// Code is generated by go generate. DO NOT EDIT.
package keibi

import (
	"context"
	aws "github.com/kaytu-io/kaytu-aws-describer/aws/model"
	essdk "github.com/kaytu-io/kaytu-util/pkg/keibi-es-sdk"
	"github.com/turbot/steampipe-plugin-sdk/v4/plugin"
)

type Client struct {
	essdk.Client
}

// ==========================  START: AccessAnalyzerAnalyzer =============================

type AccessAnalyzerAnalyzer struct {
	Description   aws.AccessAnalyzerAnalyzerDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type AccessAnalyzerAnalyzerHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  AccessAnalyzerAnalyzer `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type AccessAnalyzerAnalyzerHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []AccessAnalyzerAnalyzerHit `json:"hits"`
}

type AccessAnalyzerAnalyzerSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  AccessAnalyzerAnalyzerHits `json:"hits"`
}

type AccessAnalyzerAnalyzerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessAnalyzerAnalyzerPaginator(filters []essdk.BoolFilter, limit *int64) (AccessAnalyzerAnalyzerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_accessanalyzer_analyzer", filters, limit)
	if err != nil {
		return AccessAnalyzerAnalyzerPaginator{}, err
	}

	p := AccessAnalyzerAnalyzerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessAnalyzerAnalyzerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessAnalyzerAnalyzerPaginator) NextPage(ctx context.Context) ([]AccessAnalyzerAnalyzer, error) {
	var response AccessAnalyzerAnalyzerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessAnalyzerAnalyzer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessAnalyzerAnalyzerFilters = map[string]string{
	"akas":                      "description.Analyzer.Arn",
	"arn":                       "description.Analyzer.Arn",
	"created_at":                "description.Analyzer.CreatedAt",
	"findings":                  "description.Findings",
	"kaytu_account_id":          "metadata.SourceID",
	"last_resource_analyzed":    "description.Analyzer.LastResourceAnalyzed",
	"last_resource_analyzed_at": "description.Analyzer.LastResourceAnalyzedAt",
	"name":                      "description.Analyzer.Name",
	"status":                    "description.Analyzer.Status",
	"status_reason":             "description.Analyzer.StatusReason",
	"tags":                      "description.Analyzer.Tags",
	"title":                     "description.Analyzer.Name",
	"type":                      "description.Analyzer.Type",
}

func ListAccessAnalyzerAnalyzer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessAnalyzerAnalyzer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAccessAnalyzerAnalyzerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAccessAnalyzerAnalyzerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAccessAnalyzerAnalyzerFilters = map[string]string{
	"akas":                      "description.Analyzer.Arn",
	"arn":                       "description.Analyzer.Arn",
	"created_at":                "description.Analyzer.CreatedAt",
	"findings":                  "description.Findings",
	"kaytu_account_id":          "metadata.SourceID",
	"last_resource_analyzed":    "description.Analyzer.LastResourceAnalyzed",
	"last_resource_analyzed_at": "description.Analyzer.LastResourceAnalyzedAt",
	"name":                      "description.Analyzer.Name",
	"status":                    "description.Analyzer.Status",
	"status_reason":             "description.Analyzer.StatusReason",
	"tags":                      "description.Analyzer.Tags",
	"title":                     "description.Analyzer.Name",
	"type":                      "description.Analyzer.Type",
}

func GetAccessAnalyzerAnalyzer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessAnalyzerAnalyzer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAccessAnalyzerAnalyzerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAccessAnalyzerAnalyzerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AccessAnalyzerAnalyzer =============================

// ==========================  START: ApiGatewayStage =============================

type ApiGatewayStage struct {
	Description   aws.ApiGatewayStageDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type ApiGatewayStageHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  ApiGatewayStage `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type ApiGatewayStageHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []ApiGatewayStageHit `json:"hits"`
}

type ApiGatewayStageSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  ApiGatewayStageHits `json:"hits"`
}

type ApiGatewayStagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayStagePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayStagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_stage", filters, limit)
	if err != nil {
		return ApiGatewayStagePaginator{}, err
	}

	p := ApiGatewayStagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayStagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayStagePaginator) NextPage(ctx context.Context) ([]ApiGatewayStage, error) {
	var response ApiGatewayStageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayStage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayStageFilters = map[string]string{
	"access_log_settings":   "description.Stage.AccessLogSettings",
	"cache_cluster_enabled": "description.Stage.CacheClusterEnabled",
	"cache_cluster_size":    "description.Stage.CacheClusterSize",
	"cache_cluster_status":  "description.Stage.CacheClusterStatus",
	"canary_settings":       "description.Stage.CanarySettings",
	"client_certificate_id": "description.Stage.ClientCertificateId",
	"created_date":          "description.Stage.CreatedDate",
	"deployment_id":         "description.Stage.DeploymentId",
	"description":           "description.Stage.Description",
	"documentation_version": "description.Stage.DocumentationVersion",
	"kaytu_account_id":      "metadata.SourceID",
	"last_updated_date":     "description.Stage.LastUpdatedDate",
	"method_settings":       "description.Stage.MethodSettings",
	"name":                  "description.Stage.StageName",
	"rest_api_id":           "description.RestApiId",
	"tags":                  "description.Stage.Tags",
	"title":                 "description.Stage.StageName",
	"tracing_enabled":       "description.Stage.TracingEnabled",
	"variables":             "description.Stage.Variables",
	"web_acl_arn":           "description.Stage.WebAclArn",
}

func ListApiGatewayStage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayStage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayStagePaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayStageFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayStageFilters = map[string]string{
	"access_log_settings":   "description.Stage.AccessLogSettings",
	"cache_cluster_enabled": "description.Stage.CacheClusterEnabled",
	"cache_cluster_size":    "description.Stage.CacheClusterSize",
	"cache_cluster_status":  "description.Stage.CacheClusterStatus",
	"canary_settings":       "description.Stage.CanarySettings",
	"client_certificate_id": "description.Stage.ClientCertificateId",
	"created_date":          "description.Stage.CreatedDate",
	"deployment_id":         "description.Stage.DeploymentId",
	"description":           "description.Stage.Description",
	"documentation_version": "description.Stage.DocumentationVersion",
	"kaytu_account_id":      "metadata.SourceID",
	"last_updated_date":     "description.Stage.LastUpdatedDate",
	"method_settings":       "description.Stage.MethodSettings",
	"name":                  "description.Stage.StageName",
	"rest_api_id":           "description.RestApiId",
	"tags":                  "description.Stage.Tags",
	"title":                 "description.Stage.StageName",
	"tracing_enabled":       "description.Stage.TracingEnabled",
	"variables":             "description.Stage.Variables",
	"web_acl_arn":           "description.Stage.WebAclArn",
}

func GetApiGatewayStage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayStage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayStagePaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayStageFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayStage =============================

// ==========================  START: ApiGatewayV2Stage =============================

type ApiGatewayV2Stage struct {
	Description   aws.ApiGatewayV2StageDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ApiGatewayV2StageHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ApiGatewayV2Stage `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ApiGatewayV2StageHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ApiGatewayV2StageHit `json:"hits"`
}

type ApiGatewayV2StageSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ApiGatewayV2StageHits `json:"hits"`
}

type ApiGatewayV2StagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2StagePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2StagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_stage", filters, limit)
	if err != nil {
		return ApiGatewayV2StagePaginator{}, err
	}

	p := ApiGatewayV2StagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2StagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2StagePaginator) NextPage(ctx context.Context) ([]ApiGatewayV2Stage, error) {
	var response ApiGatewayV2StageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2Stage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2StageFilters = map[string]string{
	"api_gateway_managed":                    "description.Stage.ApiGatewayManaged",
	"api_id":                                 "description.ApiId",
	"auto_deploy":                            "description.Stage.AutoDeploy",
	"client_certificate_id":                  "description.Stage.ClientCertificateId",
	"created_date":                           "description.Stage.CreatedDate",
	"default_route_data_trace_enabled":       "description.Stage.DefaultRouteSettings.DataTraceEnabled",
	"default_route_detailed_metrics_enabled": "description.Stage.DefaultRouteSettings.DetailedMetricsEnabled",
	"default_route_logging_level":            "description.Stage.DefaultRouteSettings.LoggingLevel",
	"default_route_throttling_burst_limit":   "description.Stage.DefaultRouteSettings.ThrottlingBurstLimit",
	"default_route_throttling_rate_limit":    "description.Stage.DefaultRouteSettings.ThrottlingRateLimit",
	"deployment_id":                          "description.Stage.DeploymentId",
	"description":                            "description.Stage.Description",
	"kaytu_account_id":                       "metadata.SourceID",
	"last_deployment_status_message":         "description.Stage.LastDeploymentStatusMessage",
	"last_updated_date":                      "description.Stage.LastUpdatedDate",
	"stage_name":                             "description.Stage.StageName",
	"stage_variables":                        "description.Stage.StageVariables",
	"tags":                                   "description.Stage.Tags",
	"title":                                  "description.Stage.StageName",
}

func ListApiGatewayV2Stage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2Stage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayV2StagePaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayV2StageFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayV2StageFilters = map[string]string{
	"api_gateway_managed":                    "description.Stage.ApiGatewayManaged",
	"api_id":                                 "description.ApiId",
	"auto_deploy":                            "description.Stage.AutoDeploy",
	"client_certificate_id":                  "description.Stage.ClientCertificateId",
	"created_date":                           "description.Stage.CreatedDate",
	"default_route_data_trace_enabled":       "description.Stage.DefaultRouteSettings.DataTraceEnabled",
	"default_route_detailed_metrics_enabled": "description.Stage.DefaultRouteSettings.DetailedMetricsEnabled",
	"default_route_logging_level":            "description.Stage.DefaultRouteSettings.LoggingLevel",
	"default_route_throttling_burst_limit":   "description.Stage.DefaultRouteSettings.ThrottlingBurstLimit",
	"default_route_throttling_rate_limit":    "description.Stage.DefaultRouteSettings.ThrottlingRateLimit",
	"deployment_id":                          "description.Stage.DeploymentId",
	"description":                            "description.Stage.Description",
	"kaytu_account_id":                       "metadata.SourceID",
	"last_deployment_status_message":         "description.Stage.LastDeploymentStatusMessage",
	"last_updated_date":                      "description.Stage.LastUpdatedDate",
	"name":                                   "description.Stage.StageName",
	"stage_name":                             "description.Stage.StageName",
	"stage_variables":                        "description.Stage.StageVariables",
	"tags":                                   "description.Stage.Tags",
	"title":                                  "description.Stage.StageName",
}

func GetApiGatewayV2Stage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2Stage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2StagePaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayV2StageFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2Stage =============================

// ==========================  START: ApiGatewayRestAPI =============================

type ApiGatewayRestAPI struct {
	Description   aws.ApiGatewayRestAPIDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ApiGatewayRestAPIHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ApiGatewayRestAPI `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ApiGatewayRestAPIHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ApiGatewayRestAPIHit `json:"hits"`
}

type ApiGatewayRestAPISearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ApiGatewayRestAPIHits `json:"hits"`
}

type ApiGatewayRestAPIPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayRestAPIPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayRestAPIPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_restapi", filters, limit)
	if err != nil {
		return ApiGatewayRestAPIPaginator{}, err
	}

	p := ApiGatewayRestAPIPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayRestAPIPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayRestAPIPaginator) NextPage(ctx context.Context) ([]ApiGatewayRestAPI, error) {
	var response ApiGatewayRestAPISearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayRestAPI
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayRestAPIFilters = map[string]string{
	"api_id":                       "description.RestAPI.Id",
	"api_key_source":               "description.RestAPI.ApiKeySource",
	"binary_media_types":           "description.RestAPI.BinaryMediaTypes",
	"created_date":                 "description.RestAPI.CreatedDate",
	"description":                  "description.RestAPI.Description",
	"endpoint_configuration_types": "description.RestAPI.EndpointConfiguration.Types",
	"endpoint_configuration_vpc_endpoint_ids": "description.RestAPI.EndpointConfiguration.VpcEndpointIds",
	"kaytu_account_id":                        "metadata.SourceID",
	"minimum_compression_size":                "description.RestAPI.MinimumCompressionSize",
	"name":                                    "description.RestAPI.Name",
	"policy":                                  "description.RestAPI.Policy",
	"policy_std":                              "description.RestAPI.Policy",
	"tags":                                    "description.RestAPI.Tags",
	"title":                                   "description.RestAPI.Name",
	"version":                                 "description.RestAPI.Version",
	"warnings":                                "description.RestAPI.Warnings",
}

func ListApiGatewayRestAPI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayRestAPI")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayRestAPIPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayRestAPIFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayRestAPIFilters = map[string]string{
	"api_id":                       "description.RestAPI.Id",
	"api_key_source":               "description.RestAPI.ApiKeySource",
	"binary_media_types":           "description.RestAPI.BinaryMediaTypes",
	"created_date":                 "description.RestAPI.CreatedDate",
	"description":                  "description.RestAPI.Description",
	"endpoint_configuration_types": "description.RestAPI.EndpointConfiguration.Types",
	"endpoint_configuration_vpc_endpoint_ids": "description.RestAPI.EndpointConfiguration.VpcEndpointIds",
	"kaytu_account_id":                        "metadata.SourceID",
	"minimum_compression_size":                "description.RestAPI.MinimumCompressionSize",
	"name":                                    "description.RestAPI.Name",
	"policy":                                  "description.RestAPI.Policy",
	"policy_std":                              "description.RestAPI.Policy",
	"tags":                                    "description.RestAPI.Tags",
	"title":                                   "description.RestAPI.Name",
	"version":                                 "description.RestAPI.Version",
	"warnings":                                "description.RestAPI.Warnings",
}

func GetApiGatewayRestAPI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayRestAPI")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayRestAPIPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayRestAPIFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayRestAPI =============================

// ==========================  START: ApiGatewayApiKey =============================

type ApiGatewayApiKey struct {
	Description   aws.ApiGatewayApiKeyDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type ApiGatewayApiKeyHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ApiGatewayApiKey `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ApiGatewayApiKeyHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ApiGatewayApiKeyHit `json:"hits"`
}

type ApiGatewayApiKeySearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ApiGatewayApiKeyHits `json:"hits"`
}

type ApiGatewayApiKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayApiKeyPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayApiKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_apikey", filters, limit)
	if err != nil {
		return ApiGatewayApiKeyPaginator{}, err
	}

	p := ApiGatewayApiKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayApiKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayApiKeyPaginator) NextPage(ctx context.Context) ([]ApiGatewayApiKey, error) {
	var response ApiGatewayApiKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayApiKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayApiKeyFilters = map[string]string{
	"akas":              "aRN",
	"created_date":      "description.ApiKey.CreatedDate",
	"customer_id":       "description.ApiKey.CustomerId",
	"description":       "description.ApiKey.Description",
	"enabled":           "description.ApiKey.Enabled",
	"id":                "description.ApiKey.Id",
	"kaytu_account_id":  "metadata.SourceID",
	"last_updated_date": "description.ApiKey.LastUpdatedDate",
	"name":              "description.ApiKey.Name",
	"stage_keys":        "description.ApiKey.StageKeys",
	"tags":              "description.ApiKey.Tags",
	"tags_src":          "description.ApiKey.Tags",
	"title":             "description.ApiKey.Name",
	"value":             "description.ApiKey.Value",
}

func ListApiGatewayApiKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayApiKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayApiKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayApiKeyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayApiKeyFilters = map[string]string{
	"akas":              "aRN",
	"created_date":      "description.ApiKey.CreatedDate",
	"customer_id":       "description.ApiKey.CustomerId",
	"description":       "description.ApiKey.Description",
	"enabled":           "description.ApiKey.Enabled",
	"id":                "description.ApiKey.Id",
	"kaytu_account_id":  "metadata.SourceID",
	"last_updated_date": "description.ApiKey.LastUpdatedDate",
	"name":              "description.ApiKey.Name",
	"stage_keys":        "description.ApiKey.StageKeys",
	"tags":              "description.ApiKey.Tags",
	"tags_src":          "description.ApiKey.Tags",
	"title":             "description.ApiKey.Name",
	"value":             "description.ApiKey.Value",
}

func GetApiGatewayApiKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayApiKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayApiKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayApiKeyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayApiKey =============================

// ==========================  START: ApiGatewayUsagePlan =============================

type ApiGatewayUsagePlan struct {
	Description   aws.ApiGatewayUsagePlanDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type ApiGatewayUsagePlanHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ApiGatewayUsagePlan `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ApiGatewayUsagePlanHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ApiGatewayUsagePlanHit `json:"hits"`
}

type ApiGatewayUsagePlanSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ApiGatewayUsagePlanHits `json:"hits"`
}

type ApiGatewayUsagePlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayUsagePlanPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayUsagePlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_usageplan", filters, limit)
	if err != nil {
		return ApiGatewayUsagePlanPaginator{}, err
	}

	p := ApiGatewayUsagePlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayUsagePlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayUsagePlanPaginator) NextPage(ctx context.Context) ([]ApiGatewayUsagePlan, error) {
	var response ApiGatewayUsagePlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayUsagePlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayUsagePlanFilters = map[string]string{
	"akas":             "aRN",
	"api_stages":       "description.UsagePlan.ApiStages",
	"description":      "description.UsagePlan.Description",
	"id":               "description.UsagePlan.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.UsagePlan.Name",
	"product_code":     "description.UsagePlan.ProductCode",
	"quota":            "description.UsagePlan.Quota",
	"tags":             "description.UsagePlan.Tags",
	"throttle":         "description.UsagePlan.Throttle",
	"title":            "description.UsagePlan.Name",
}

func ListApiGatewayUsagePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayUsagePlan")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayUsagePlanPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayUsagePlanFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayUsagePlanFilters = map[string]string{
	"akas":             "aRN",
	"api_stages":       "description.UsagePlan.ApiStages",
	"description":      "description.UsagePlan.Description",
	"id":               "description.UsagePlan.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.UsagePlan.Name",
	"product_code":     "description.UsagePlan.ProductCode",
	"quota":            "description.UsagePlan.Quota",
	"tags":             "description.UsagePlan.Tags",
	"throttle":         "description.UsagePlan.Throttle",
	"title":            "description.UsagePlan.Name",
}

func GetApiGatewayUsagePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayUsagePlan")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayUsagePlanPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayUsagePlanFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayUsagePlan =============================

// ==========================  START: ApiGatewayAuthorizer =============================

type ApiGatewayAuthorizer struct {
	Description   aws.ApiGatewayAuthorizerDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ApiGatewayAuthorizerHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ApiGatewayAuthorizer `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ApiGatewayAuthorizerHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ApiGatewayAuthorizerHit `json:"hits"`
}

type ApiGatewayAuthorizerSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ApiGatewayAuthorizerHits `json:"hits"`
}

type ApiGatewayAuthorizerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayAuthorizerPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayAuthorizerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_authorizer", filters, limit)
	if err != nil {
		return ApiGatewayAuthorizerPaginator{}, err
	}

	p := ApiGatewayAuthorizerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayAuthorizerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayAuthorizerPaginator) NextPage(ctx context.Context) ([]ApiGatewayAuthorizer, error) {
	var response ApiGatewayAuthorizerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayAuthorizer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayAuthorizerFilters = map[string]string{
	"akas":                           "aRN",
	"auth_type":                      "description.Authorizer.AuthType",
	"authorizer_credentials":         "description.Authorizer.AuthorizerCredentials",
	"authorizer_uri":                 "description.Authorizer.AuthorizerUri",
	"id":                             "description.Authorizer.Id",
	"identity_source":                "description.Authorizer.IdentitySource",
	"identity_validation_expression": "description.Authorizer.IdentityValidationExpression",
	"kaytu_account_id":               "metadata.SourceID",
	"name":                           "description.Authorizer.Name",
	"provider_arns":                  "description.Authorizer.ProviderARNs",
	"rest_api_id":                    "description.RestApiId",
	"title":                          "description.Authorizer.Name",
}

func ListApiGatewayAuthorizer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayAuthorizer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayAuthorizerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayAuthorizerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayAuthorizerFilters = map[string]string{
	"akas":                           "aRN",
	"auth_type":                      "description.Authorizer.AuthType",
	"authorizer_credentials":         "description.Authorizer.AuthorizerCredentials",
	"authorizer_uri":                 "description.Authorizer.AuthorizerUri",
	"id":                             "description.Authorizer.Id",
	"identity_source":                "description.Authorizer.IdentitySource",
	"identity_validation_expression": "description.Authorizer.IdentityValidationExpression",
	"kaytu_account_id":               "metadata.SourceID",
	"name":                           "description.Authorizer.Name",
	"provider_arns":                  "description.Authorizer.ProviderARNs",
	"rest_api_id":                    "description.RestApiId",
	"title":                          "description.Authorizer.Name",
}

func GetApiGatewayAuthorizer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayAuthorizer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayAuthorizerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayAuthorizerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayAuthorizer =============================

// ==========================  START: ApiGatewayV2API =============================

type ApiGatewayV2API struct {
	Description   aws.ApiGatewayV2APIDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type ApiGatewayV2APIHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  ApiGatewayV2API `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type ApiGatewayV2APIHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []ApiGatewayV2APIHit `json:"hits"`
}

type ApiGatewayV2APISearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  ApiGatewayV2APIHits `json:"hits"`
}

type ApiGatewayV2APIPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2APIPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2APIPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_api", filters, limit)
	if err != nil {
		return ApiGatewayV2APIPaginator{}, err
	}

	p := ApiGatewayV2APIPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2APIPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2APIPaginator) NextPage(ctx context.Context) ([]ApiGatewayV2API, error) {
	var response ApiGatewayV2APISearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2API
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2APIFilters = map[string]string{
	"api_endpoint":                 "description.API.ApiEndpoint",
	"api_id":                       "description.API.ApiId",
	"api_key_selection_expression": "description.API.ApiKeySelectionExpression",
	"created_date":                 "description.API.CreatedDate",
	"disable_execute_api_endpoint": "description.API.DisableExecuteApiEndpoint",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.API.Name",
	"protocol_type":                "description.API.ProtocolType",
	"route_selection_expression":   "description.API.RouteSelectionExpression",
	"tags":                         "description.API.Tags",
	"title":                        "description.API.Name",
}

func ListApiGatewayV2API(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2API")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayV2APIPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayV2APIFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayV2APIFilters = map[string]string{
	"api_endpoint":                 "description.API.ApiEndpoint",
	"api_id":                       "description.API.ApiId",
	"api_key_selection_expression": "description.API.ApiKeySelectionExpression",
	"created_date":                 "description.API.CreatedDate",
	"disable_execute_api_endpoint": "description.API.DisableExecuteApiEndpoint",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.API.Name",
	"protocol_type":                "description.API.ProtocolType",
	"route_selection_expression":   "description.API.RouteSelectionExpression",
	"tags":                         "description.API.Tags",
	"title":                        "description.API.Name",
}

func GetApiGatewayV2API(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2API")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2APIPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayV2APIFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2API =============================

// ==========================  START: ApiGatewayV2DomainName =============================

type ApiGatewayV2DomainName struct {
	Description   aws.ApiGatewayV2DomainNameDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ApiGatewayV2DomainNameHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ApiGatewayV2DomainName `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ApiGatewayV2DomainNameHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ApiGatewayV2DomainNameHit `json:"hits"`
}

type ApiGatewayV2DomainNameSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ApiGatewayV2DomainNameHits `json:"hits"`
}

type ApiGatewayV2DomainNamePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2DomainNamePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2DomainNamePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_domainname", filters, limit)
	if err != nil {
		return ApiGatewayV2DomainNamePaginator{}, err
	}

	p := ApiGatewayV2DomainNamePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2DomainNamePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2DomainNamePaginator) NextPage(ctx context.Context) ([]ApiGatewayV2DomainName, error) {
	var response ApiGatewayV2DomainNameSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2DomainName
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2DomainNameFilters = map[string]string{
	"akas":                       "aRN",
	"domain_name":                "description.DomainName.DomainName",
	"domain_name_configurations": "description.DomainName.DomainNameConfigurations",
	"kaytu_account_id":           "metadata.SourceID",
	"mutual_tls_authentication":  "description.DomainName.MutualTlsAuthentication",
	"tags":                       "description.DomainName.Tags",
	"title":                      "description.DomainName.DomainName",
}

func ListApiGatewayV2DomainName(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2DomainName")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayV2DomainNamePaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayV2DomainNameFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayV2DomainNameFilters = map[string]string{
	"akas":                       "aRN",
	"domain_name":                "description.DomainName.DomainName",
	"domain_name_configurations": "description.DomainName.DomainNameConfigurations",
	"kaytu_account_id":           "metadata.SourceID",
	"mutual_tls_authentication":  "description.DomainName.MutualTlsAuthentication",
	"tags":                       "description.DomainName.Tags",
	"title":                      "description.DomainName.DomainName",
}

func GetApiGatewayV2DomainName(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2DomainName")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2DomainNamePaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayV2DomainNameFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2DomainName =============================

// ==========================  START: ApiGatewayV2Integration =============================

type ApiGatewayV2Integration struct {
	Description   aws.ApiGatewayV2IntegrationDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type ApiGatewayV2IntegrationHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  ApiGatewayV2Integration `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type ApiGatewayV2IntegrationHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []ApiGatewayV2IntegrationHit `json:"hits"`
}

type ApiGatewayV2IntegrationSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  ApiGatewayV2IntegrationHits `json:"hits"`
}

type ApiGatewayV2IntegrationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2IntegrationPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2IntegrationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_integration", filters, limit)
	if err != nil {
		return ApiGatewayV2IntegrationPaginator{}, err
	}

	p := ApiGatewayV2IntegrationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2IntegrationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2IntegrationPaginator) NextPage(ctx context.Context) ([]ApiGatewayV2Integration, error) {
	var response ApiGatewayV2IntegrationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2Integration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2IntegrationFilters = map[string]string{
	"akas":                      "aRN",
	"api_gateway_managed":       "description.Integration.ApiGatewayManaged",
	"api_id":                    "description.ApiId",
	"arn":                       "aRN",
	"connection_id":             "description.Integration.ConnectionId",
	"connection_type":           "description.Integration.ConnectionType",
	"content_handling_strategy": "description.Integration.ContentHandlingStrategy",
	"credentials_arn":           "description.Integration.CredentialsArn",
	"description":               "description.Integration.Description",
	"integration_id":            "description.Integration.IntegrationId",
	"integration_method":        "description.Integration.IntegrationMethod",
	"integration_response_selection_expression": "description.Integration.IntegrationResponseSelectionExpression",
	"integration_subtype":                       "description.Integration.IntegrationSubtype",
	"integration_type":                          "description.Integration.IntegrationType",
	"integration_uri":                           "description.Integration.IntegrationUri",
	"kaytu_account_id":                          "metadata.SourceID",
	"passthrough_behavior":                      "description.Integration.PassthroughBehavior",
	"payload_format_version":                    "description.Integration.PayloadFormatVersion",
	"request_parameters":                        "description.Integration.RequestParameters",
	"request_templates":                         "description.Integration.RequestTemplates",
	"response_parameters":                       "description.Integration.ResponseParameters",
	"template_selection_expression":             "description.Integration.TemplateSelectionExpression",
	"timeout_in_millis":                         "description.Integration.TimeoutInMillis",
	"title":                                     "description.Integration.IntegrationId",
	"tls_config":                                "description.Integration.TlsConfig",
}

func ListApiGatewayV2Integration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2Integration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApiGatewayV2IntegrationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApiGatewayV2IntegrationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApiGatewayV2IntegrationFilters = map[string]string{
	"akas":                      "aRN",
	"api_gateway_managed":       "description.Integration.ApiGatewayManaged",
	"api_id":                    "description.ApiId",
	"arn":                       "aRN",
	"connection_id":             "description.Integration.ConnectionId",
	"connection_type":           "description.Integration.ConnectionType",
	"content_handling_strategy": "description.Integration.ContentHandlingStrategy",
	"credentials_arn":           "description.Integration.CredentialsArn",
	"description":               "description.Integration.Description",
	"integration_id":            "description.Integration.IntegrationId",
	"integration_method":        "description.Integration.IntegrationMethod",
	"integration_response_selection_expression": "description.Integration.IntegrationResponseSelectionExpression",
	"integration_subtype":                       "description.Integration.IntegrationSubtype",
	"integration_type":                          "description.Integration.IntegrationType",
	"integration_uri":                           "description.Integration.IntegrationUri",
	"kaytu_account_id":                          "metadata.SourceID",
	"passthrough_behavior":                      "description.Integration.PassthroughBehavior",
	"payload_format_version":                    "description.Integration.PayloadFormatVersion",
	"request_parameters":                        "description.Integration.RequestParameters",
	"request_templates":                         "description.Integration.RequestTemplates",
	"response_parameters":                       "description.Integration.ResponseParameters",
	"template_selection_expression":             "description.Integration.TemplateSelectionExpression",
	"timeout_in_millis":                         "description.Integration.TimeoutInMillis",
	"title":                                     "description.Integration.IntegrationId",
	"tls_config":                                "description.Integration.TlsConfig",
}

func GetApiGatewayV2Integration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2Integration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2IntegrationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApiGatewayV2IntegrationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2Integration =============================

// ==========================  START: ElasticBeanstalkEnvironment =============================

type ElasticBeanstalkEnvironment struct {
	Description   aws.ElasticBeanstalkEnvironmentDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ElasticBeanstalkEnvironmentHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ElasticBeanstalkEnvironment `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ElasticBeanstalkEnvironmentHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ElasticBeanstalkEnvironmentHit `json:"hits"`
}

type ElasticBeanstalkEnvironmentSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ElasticBeanstalkEnvironmentHits `json:"hits"`
}

type ElasticBeanstalkEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticBeanstalkEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticBeanstalkEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticbeanstalk_environment", filters, limit)
	if err != nil {
		return ElasticBeanstalkEnvironmentPaginator{}, err
	}

	p := ElasticBeanstalkEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticBeanstalkEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticBeanstalkEnvironmentPaginator) NextPage(ctx context.Context) ([]ElasticBeanstalkEnvironment, error) {
	var response ElasticBeanstalkEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticBeanstalkEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticBeanstalkEnvironmentFilters = map[string]string{
	"abortable_operation_in_progress": "description.EnvironmentDescription.AbortableOperationInProgress",
	"akas":                            "description.EnvironmentDescription.EnvironmentArn",
	"application_name":                "description.EnvironmentDescription.ApplicationName",
	"arn":                             "description.EnvironmentDescription.EnvironmentArn",
	"cname":                           "description.EnvironmentDescription.CNAME",
	"date-created":                    "description.EnvironmentDescription.DateCreated",
	"date_updated":                    "description.EnvironmentDescription.DateUpdated",
	"description":                     "description.EnvironmentDescription",
	"endpoint_url":                    "description.EnvironmentDescription.EndpointURL",
	"environment_id":                  "description.EnvironmentDescription.EnvironmentId",
	"environment_links":               "description.EnvironmentDescription.EnvironmentLinks",
	"environment_name":                "description.EnvironmentDescription.EnvironmentName",
	"health":                          "description.EnvironmentDescription.Health",
	"health_status":                   "description.EnvironmentDescription.HealthStatus",
	"kaytu_account_id":                "metadata.SourceID",
	"operations_role":                 "description.EnvironmentDescription.OperationsRole",
	"platform_arn":                    "description.EnvironmentDescription.PlatformArn",
	"resources":                       "description.EnvironmentDescription.Resources",
	"solution_stack_name":             "description.EnvironmentDescription.SolutionStackName",
	"status":                          "description.EnvironmentDescription.Status",
	"tags":                            "description.Tags",
	"tags_src":                        "description.Tags",
	"template_name":                   "description.EnvironmentDescription.TemplateName",
	"tier":                            "description.EnvironmentDescription.Tier",
	"title":                           "description.EnvironmentDescription.EnvironmentName",
	"version_label":                   "description.EnvironmentDescription.VersionLabel",
}

func ListElasticBeanstalkEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticBeanstalkEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticBeanstalkEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticBeanstalkEnvironmentFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticBeanstalkEnvironmentFilters = map[string]string{
	"abortable_operation_in_progress": "description.EnvironmentDescription.AbortableOperationInProgress",
	"akas":                            "description.EnvironmentDescription.EnvironmentArn",
	"application_name":                "description.EnvironmentDescription.ApplicationName",
	"arn":                             "description.EnvironmentDescription.EnvironmentArn",
	"cname":                           "description.EnvironmentDescription.CNAME",
	"date-created":                    "description.EnvironmentDescription.DateCreated",
	"date_updated":                    "description.EnvironmentDescription.DateUpdated",
	"description":                     "description.EnvironmentDescription",
	"endpoint_url":                    "description.EnvironmentDescription.EndpointURL",
	"environment_id":                  "description.EnvironmentDescription.EnvironmentId",
	"environment_links":               "description.EnvironmentDescription.EnvironmentLinks",
	"environment_name":                "description.EnvironmentDescription.EnvironmentName",
	"health":                          "description.EnvironmentDescription.Health",
	"health_status":                   "description.EnvironmentDescription.HealthStatus",
	"kaytu_account_id":                "metadata.SourceID",
	"operations_role":                 "description.EnvironmentDescription.OperationsRole",
	"platform_arn":                    "description.EnvironmentDescription.PlatformArn",
	"resources":                       "description.EnvironmentDescription.Resources",
	"solution_stack_name":             "description.EnvironmentDescription.SolutionStackName",
	"status":                          "description.EnvironmentDescription.Status",
	"tags":                            "description.Tags",
	"tags_src":                        "description.Tags",
	"template_name":                   "description.EnvironmentDescription.TemplateName",
	"tier":                            "description.EnvironmentDescription.Tier",
	"title":                           "description.EnvironmentDescription.EnvironmentName",
	"version_label":                   "description.EnvironmentDescription.VersionLabel",
}

func GetElasticBeanstalkEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticBeanstalkEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticBeanstalkEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticBeanstalkEnvironmentFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticBeanstalkEnvironment =============================

// ==========================  START: ElasticBeanstalkApplication =============================

type ElasticBeanstalkApplication struct {
	Description   aws.ElasticBeanstalkApplicationDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ElasticBeanstalkApplicationHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ElasticBeanstalkApplication `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ElasticBeanstalkApplicationHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ElasticBeanstalkApplicationHit `json:"hits"`
}

type ElasticBeanstalkApplicationSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ElasticBeanstalkApplicationHits `json:"hits"`
}

type ElasticBeanstalkApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticBeanstalkApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticBeanstalkApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticbeanstalk_application", filters, limit)
	if err != nil {
		return ElasticBeanstalkApplicationPaginator{}, err
	}

	p := ElasticBeanstalkApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticBeanstalkApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticBeanstalkApplicationPaginator) NextPage(ctx context.Context) ([]ElasticBeanstalkApplication, error) {
	var response ElasticBeanstalkApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticBeanstalkApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticBeanstalkApplicationFilters = map[string]string{
	"akas":                      "description.Application.ApplicationArn",
	"arn":                       "description.Application.ApplicationArn",
	"configuration_templates":   "description.Application.ConfigurationTemplates",
	"date_created":              "description.Application.DateCreated",
	"date_updated":              "description.Application.DateUpdated",
	"description":               "description.Application.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.Application.ApplicationName",
	"resource_lifecycle_config": "description.Application.ResourceLifecycleConfig",
	"tags_src":                  "description.Tags",
	"title":                     "description.Application.ApplicationName",
	"versions":                  "description.Application.Versions",
}

func ListElasticBeanstalkApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticBeanstalkApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticBeanstalkApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticBeanstalkApplicationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticBeanstalkApplicationFilters = map[string]string{
	"akas":                      "description.Application.ApplicationArn",
	"arn":                       "description.Application.ApplicationArn",
	"configuration_templates":   "description.Application.ConfigurationTemplates",
	"date_created":              "description.Application.DateCreated",
	"date_updated":              "description.Application.DateUpdated",
	"description":               "description.Application.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.Application.ApplicationName",
	"resource_lifecycle_config": "description.Application.ResourceLifecycleConfig",
	"tags_src":                  "description.Tags",
	"title":                     "description.Application.ApplicationName",
	"versions":                  "description.Application.Versions",
}

func GetElasticBeanstalkApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticBeanstalkApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticBeanstalkApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticBeanstalkApplicationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticBeanstalkApplication =============================

// ==========================  START: ElastiCacheReplicationGroup =============================

type ElastiCacheReplicationGroup struct {
	Description   aws.ElastiCacheReplicationGroupDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ElastiCacheReplicationGroupHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ElastiCacheReplicationGroup `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ElastiCacheReplicationGroupHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ElastiCacheReplicationGroupHit `json:"hits"`
}

type ElastiCacheReplicationGroupSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ElastiCacheReplicationGroupHits `json:"hits"`
}

type ElastiCacheReplicationGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheReplicationGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheReplicationGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_replicationgroup", filters, limit)
	if err != nil {
		return ElastiCacheReplicationGroupPaginator{}, err
	}

	p := ElastiCacheReplicationGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheReplicationGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheReplicationGroupPaginator) NextPage(ctx context.Context) ([]ElastiCacheReplicationGroup, error) {
	var response ElastiCacheReplicationGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheReplicationGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheReplicationGroupFilters = map[string]string{
	"akas":                          "description.ReplicationGroup.ARN",
	"arn":                           "description.ReplicationGroup.ARN",
	"at_rest_encryption_enabled":    "description.ReplicationGroup.AtRestEncryptionEnabled",
	"auth_token_enabled":            "description.ReplicationGroup.AuthTokenEnabled",
	"auth_token_last_modified_date": "description.ReplicationGroup.AuthTokenLastModifiedDate",
	"automatic_failover":            "description.ReplicationGroup.AutomaticFailover",
	"cache_node_type":               "description.ReplicationGroup.CacheNodeType",
	"cluster_enabled":               "description.ReplicationGroup.ClusterEnabled",
	"configuration_endpoint":        "description.ReplicationGroup.ConfigurationEndpoint",
	"description":                   "description.ReplicationGroup.Description",
	"global_replication_group_info": "description.ReplicationGroup.GlobalReplicationGroupInfo",
	"kaytu_account_id":              "metadata.SourceID",
	"kms_key_id":                    "description.ReplicationGroup.KmsKeyId",
	"member_clusters":               "description.ReplicationGroup.MemberClusters",
	"member_clusters_outpost_arns":  "description.ReplicationGroup.MemberClustersOutpostArns",
	"multi_az":                      "description.ReplicationGroup.MultiAZ",
	"node_groups":                   "description.ReplicationGroup.NodeGroups",
	"pending_modified_values":       "description.ReplicationGroup.PendingModifiedValues",
	"replication_group_id":          "description.ReplicationGroup.ReplicationGroupId",
	"snapshot_retention_limit":      "description.ReplicationGroup.SnapshotRetentionLimit",
	"snapshot_window":               "description.ReplicationGroup.SnapshotWindow",
	"snapshotting_cluster_id":       "description.ReplicationGroup.SnapshottingClusterId",
	"status":                        "description.ReplicationGroup.Status",
	"title":                         "description.ReplicationGroup.ReplicationGroupId",
	"transit_encryption_enabled":    "description.ReplicationGroup.TransitEncryptionEnabled",
	"user_group_ids":                "description.ReplicationGroup.UserGroupIds",
}

func ListElastiCacheReplicationGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheReplicationGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElastiCacheReplicationGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElastiCacheReplicationGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElastiCacheReplicationGroupFilters = map[string]string{
	"akas":                          "description.ReplicationGroup.ARN",
	"arn":                           "description.ReplicationGroup.ARN",
	"at_rest_encryption_enabled":    "description.ReplicationGroup.AtRestEncryptionEnabled",
	"auth_token_enabled":            "description.ReplicationGroup.AuthTokenEnabled",
	"auth_token_last_modified_date": "description.ReplicationGroup.AuthTokenLastModifiedDate",
	"automatic_failover":            "description.ReplicationGroup.AutomaticFailover",
	"cache_node_type":               "description.ReplicationGroup.CacheNodeType",
	"cluster_enabled":               "description.ReplicationGroup.ClusterEnabled",
	"configuration_endpoint":        "description.ReplicationGroup.ConfigurationEndpoint",
	"description":                   "description.ReplicationGroup.Description",
	"global_replication_group_info": "description.ReplicationGroup.GlobalReplicationGroupInfo",
	"kaytu_account_id":              "metadata.SourceID",
	"kms_key_id":                    "description.ReplicationGroup.KmsKeyId",
	"member_clusters":               "description.ReplicationGroup.MemberClusters",
	"member_clusters_outpost_arns":  "description.ReplicationGroup.MemberClustersOutpostArns",
	"multi_az":                      "description.ReplicationGroup.MultiAZ",
	"node_groups":                   "description.ReplicationGroup.NodeGroups",
	"pending_modified_values":       "description.ReplicationGroup.PendingModifiedValues",
	"replication_group_id":          "description.ReplicationGroup.ReplicationGroupId",
	"snapshot_retention_limit":      "description.ReplicationGroup.SnapshotRetentionLimit",
	"snapshot_window":               "description.ReplicationGroup.SnapshotWindow",
	"snapshotting_cluster_id":       "description.ReplicationGroup.SnapshottingClusterId",
	"status":                        "description.ReplicationGroup.Status",
	"title":                         "description.ReplicationGroup.ReplicationGroupId",
	"transit_encryption_enabled":    "description.ReplicationGroup.TransitEncryptionEnabled",
	"user_group_ids":                "description.ReplicationGroup.UserGroupIds",
}

func GetElastiCacheReplicationGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheReplicationGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElastiCacheReplicationGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElastiCacheReplicationGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElastiCacheReplicationGroup =============================

// ==========================  START: ElastiCacheCluster =============================

type ElastiCacheCluster struct {
	Description   aws.ElastiCacheClusterDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type ElastiCacheClusterHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ElastiCacheCluster `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ElastiCacheClusterHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []ElastiCacheClusterHit `json:"hits"`
}

type ElastiCacheClusterSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ElastiCacheClusterHits `json:"hits"`
}

type ElastiCacheClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheClusterPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_cluster", filters, limit)
	if err != nil {
		return ElastiCacheClusterPaginator{}, err
	}

	p := ElastiCacheClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheClusterPaginator) NextPage(ctx context.Context) ([]ElastiCacheCluster, error) {
	var response ElastiCacheClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheClusterFilters = map[string]string{
	"akas":                         "description.Cluster.ARN",
	"arn":                          "description.Cluster.ARN",
	"at_rest_encryption_enabled":   "description.Cluster.AtRestEncryptionEnabled",
	"auth_token_enabled":           "description.Cluster.AuthTokenEnabled",
	"auto_minor_version_upgrade":   "description.Cluster.AutoMinorVersionUpgrade",
	"cache_cluster_create_time":    "description.Cluster.CacheClusterCreateTime",
	"cache_cluster_id":             "description.Cluster.CacheClusterId",
	"cache_cluster_status":         "description.Cluster.CacheClusterStatus",
	"cache_node_type":              "description.Cluster.CacheNodeType",
	"cache_parameter_group":        "description.Cluster.CacheParameterGroup",
	"cache_subnet_group_name":      "description.Cluster.CacheSubnetGroupName",
	"client_download_landing_page": "description.Cluster.ClientDownloadLandingPage",
	"configuration_endpoint":       "description.Cluster.ConfigurationEndpoint",
	"engine":                       "description.Cluster.Engine",
	"engine_version":               "description.Cluster.EngineVersion",
	"kaytu_account_id":             "metadata.SourceID",
	"notification_configuration":   "description.Cluster.NotificationConfiguration",
	"num_cache_nodes":              "description.Cluster.NumCacheNodes",
	"pending_modified_values":      "description.Cluster.PendingModifiedValues",
	"preferred_availability_zone":  "description.Cluster.PreferredAvailabilityZone",
	"preferred_maintenance_window": "description.Cluster.PreferredMaintenanceWindow",
	"replication_group_id":         "description.Cluster.ReplicationGroupId",
	"security_groups":              "description.Cluster.SecurityGroups",
	"snapshot_retention_limit":     "description.Cluster.SnapshotRetentionLimit",
	"snapshot_window":              "description.Cluster.SnapshotWindow",
	"tags":                         "description.TagList",
	"tags_src":                     "description.TagList",
	"title":                        "description.Cluster.CacheClusterId",
	"transit_encryption_enabled":   "description.Cluster.TransitEncryptionEnabled",
}

func ListElastiCacheCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElastiCacheClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElastiCacheClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElastiCacheClusterFilters = map[string]string{
	"akas":                         "description.Cluster.ARN",
	"arn":                          "description.Cluster.ARN",
	"at_rest_encryption_enabled":   "description.Cluster.AtRestEncryptionEnabled",
	"auth_token_enabled":           "description.Cluster.AuthTokenEnabled",
	"auto_minor_version_upgrade":   "description.Cluster.AutoMinorVersionUpgrade",
	"cache_cluster_create_time":    "description.Cluster.CacheClusterCreateTime",
	"cache_cluster_id":             "description.Cluster.CacheClusterId",
	"cache_cluster_status":         "description.Cluster.CacheClusterStatus",
	"cache_node_type":              "description.Cluster.CacheNodeType",
	"cache_parameter_group":        "description.Cluster.CacheParameterGroup",
	"cache_subnet_group_name":      "description.Cluster.CacheSubnetGroupName",
	"client_download_landing_page": "description.Cluster.ClientDownloadLandingPage",
	"configuration_endpoint":       "description.Cluster.ConfigurationEndpoint",
	"engine":                       "description.Cluster.Engine",
	"engine_version":               "description.Cluster.EngineVersion",
	"kaytu_account_id":             "metadata.SourceID",
	"notification_configuration":   "description.Cluster.NotificationConfiguration",
	"num_cache_nodes":              "description.Cluster.NumCacheNodes",
	"pending_modified_values":      "description.Cluster.PendingModifiedValues",
	"preferred_availability_zone":  "description.Cluster.PreferredAvailabilityZone",
	"preferred_maintenance_window": "description.Cluster.PreferredMaintenanceWindow",
	"replication_group_id":         "description.Cluster.ReplicationGroupId",
	"security_groups":              "description.Cluster.SecurityGroups",
	"snapshot_retention_limit":     "description.Cluster.SnapshotRetentionLimit",
	"snapshot_window":              "description.Cluster.SnapshotWindow",
	"tags":                         "description.TagList",
	"tags_src":                     "description.TagList",
	"title":                        "description.Cluster.CacheClusterId",
	"transit_encryption_enabled":   "description.Cluster.TransitEncryptionEnabled",
}

func GetElastiCacheCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElastiCacheClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElastiCacheClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElastiCacheCluster =============================

// ==========================  START: ElastiCacheParameterGroup =============================

type ElastiCacheParameterGroup struct {
	Description   aws.ElastiCacheParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type ElastiCacheParameterGroupHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  ElastiCacheParameterGroup `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type ElastiCacheParameterGroupHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []ElastiCacheParameterGroupHit `json:"hits"`
}

type ElastiCacheParameterGroupSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  ElastiCacheParameterGroupHits `json:"hits"`
}

type ElastiCacheParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_parametergroup", filters, limit)
	if err != nil {
		return ElastiCacheParameterGroupPaginator{}, err
	}

	p := ElastiCacheParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheParameterGroupPaginator) NextPage(ctx context.Context) ([]ElastiCacheParameterGroup, error) {
	var response ElastiCacheParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheParameterGroupFilters = map[string]string{
	"akas":                         "aRN",
	"arn":                          "aRN",
	"cache_parameter_group_family": "description.ParameterGroup.CacheParameterGroupFamily",
	"cache_parameter_group_name":   "description.ParameterGroup.CacheParameterGroupName",
	"description":                  "description.ParameterGroup.Description",
	"is_global":                    "description.ParameterGroup.IsGlobal",
	"kaytu_account_id":             "metadata.SourceID",
	"title":                        "description.ParameterGroup.CacheParameterGroupName",
}

func ListElastiCacheParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElastiCacheParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElastiCacheParameterGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElastiCacheParameterGroupFilters = map[string]string{
	"akas":                         "aRN",
	"arn":                          "aRN",
	"cache_parameter_group_family": "description.ParameterGroup.CacheParameterGroupFamily",
	"cache_parameter_group_name":   "description.ParameterGroup.CacheParameterGroupName",
	"description":                  "description.ParameterGroup.Description",
	"is_global":                    "description.ParameterGroup.IsGlobal",
	"kaytu_account_id":             "metadata.SourceID",
	"title":                        "description.ParameterGroup.CacheParameterGroupName",
}

func GetElastiCacheParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElastiCacheParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElastiCacheParameterGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElastiCacheParameterGroup =============================

// ==========================  START: ElastiCacheReservedCacheNode =============================

type ElastiCacheReservedCacheNode struct {
	Description   aws.ElastiCacheReservedCacheNodeDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type ElastiCacheReservedCacheNodeHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  ElastiCacheReservedCacheNode `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type ElastiCacheReservedCacheNodeHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []ElastiCacheReservedCacheNodeHit `json:"hits"`
}

type ElastiCacheReservedCacheNodeSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  ElastiCacheReservedCacheNodeHits `json:"hits"`
}

type ElastiCacheReservedCacheNodePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheReservedCacheNodePaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheReservedCacheNodePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_reservedcachenode", filters, limit)
	if err != nil {
		return ElastiCacheReservedCacheNodePaginator{}, err
	}

	p := ElastiCacheReservedCacheNodePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheReservedCacheNodePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheReservedCacheNodePaginator) NextPage(ctx context.Context) ([]ElastiCacheReservedCacheNode, error) {
	var response ElastiCacheReservedCacheNodeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheReservedCacheNode
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheReservedCacheNodeFilters = map[string]string{
	"akas":                             "description.ReservedCacheNode.ReservationARN",
	"arn":                              "description.ReservedCacheNode.ReservationARN",
	"cache_node_count":                 "description.ReservedCacheNode.CacheNodeCount",
	"cache_node_type":                  "description.ReservedCacheNode.CacheNodeType",
	"duration":                         "description.ReservedCacheNode.Duration",
	"fixed_price":                      "description.ReservedCacheNode.FixedPrice",
	"kaytu_account_id":                 "metadata.SourceID",
	"offering_type":                    "description.ReservedCacheNode.OfferingType",
	"product_description":              "description.ReservedCacheNode.ProductDescription",
	"recurring_charges":                "description.ReservedCacheNode.RecurringCharges",
	"reserved_cache_node_id":           "description.ReservedCacheNode.ReservedCacheNodeId",
	"reserved_cache_nodes_offering_id": "description.ReservedCacheNode.ReservedCacheNodesOfferingId",
	"start_time":                       "description.ReservedCacheNode.StartTime",
	"state":                            "description.ReservedCacheNode.State",
	"title":                            "description.ReservedCacheNode.ReservedCacheNodeId",
	"usage_price":                      "description.ReservedCacheNode.UsagePrice",
}

func ListElastiCacheReservedCacheNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheReservedCacheNode")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElastiCacheReservedCacheNodePaginator(essdk.BuildFilter(d.KeyColumnQuals, listElastiCacheReservedCacheNodeFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElastiCacheReservedCacheNodeFilters = map[string]string{
	"akas":                             "description.ReservedCacheNode.ReservationARN",
	"arn":                              "description.ReservedCacheNode.ReservationARN",
	"cache_node_count":                 "description.ReservedCacheNode.CacheNodeCount",
	"cache_node_type":                  "description.ReservedCacheNode.CacheNodeType",
	"duration":                         "description.ReservedCacheNode.Duration",
	"fixed_price":                      "description.ReservedCacheNode.FixedPrice",
	"kaytu_account_id":                 "metadata.SourceID",
	"offering_type":                    "description.ReservedCacheNode.OfferingType",
	"product_description":              "description.ReservedCacheNode.ProductDescription",
	"recurring_charges":                "description.ReservedCacheNode.RecurringCharges",
	"reserved_cache_node_id":           "description.ReservedCacheNode.ReservedCacheNodeId",
	"reserved_cache_nodes_offering_id": "description.ReservedCacheNode.ReservedCacheNodesOfferingId",
	"start_time":                       "description.ReservedCacheNode.StartTime",
	"state":                            "description.ReservedCacheNode.State",
	"title":                            "description.ReservedCacheNode.ReservedCacheNodeId",
	"usage_price":                      "description.ReservedCacheNode.UsagePrice",
}

func GetElastiCacheReservedCacheNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheReservedCacheNode")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElastiCacheReservedCacheNodePaginator(essdk.BuildFilter(d.KeyColumnQuals, getElastiCacheReservedCacheNodeFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElastiCacheReservedCacheNode =============================

// ==========================  START: ElastiCacheSubnetGroup =============================

type ElastiCacheSubnetGroup struct {
	Description   aws.ElastiCacheSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ElastiCacheSubnetGroupHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ElastiCacheSubnetGroup `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ElastiCacheSubnetGroupHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ElastiCacheSubnetGroupHit `json:"hits"`
}

type ElastiCacheSubnetGroupSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ElastiCacheSubnetGroupHits `json:"hits"`
}

type ElastiCacheSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_subnetgroup", filters, limit)
	if err != nil {
		return ElastiCacheSubnetGroupPaginator{}, err
	}

	p := ElastiCacheSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheSubnetGroupPaginator) NextPage(ctx context.Context) ([]ElastiCacheSubnetGroup, error) {
	var response ElastiCacheSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheSubnetGroupFilters = map[string]string{
	"akas":                           "description.SubnetGroup.ARN",
	"arn":                            "description.SubnetGroup.ARN",
	"cache_subnet_group_description": "description.SubnetGroup.CacheSubnetGroupDescription",
	"cache_subnet_group_name":        "description.SubnetGroup.CacheSubnetGroupName",
	"kaytu_account_id":               "metadata.SourceID",
	"subnets":                        "description.SubnetGroup.Subnets",
	"title":                          "description.SubnetGroup.CacheSubnetGroupName",
	"vpc_id":                         "description.SubnetGroup.VpcId",
}

func ListElastiCacheSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElastiCacheSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElastiCacheSubnetGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElastiCacheSubnetGroupFilters = map[string]string{
	"akas":                           "description.SubnetGroup.ARN",
	"arn":                            "description.SubnetGroup.ARN",
	"cache_subnet_group_description": "description.SubnetGroup.CacheSubnetGroupDescription",
	"cache_subnet_group_name":        "description.SubnetGroup.CacheSubnetGroupName",
	"kaytu_account_id":               "metadata.SourceID",
	"subnets":                        "description.SubnetGroup.Subnets",
	"title":                          "description.SubnetGroup.CacheSubnetGroupName",
	"vpc_id":                         "description.SubnetGroup.VpcId",
}

func GetElastiCacheSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElastiCacheSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElastiCacheSubnetGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElastiCacheSubnetGroup =============================

// ==========================  START: ESDomain =============================

type ESDomain struct {
	Description   aws.ESDomainDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type ESDomainHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ESDomain      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ESDomainHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ESDomainHit     `json:"hits"`
}

type ESDomainSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ESDomainHits `json:"hits"`
}

type ESDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewESDomainPaginator(filters []essdk.BoolFilter, limit *int64) (ESDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticsearch_domain", filters, limit)
	if err != nil {
		return ESDomainPaginator{}, err
	}

	p := ESDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ESDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ESDomainPaginator) NextPage(ctx context.Context) ([]ESDomain, error) {
	var response ESDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ESDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listESDomainFilters = map[string]string{
	"access_policies":              "description.Domain.AccessPolicies",
	"advanced_options":             "description.Domain.AdvancedOptions",
	"advanced_security_options":    "description.Domain.AdvancedSecurityOptions",
	"akas":                         "description.Domain.ARN",
	"arn":                          "description.Domain.ARN",
	"auto_tune_options":            "description.Domain.AutoTuneOptions",
	"cognito_options":              "description.Domain.CognitoOptions",
	"created":                      "description.Domain.Created",
	"deleted":                      "description.Domain.Deleted",
	"domain_endpoint_options":      "description.Domain.DomainEndpointOptions",
	"domain_id":                    "description.Domain.DomainId",
	"domain_name":                  "description.Domain.DomainName",
	"ebs_options":                  "description.Domain.EBSOptions",
	"elasticsearch_cluster_config": "description.Domain.ElasticsearchClusterConfig",
	"elasticsearch_version":        "description.Domain.ElasticsearchVersion",
	"enabled":                      "description.Domain.NodeToNodeEncryptionOptions.Enabled",
	"encryption_at_rest_options":   "description.Domain.EncryptionAtRestOptions",
	"endpoint":                     "description.Domain.Endpoint",
	"kaytu_account_id":             "metadata.SourceID",
	"log_publishing_options":       "description.Domain.LogPublishingOptions",
	"policy_std":                   "description.Domain.AccessPolicies",
	"processing":                   "description.Domain.Processing",
	"service_software_options":     "description.Domain.ServiceSoftwareOptions",
	"snapshot_options":             "description.Domain.SnapshotOptions",
	"tags":                         "description.Tags",
	"tags_src":                     "description.Tags",
	"title":                        "description.Domain.DomainName",
	"upgrade_processing":           "description.Domain.UpgradeProcessing",
	"vpc_options":                  "description.Domain.VPCOptions",
}

func ListESDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListESDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewESDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, listESDomainFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getESDomainFilters = map[string]string{
	"access_policies":              "description.Domain.AccessPolicies",
	"advanced_options":             "description.Domain.AdvancedOptions",
	"advanced_security_options":    "description.Domain.AdvancedSecurityOptions",
	"akas":                         "description.Domain.ARN",
	"arn":                          "description.Domain.ARN",
	"auto_tune_options":            "description.Domain.AutoTuneOptions",
	"cognito_options":              "description.Domain.CognitoOptions",
	"created":                      "description.Domain.Created",
	"deleted":                      "description.Domain.Deleted",
	"domain_endpoint_options":      "description.Domain.DomainEndpointOptions",
	"domain_id":                    "description.Domain.DomainId",
	"domain_name":                  "description.Domain.DomainName",
	"ebs_options":                  "description.Domain.EBSOptions",
	"elasticsearch_cluster_config": "description.Domain.ElasticsearchClusterConfig",
	"elasticsearch_version":        "description.Domain.ElasticsearchVersion",
	"enabled":                      "description.Domain.NodeToNodeEncryptionOptions.Enabled",
	"encryption_at_rest_options":   "description.Domain.EncryptionAtRestOptions",
	"endpoint":                     "description.Domain.Endpoint",
	"kaytu_account_id":             "metadata.SourceID",
	"log_publishing_options":       "description.Domain.LogPublishingOptions",
	"policy_std":                   "description.Domain.AccessPolicies",
	"processing":                   "description.Domain.Processing",
	"service_software_options":     "description.Domain.ServiceSoftwareOptions",
	"snapshot_options":             "description.Domain.SnapshotOptions",
	"tags":                         "description.Tags",
	"tags_src":                     "description.Tags",
	"title":                        "description.Domain.DomainName",
	"upgrade_processing":           "description.Domain.UpgradeProcessing",
	"vpc_options":                  "description.Domain.VPCOptions",
}

func GetESDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetESDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewESDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, getESDomainFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ESDomain =============================

// ==========================  START: EMRCluster =============================

type EMRCluster struct {
	Description   aws.EMRClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EMRClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EMRCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EMRClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EMRClusterHit   `json:"hits"`
}

type EMRClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EMRClusterHits `json:"hits"`
}

type EMRClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRClusterPaginator(filters []essdk.BoolFilter, limit *int64) (EMRClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_cluster", filters, limit)
	if err != nil {
		return EMRClusterPaginator{}, err
	}

	p := EMRClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRClusterPaginator) NextPage(ctx context.Context) ([]EMRCluster, error) {
	var response EMRClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRClusterFilters = map[string]string{
	"akas":                      "description.Cluster.ClusterArn",
	"applications":              "description.Cluster.Applications",
	"auto_scaling_role":         "description.Cluster.AutoScalingRole",
	"auto_terminate":            "description.Cluster.AutoTerminate",
	"cluster_arn":               "description.Cluster.ClusterArn",
	"configurations":            "description.Cluster.Configurations",
	"custom_ami_id":             "description.Cluster.CustomAmiId",
	"ebs_root_volume_size":      "description.Cluster.EbsRootVolumeSize",
	"ec2_instance_attributes":   "description.Cluster.Ec2InstanceAttributes",
	"id":                        "description.Cluster.Id",
	"instance_collection_type":  "description.Cluster.InstanceCollectionType",
	"kaytu_account_id":          "metadata.SourceID",
	"kerberos_attributes":       "description.Cluster.KerberosAttributes",
	"log_encryption_kms_key_id": "description.Cluster.LogEncryptionKmsKeyId",
	"log_uri":                   "description.Cluster.LogUri",
	"master_public_dns_name":    "description.Cluster.MasterPublicDnsName",
	"name":                      "description.Cluster.Name",
	"normalized_instance_hours": "description.Cluster.NormalizedInstanceHours",
	"outpost_arn":               "description.Cluster.OutpostArn",
	"placement_groups":          "description.Cluster.PlacementGroups",
	"release_label":             "description.Cluster.ReleaseLabel",
	"repo_upgrade_on_boot":      "description.Cluster.RepoUpgradeOnBoot",
	"requested_ami_version":     "description.Cluster.RequestedAmiVersion",
	"running_ami_version":       "description.Cluster.RunningAmiVersion",
	"scale_down_behavior":       "description.Cluster.ScaleDownBehavior",
	"security_configuration":    "description.Cluster.SecurityConfiguration",
	"service_role":              "description.Cluster.ServiceRole",
	"status":                    "description.Cluster.Status",
	"step_concurrency_level":    "description.Cluster.StepConcurrencyLevel",
	"tags":                      "description.Cluster.Tags",
	"tags_src":                  "description.Cluster.Tags",
	"termination_protected":     "description.Cluster.TerminationProtected",
	"title":                     "description.Cluster.Name",
	"visible_to_all_users":      "description.Cluster.VisibleToAllUsers",
}

func ListEMRCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEMRClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEMRClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEMRClusterFilters = map[string]string{
	"akas":                      "description.Cluster.ClusterArn",
	"applications":              "description.Cluster.Applications",
	"auto_scaling_role":         "description.Cluster.AutoScalingRole",
	"auto_terminate":            "description.Cluster.AutoTerminate",
	"cluster_arn":               "description.Cluster.ClusterArn",
	"configurations":            "description.Cluster.Configurations",
	"custom_ami_id":             "description.Cluster.CustomAmiId",
	"ebs_root_volume_size":      "description.Cluster.EbsRootVolumeSize",
	"ec2_instance_attributes":   "description.Cluster.Ec2InstanceAttributes",
	"id":                        "description.Cluster.Id",
	"instance_collection_type":  "description.Cluster.InstanceCollectionType",
	"kaytu_account_id":          "metadata.SourceID",
	"kerberos_attributes":       "description.Cluster.KerberosAttributes",
	"log_encryption_kms_key_id": "description.Cluster.LogEncryptionKmsKeyId",
	"log_uri":                   "description.Cluster.LogUri",
	"master_public_dns_name":    "description.Cluster.MasterPublicDnsName",
	"name":                      "description.Cluster.Name",
	"normalized_instance_hours": "description.Cluster.NormalizedInstanceHours",
	"outpost_arn":               "description.Cluster.OutpostArn",
	"placement_groups":          "description.Cluster.PlacementGroups",
	"release_label":             "description.Cluster.ReleaseLabel",
	"repo_upgrade_on_boot":      "description.Cluster.RepoUpgradeOnBoot",
	"requested_ami_version":     "description.Cluster.RequestedAmiVersion",
	"running_ami_version":       "description.Cluster.RunningAmiVersion",
	"scale_down_behavior":       "description.Cluster.ScaleDownBehavior",
	"security_configuration":    "description.Cluster.SecurityConfiguration",
	"service_role":              "description.Cluster.ServiceRole",
	"status":                    "description.Cluster.Status",
	"step_concurrency_level":    "description.Cluster.StepConcurrencyLevel",
	"tags":                      "description.Cluster.Tags",
	"tags_src":                  "description.Cluster.Tags",
	"termination_protected":     "description.Cluster.TerminationProtected",
	"title":                     "description.Cluster.Name",
	"visible_to_all_users":      "description.Cluster.VisibleToAllUsers",
}

func GetEMRCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEMRClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEMRClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EMRCluster =============================

// ==========================  START: EMRInstance =============================

type EMRInstance struct {
	Description   aws.EMRInstanceDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type EMRInstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EMRInstance   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EMRInstanceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EMRInstanceHit  `json:"hits"`
}

type EMRInstanceSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  EMRInstanceHits `json:"hits"`
}

type EMRInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRInstancePaginator(filters []essdk.BoolFilter, limit *int64) (EMRInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_instance", filters, limit)
	if err != nil {
		return EMRInstancePaginator{}, err
	}

	p := EMRInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRInstancePaginator) NextPage(ctx context.Context) ([]EMRInstance, error) {
	var response EMRInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRInstanceFilters = map[string]string{
	"akas":                "aRN",
	"cluster_id":          "description.ClusterID",
	"ebs_volumes":         "description.Instance.EbsVolumes",
	"ec2_instance_id":     "description.Instance.Ec2InstanceId",
	"id":                  "description.Instance.Id",
	"instance_fleet_id":   "description.Instance.InstanceFleetId",
	"instance_group_id":   "description.Instance.InstanceGroupId",
	"instance_type":       "description.Instance.InstanceType",
	"kaytu_account_id":    "metadata.SourceID",
	"market":              "description.Instance.Market",
	"private_dns_name":    "description.Instance.PrivateDnsName",
	"private_ip_address":  "description.Instance.PrivateIpAddress",
	"public_dns_name":     "description.Instance.PublicDnsName",
	"public_ip_address":   "description.Instance.PublicIpAddress",
	"state":               "description.Instance.Status.State",
	"state_change_reason": "description.Instance.Status.StateChangeReason",
	"status_timeline":     "description.Instance.Status.Timeline",
	"title":               "description.Instance.Id",
}

func ListEMRInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEMRInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEMRInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEMRInstanceFilters = map[string]string{
	"akas":                "aRN",
	"cluster_id":          "description.ClusterID",
	"ebs_volumes":         "description.Instance.EbsVolumes",
	"ec2_instance_id":     "description.Instance.Ec2InstanceId",
	"id":                  "description.Instance.Id",
	"instance_fleet_id":   "description.Instance.InstanceFleetId",
	"instance_group_id":   "description.Instance.InstanceGroupId",
	"instance_type":       "description.Instance.InstanceType",
	"kaytu_account_id":    "metadata.SourceID",
	"market":              "description.Instance.Market",
	"private_dns_name":    "description.Instance.PrivateDnsName",
	"private_ip_address":  "description.Instance.PrivateIpAddress",
	"public_dns_name":     "description.Instance.PublicDnsName",
	"public_ip_address":   "description.Instance.PublicIpAddress",
	"state":               "description.Instance.Status.State",
	"state_change_reason": "description.Instance.Status.StateChangeReason",
	"status_timeline":     "description.Instance.Status.Timeline",
	"title":               "description.Instance.Id",
}

func GetEMRInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEMRInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEMRInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EMRInstance =============================

// ==========================  START: EMRInstanceFleet =============================

type EMRInstanceFleet struct {
	Description   aws.EMRInstanceFleetDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EMRInstanceFleetHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EMRInstanceFleet `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EMRInstanceFleetHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EMRInstanceFleetHit `json:"hits"`
}

type EMRInstanceFleetSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EMRInstanceFleetHits `json:"hits"`
}

type EMRInstanceFleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRInstanceFleetPaginator(filters []essdk.BoolFilter, limit *int64) (EMRInstanceFleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_instancefleet", filters, limit)
	if err != nil {
		return EMRInstanceFleetPaginator{}, err
	}

	p := EMRInstanceFleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRInstanceFleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRInstanceFleetPaginator) NextPage(ctx context.Context) ([]EMRInstanceFleet, error) {
	var response EMRInstanceFleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRInstanceFleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRInstanceFleetFilters = map[string]string{
	"akas":                           "aRN",
	"arn":                            "aRN",
	"cluster_id":                     "description.ClusterID",
	"id":                             "description.InstanceFleet.Id",
	"instance_fleet_type":            "description.InstanceFleet.InstanceFleetType",
	"instance_type_specifications":   "description.InstanceFleet.InstanceTypeSpecifications",
	"kaytu_account_id":               "metadata.SourceID",
	"launch_specifications":          "description.InstanceFleet.LaunchSpecifications",
	"name":                           "description.InstanceFleet.Name",
	"provisioned_on_demand_capacity": "description.InstanceFleet.ProvisionedOnDemandCapacity",
	"provisioned_spot_capacity":      "description.InstanceFleet.ProvisionedSpotCapacity",
	"state":                          "description.InstanceFleet.Status.State",
	"state_change_reason":            "description.InstanceFleet.Status.StateChangeReason",
	"status_timeline":                "description.InstanceFleet.Status.Timeline",
	"target_on_demand_capacity":      "description.InstanceFleet.TargetOnDemandCapacity",
	"target_spot_capacity":           "description.InstanceFleet.TargetSpotCapacity",
}

func ListEMRInstanceFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRInstanceFleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEMRInstanceFleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEMRInstanceFleetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEMRInstanceFleetFilters = map[string]string{
	"akas":                           "aRN",
	"arn":                            "aRN",
	"cluster_id":                     "description.ClusterID",
	"id":                             "description.InstanceFleet.Id",
	"instance_fleet_type":            "description.InstanceFleet.InstanceFleetType",
	"instance_type_specifications":   "description.InstanceFleet.InstanceTypeSpecifications",
	"kaytu_account_id":               "metadata.SourceID",
	"launch_specifications":          "description.InstanceFleet.LaunchSpecifications",
	"name":                           "description.InstanceFleet.Name",
	"provisioned_on_demand_capacity": "description.InstanceFleet.ProvisionedOnDemandCapacity",
	"provisioned_spot_capacity":      "description.InstanceFleet.ProvisionedSpotCapacity",
	"state":                          "description.InstanceFleet.Status.State",
	"state_change_reason":            "description.InstanceFleet.Status.StateChangeReason",
	"status_timeline":                "description.InstanceFleet.Status.Timeline",
	"target_on_demand_capacity":      "description.InstanceFleet.TargetOnDemandCapacity",
	"target_spot_capacity":           "description.InstanceFleet.TargetSpotCapacity",
}

func GetEMRInstanceFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRInstanceFleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEMRInstanceFleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEMRInstanceFleetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EMRInstanceFleet =============================

// ==========================  START: EMRInstanceGroup =============================

type EMRInstanceGroup struct {
	Description   aws.EMRInstanceGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EMRInstanceGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EMRInstanceGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EMRInstanceGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EMRInstanceGroupHit `json:"hits"`
}

type EMRInstanceGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EMRInstanceGroupHits `json:"hits"`
}

type EMRInstanceGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRInstanceGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EMRInstanceGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_instancegroup", filters, limit)
	if err != nil {
		return EMRInstanceGroupPaginator{}, err
	}

	p := EMRInstanceGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRInstanceGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRInstanceGroupPaginator) NextPage(ctx context.Context) ([]EMRInstanceGroup, error) {
	var response EMRInstanceGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRInstanceGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRInstanceGroupFilters = map[string]string{
	"akas":                   "aRN",
	"arn":                    "aRN",
	"autoscaling_policy":     "description.InstanceGroup.AutoScalingPolicy",
	"bid_price":              "description.InstanceGroup.BidPrice",
	"cluster_id":             "description.ClusterID",
	"configurations":         "description.InstanceGroup.Configurations",
	"configurations_version": "description.InstanceGroup.ConfigurationsVersion",
	"ebs_block_devices":      "description.InstanceGroup.EbsBlockDevices",
	"ebs_optimized":          "description.InstanceGroup.EbsOptimized",
	"id":                     "description.InstanceGroup.Id",
	"instance_group_type":    "description.InstanceGroup.InstanceGroupType",
	"instance_type":          "description.InstanceGroup.InstanceType",
	"kaytu_account_id":       "metadata.SourceID",
	"last_successfully_applied_configurations":         "description.InstanceGroup.LastSuccessfullyAppliedConfigurations",
	"last_successfully_applied_configurations_version": "description.InstanceGroup.LastSuccessfullyAppliedConfigurationsVersion",
	"market":                   "description.InstanceGroup.Market",
	"name":                     "description.InstanceGroup.Name",
	"requested_instance_count": "description.InstanceGroup.RequestedInstanceCount",
	"running_instance_count":   "description.InstanceGroup.RunningInstanceCount",
	"shrink_policy":            "description.InstanceGroup.ShrinkPolicy",
	"state":                    "description.InstanceGroup.Status.State",
	"state_change_reason":      "description.InstanceGroup.Status.StateChangeReason",
	"status_timeline":          "description.InstanceGroup.Status.Timeline",
}

func ListEMRInstanceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRInstanceGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEMRInstanceGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEMRInstanceGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEMRInstanceGroupFilters = map[string]string{
	"akas":                   "aRN",
	"arn":                    "aRN",
	"autoscaling_policy":     "description.InstanceGroup.AutoScalingPolicy",
	"bid_price":              "description.InstanceGroup.BidPrice",
	"cluster_id":             "description.ClusterID",
	"configurations":         "description.InstanceGroup.Configurations",
	"configurations_version": "description.InstanceGroup.ConfigurationsVersion",
	"ebs_block_devices":      "description.InstanceGroup.EbsBlockDevices",
	"ebs_optimized":          "description.InstanceGroup.EbsOptimized",
	"id":                     "description.InstanceGroup.Id",
	"instance_group_type":    "description.InstanceGroup.InstanceGroupType",
	"instance_type":          "description.InstanceGroup.InstanceType",
	"kaytu_account_id":       "metadata.SourceID",
	"last_successfully_applied_configurations":         "description.InstanceGroup.LastSuccessfullyAppliedConfigurations",
	"last_successfully_applied_configurations_version": "description.InstanceGroup.LastSuccessfullyAppliedConfigurationsVersion",
	"market":                   "description.InstanceGroup.Market",
	"name":                     "description.InstanceGroup.Name",
	"requested_instance_count": "description.InstanceGroup.RequestedInstanceCount",
	"running_instance_count":   "description.InstanceGroup.RunningInstanceCount",
	"shrink_policy":            "description.InstanceGroup.ShrinkPolicy",
	"state":                    "description.InstanceGroup.Status.State",
	"state_change_reason":      "description.InstanceGroup.Status.StateChangeReason",
	"status_timeline":          "description.InstanceGroup.Status.Timeline",
}

func GetEMRInstanceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRInstanceGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEMRInstanceGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEMRInstanceGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EMRInstanceGroup =============================

// ==========================  START: GuardDutyFinding =============================

type GuardDutyFinding struct {
	Description   aws.GuardDutyFindingDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type GuardDutyFindingHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  GuardDutyFinding `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type GuardDutyFindingHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []GuardDutyFindingHit `json:"hits"`
}

type GuardDutyFindingSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  GuardDutyFindingHits `json:"hits"`
}

type GuardDutyFindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyFindingPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyFindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_finding", filters, limit)
	if err != nil {
		return GuardDutyFindingPaginator{}, err
	}

	p := GuardDutyFindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyFindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyFindingPaginator) NextPage(ctx context.Context) ([]GuardDutyFinding, error) {
	var response GuardDutyFindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyFinding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyFindingFilters = map[string]string{
	"akas":             "description.Finding.Arn",
	"arn":              "description.Finding.Arn",
	"confidence":       "description.Finding.Confidence",
	"created_at":       "description.Finding.CreatedAt",
	"description":      "description.Finding.Description",
	"detector_id":      "description.Finding.Service.DetectorId",
	"id":               "description.Finding.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Finding.Title",
	"resource":         "description.Finding.Resource",
	"schema_version":   "description.Finding.SchemaVersion",
	"service":          "description.Finding.Service",
	"severity":         "description.Finding.Severity",
	"title":            "description.Finding.Title",
	"type":             "description.Finding.Type",
	"updated_at":       "description.Finding.UpdatedAt",
}

func ListGuardDutyFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyFinding")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGuardDutyFindingPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGuardDutyFindingFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGuardDutyFindingFilters = map[string]string{
	"akas":             "description.Finding.Arn",
	"arn":              "description.Finding.Arn",
	"confidence":       "description.Finding.Confidence",
	"created_at":       "description.Finding.CreatedAt",
	"description":      "description.Finding.Description",
	"detector_id":      "description.Finding.Service.DetectorId",
	"id":               "description.Finding.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Finding.Title",
	"resource":         "description.Finding.Resource",
	"schema_version":   "description.Finding.SchemaVersion",
	"service":          "description.Finding.Service",
	"severity":         "description.Finding.Severity",
	"title":            "description.Finding.Title",
	"type":             "description.Finding.Type",
	"updated_at":       "description.Finding.UpdatedAt",
}

func GetGuardDutyFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyFinding")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGuardDutyFindingPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGuardDutyFindingFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GuardDutyFinding =============================

// ==========================  START: GuardDutyDetector =============================

type GuardDutyDetector struct {
	Description   aws.GuardDutyDetectorDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type GuardDutyDetectorHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  GuardDutyDetector `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type GuardDutyDetectorHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []GuardDutyDetectorHit `json:"hits"`
}

type GuardDutyDetectorSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  GuardDutyDetectorHits `json:"hits"`
}

type GuardDutyDetectorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyDetectorPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyDetectorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_detector", filters, limit)
	if err != nil {
		return GuardDutyDetectorPaginator{}, err
	}

	p := GuardDutyDetectorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyDetectorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyDetectorPaginator) NextPage(ctx context.Context) ([]GuardDutyDetector, error) {
	var response GuardDutyDetectorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyDetector
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyDetectorFilters = map[string]string{
	"created_at":                   "description.Detector.CreatedAt",
	"data_sources":                 "description.Detector.DataSources",
	"detector_id":                  "description.DetectorId",
	"finding_publishing_frequency": "description.Detector.FindingPublishingFrequency",
	"kaytu_account_id":             "metadata.SourceID",
	"service_role":                 "description.Detector.ServiceRole",
	"status":                       "description.Detector.Status",
	"tags":                         "description.Detector.Tags",
	"title":                        "description.DetectorId",
	"updated_at":                   "description.Detector.UpdatedAt",
}

func ListGuardDutyDetector(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyDetector")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGuardDutyDetectorPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGuardDutyDetectorFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGuardDutyDetectorFilters = map[string]string{
	"created_at":                   "description.Detector.CreatedAt",
	"data_sources":                 "description.Detector.DataSources",
	"detector_id":                  "description.DetectorId",
	"finding_publishing_frequency": "description.Detector.FindingPublishingFrequency",
	"kaytu_account_id":             "metadata.SourceID",
	"service_role":                 "description.Detector.ServiceRole",
	"status":                       "description.Detector.Status",
	"tags":                         "description.Detector.Tags",
	"title":                        "description.DetectorId",
	"updated_at":                   "description.Detector.UpdatedAt",
}

func GetGuardDutyDetector(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyDetector")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGuardDutyDetectorPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGuardDutyDetectorFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GuardDutyDetector =============================

// ==========================  START: GuardDutyFilter =============================

type GuardDutyFilter struct {
	Description   aws.GuardDutyFilterDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type GuardDutyFilterHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  GuardDutyFilter `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type GuardDutyFilterHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []GuardDutyFilterHit `json:"hits"`
}

type GuardDutyFilterSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  GuardDutyFilterHits `json:"hits"`
}

type GuardDutyFilterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyFilterPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyFilterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_filter", filters, limit)
	if err != nil {
		return GuardDutyFilterPaginator{}, err
	}

	p := GuardDutyFilterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyFilterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyFilterPaginator) NextPage(ctx context.Context) ([]GuardDutyFilter, error) {
	var response GuardDutyFilterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyFilter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyFilterFilters = map[string]string{
	"action":           "description.Filter.Action",
	"akas":             "aRN",
	"description":      "description.Filter.Description",
	"detector_id":      "description.DetectorId",
	"finding_criteria": "description.Filter.FindingCriteria",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Filter.Name",
	"rank":             "description.Filter.Rank",
	"tags":             "description.Filter.Tags",
	"title":            "description.Filter.Name",
}

func ListGuardDutyFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyFilter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGuardDutyFilterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGuardDutyFilterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGuardDutyFilterFilters = map[string]string{
	"action":           "description.Filter.Action",
	"akas":             "aRN",
	"description":      "description.Filter.Description",
	"detector_id":      "description.DetectorId",
	"finding_criteria": "description.Filter.FindingCriteria",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Filter.Name",
	"rank":             "description.Filter.Rank",
	"tags":             "description.Filter.Tags",
	"title":            "description.Filter.Name",
}

func GetGuardDutyFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyFilter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGuardDutyFilterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGuardDutyFilterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GuardDutyFilter =============================

// ==========================  START: GuardDutyIPSet =============================

type GuardDutyIPSet struct {
	Description   aws.GuardDutyIPSetDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type GuardDutyIPSetHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  GuardDutyIPSet `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type GuardDutyIPSetHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []GuardDutyIPSetHit `json:"hits"`
}

type GuardDutyIPSetSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  GuardDutyIPSetHits `json:"hits"`
}

type GuardDutyIPSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyIPSetPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyIPSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_ipset", filters, limit)
	if err != nil {
		return GuardDutyIPSetPaginator{}, err
	}

	p := GuardDutyIPSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyIPSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyIPSetPaginator) NextPage(ctx context.Context) ([]GuardDutyIPSet, error) {
	var response GuardDutyIPSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyIPSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyIPSetFilters = map[string]string{
	"akas":             "aRN",
	"detector_id":      "description.DetectorId",
	"format":           "description.IPSet.Format",
	"ipset_id":         "description.IPSetId",
	"kaytu_account_id": "metadata.SourceID",
	"location":         "description.IPSet.Location",
	"name":             "description.IPSet.Name",
	"status":           "description.IPSet.Status",
	"tags":             "description.IPSet.Tags",
	"title":            "description.IPSet.Name",
}

func ListGuardDutyIPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyIPSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGuardDutyIPSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGuardDutyIPSetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGuardDutyIPSetFilters = map[string]string{
	"akas":             "aRN",
	"detector_id":      "description.DetectorId",
	"format":           "description.IPSet.Format",
	"ipset_id":         "description.IPSetId",
	"kaytu_account_id": "metadata.SourceID",
	"location":         "description.IPSet.Location",
	"name":             "description.IPSet.Name",
	"status":           "description.IPSet.Status",
	"tags":             "description.IPSet.Tags",
	"title":            "description.IPSet.Name",
}

func GetGuardDutyIPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyIPSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGuardDutyIPSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGuardDutyIPSetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GuardDutyIPSet =============================

// ==========================  START: GuardDutyMember =============================

type GuardDutyMember struct {
	Description   aws.GuardDutyMemberDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type GuardDutyMemberHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  GuardDutyMember `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type GuardDutyMemberHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []GuardDutyMemberHit `json:"hits"`
}

type GuardDutyMemberSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  GuardDutyMemberHits `json:"hits"`
}

type GuardDutyMemberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyMemberPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyMemberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_member", filters, limit)
	if err != nil {
		return GuardDutyMemberPaginator{}, err
	}

	p := GuardDutyMemberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyMemberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyMemberPaginator) NextPage(ctx context.Context) ([]GuardDutyMember, error) {
	var response GuardDutyMemberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyMember
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyMemberFilters = map[string]string{
	"detector_id":         "description.Member.DetectorId",
	"email":               "description.Member.Email",
	"invited_at":          "description.Member.InvitedAt",
	"kaytu_account_id":    "metadata.SourceID",
	"master_id":           "description.Member.MasterId",
	"member_account_id":   "description.Member.AccountId",
	"relationship_status": "description.Member.RelationshipStatus",
	"title":               "description.Member.AccountId",
	"updated_at":          "description.Member.UpdatedAt",
}

func ListGuardDutyMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyMember")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGuardDutyMemberPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGuardDutyMemberFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGuardDutyMemberFilters = map[string]string{
	"detector_id":         "description.Member.DetectorId",
	"email":               "description.Member.Email",
	"invited_at":          "description.Member.InvitedAt",
	"kaytu_account_id":    "metadata.SourceID",
	"master_id":           "description.Member.MasterId",
	"member_account_id":   "description.Member.AccountId",
	"relationship_status": "description.Member.RelationshipStatus",
	"title":               "description.Member.AccountId",
	"updated_at":          "description.Member.UpdatedAt",
}

func GetGuardDutyMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyMember")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGuardDutyMemberPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGuardDutyMemberFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GuardDutyMember =============================

// ==========================  START: GuardDutyPublishingDestination =============================

type GuardDutyPublishingDestination struct {
	Description   aws.GuardDutyPublishingDestinationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type GuardDutyPublishingDestinationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  GuardDutyPublishingDestination `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type GuardDutyPublishingDestinationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []GuardDutyPublishingDestinationHit `json:"hits"`
}

type GuardDutyPublishingDestinationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  GuardDutyPublishingDestinationHits `json:"hits"`
}

type GuardDutyPublishingDestinationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyPublishingDestinationPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyPublishingDestinationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_publishingdestination", filters, limit)
	if err != nil {
		return GuardDutyPublishingDestinationPaginator{}, err
	}

	p := GuardDutyPublishingDestinationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyPublishingDestinationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyPublishingDestinationPaginator) NextPage(ctx context.Context) ([]GuardDutyPublishingDestination, error) {
	var response GuardDutyPublishingDestinationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyPublishingDestination
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyPublishingDestinationFilters = map[string]string{
	"akas":                               "aRN",
	"arn":                                "aRN",
	"destination_arn":                    "description.PublishingDestination.DestinationProperties.DestinationArn",
	"destination_id":                     "description.PublishingDestination.DestinationId",
	"destination_type":                   "description.PublishingDestination.DestinationType",
	"detector_id":                        "description.DetectorId",
	"kaytu_account_id":                   "metadata.SourceID",
	"kms_key_arn":                        "description.PublishingDestination.DestinationProperties.KmsKeyArn",
	"publishing_failure_start_timestamp": "description.PublishingDestination.PublishingFailureStartTimestamp",
	"status":                             "description.PublishingDestination.Status",
	"title":                              "description.PublishingDestination.DestinationId",
}

func ListGuardDutyPublishingDestination(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyPublishingDestination")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGuardDutyPublishingDestinationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGuardDutyPublishingDestinationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGuardDutyPublishingDestinationFilters = map[string]string{
	"akas":                               "aRN",
	"arn":                                "aRN",
	"destination_arn":                    "description.PublishingDestination.DestinationProperties.DestinationArn",
	"destination_id":                     "description.PublishingDestination.DestinationId",
	"destination_type":                   "description.PublishingDestination.DestinationType",
	"detector_id":                        "description.DetectorId",
	"kaytu_account_id":                   "metadata.SourceID",
	"kms_key_arn":                        "description.PublishingDestination.DestinationProperties.KmsKeyArn",
	"publishing_failure_start_timestamp": "description.PublishingDestination.PublishingFailureStartTimestamp",
	"status":                             "description.PublishingDestination.Status",
	"title":                              "description.PublishingDestination.DestinationId",
}

func GetGuardDutyPublishingDestination(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyPublishingDestination")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGuardDutyPublishingDestinationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGuardDutyPublishingDestinationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GuardDutyPublishingDestination =============================

// ==========================  START: GuardDutyThreatIntelSet =============================

type GuardDutyThreatIntelSet struct {
	Description   aws.GuardDutyThreatIntelSetDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type GuardDutyThreatIntelSetHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  GuardDutyThreatIntelSet `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type GuardDutyThreatIntelSetHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []GuardDutyThreatIntelSetHit `json:"hits"`
}

type GuardDutyThreatIntelSetSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  GuardDutyThreatIntelSetHits `json:"hits"`
}

type GuardDutyThreatIntelSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyThreatIntelSetPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyThreatIntelSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_threatintelset", filters, limit)
	if err != nil {
		return GuardDutyThreatIntelSetPaginator{}, err
	}

	p := GuardDutyThreatIntelSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyThreatIntelSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyThreatIntelSetPaginator) NextPage(ctx context.Context) ([]GuardDutyThreatIntelSet, error) {
	var response GuardDutyThreatIntelSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyThreatIntelSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyThreatIntelSetFilters = map[string]string{
	"akas":                "aRN",
	"detector_id":         "description.DetectorId",
	"format":              "description.ThreatIntelSet.Format",
	"kaytu_account_id":    "metadata.SourceID",
	"location":            "description.ThreatIntelSet.Location",
	"name":                "description.ThreatIntelSet.Name",
	"status":              "description.ThreatIntelSet.Status",
	"tags":                "description.ThreatIntelSet.Tags",
	"threat_intel_set_id": "description.ThreatIntelSetID",
	"title":               "description.ThreatIntelSet.Name",
}

func ListGuardDutyThreatIntelSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyThreatIntelSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGuardDutyThreatIntelSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGuardDutyThreatIntelSetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGuardDutyThreatIntelSetFilters = map[string]string{
	"akas":                "aRN",
	"detector_id":         "description.DetectorId",
	"format":              "description.ThreatIntelSet.Format",
	"kaytu_account_id":    "metadata.SourceID",
	"location":            "description.ThreatIntelSet.Location",
	"name":                "description.ThreatIntelSet.Name",
	"status":              "description.ThreatIntelSet.Status",
	"tags":                "description.ThreatIntelSet.Tags",
	"threat_intel_set_id": "description.ThreatIntelSetID",
	"title":               "description.ThreatIntelSet.Name",
}

func GetGuardDutyThreatIntelSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyThreatIntelSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGuardDutyThreatIntelSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGuardDutyThreatIntelSetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GuardDutyThreatIntelSet =============================

// ==========================  START: BackupPlan =============================

type BackupPlan struct {
	Description   aws.BackupPlanDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type BackupPlanHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BackupPlan    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BackupPlanHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BackupPlanHit   `json:"hits"`
}

type BackupPlanSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  BackupPlanHits `json:"hits"`
}

type BackupPlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupPlanPaginator(filters []essdk.BoolFilter, limit *int64) (BackupPlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_plan", filters, limit)
	if err != nil {
		return BackupPlanPaginator{}, err
	}

	p := BackupPlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupPlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupPlanPaginator) NextPage(ctx context.Context) ([]BackupPlan, error) {
	var response BackupPlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupPlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupPlanFilters = map[string]string{
	"advanced_backup_settings": "description.BackupPlan.AdvancedBackupSettings",
	"akas":                     "description.BackupPlan.BackupPlanArn",
	"arn":                      "description.BackupPlan.BackupPlanArn",
	"backup_plan":              "description.BackupPlan",
	"backup_plan_id":           "description.BackupPlan.BackupPlanId",
	"creation_date":            "description.BackupPlan.CreationDate",
	"creator_request_id":       "description.BackupPlan.CreatorRequestId",
	"deletion_date":            "description.BackupPlan.DeletionDate",
	"kaytu_account_id":         "metadata.SourceID",
	"last_execution_date":      "description.BackupPlan.LastExecutionDate",
	"name":                     "description.BackupPlan.BackupPlanName",
	"title":                    "description.BackupPlan.BackupPlanName",
	"version_id":               "description.BackupPlan.VersionId",
}

func ListBackupPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupPlan")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBackupPlanPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBackupPlanFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBackupPlanFilters = map[string]string{
	"advanced_backup_settings": "description.BackupPlan.AdvancedBackupSettings",
	"akas":                     "description.BackupPlan.BackupPlanArn",
	"arn":                      "description.BackupPlan.BackupPlanArn",
	"backup_plan":              "description.BackupPlan",
	"backup_plan_id":           "description.BackupPlan.BackupPlanId",
	"creation_date":            "description.BackupPlan.CreationDate",
	"creator_request_id":       "description.BackupPlan.CreatorRequestId",
	"deletion_date":            "description.BackupPlan.DeletionDate",
	"kaytu_account_id":         "metadata.SourceID",
	"last_execution_date":      "description.BackupPlan.LastExecutionDate",
	"name":                     "description.BackupPlan.BackupPlanName",
	"title":                    "description.BackupPlan.BackupPlanName",
	"version_id":               "description.BackupPlan.VersionId",
}

func GetBackupPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupPlan")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBackupPlanPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBackupPlanFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BackupPlan =============================

// ==========================  START: BackupSelection =============================

type BackupSelection struct {
	Description   aws.BackupSelectionDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type BackupSelectionHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  BackupSelection `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type BackupSelectionHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []BackupSelectionHit `json:"hits"`
}

type BackupSelectionSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  BackupSelectionHits `json:"hits"`
}

type BackupSelectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupSelectionPaginator(filters []essdk.BoolFilter, limit *int64) (BackupSelectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_selection", filters, limit)
	if err != nil {
		return BackupSelectionPaginator{}, err
	}

	p := BackupSelectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupSelectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupSelectionPaginator) NextPage(ctx context.Context) ([]BackupSelection, error) {
	var response BackupSelectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupSelection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupSelectionFilters = map[string]string{
	"backup_plan_id":     "description.BackupSelection.BackupPlanId",
	"creation_date":      "description.BackupSelection.CreationDate",
	"creator_request_id": "description.BackupSelection.CreatorRequestId",
	"iam_role_arn":       "description.BackupSelection.IamRoleArn",
	"kaytu_account_id":   "metadata.SourceID",
	"list_of_tags":       "description.ListOfTags",
	"resources":          "description.Resources",
	"selection_id":       "description.BackupSelection.SelectionId",
	"selection_name":     "description.BackupSelection.SelectionName",
	"title":              "description.BackupSelection.SelectionName",
}

func ListBackupSelection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupSelection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBackupSelectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBackupSelectionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBackupSelectionFilters = map[string]string{
	"backup_plan_id":     "description.BackupSelection.BackupPlanId",
	"creation_date":      "description.BackupSelection.CreationDate",
	"creator_request_id": "description.BackupSelection.CreatorRequestId",
	"iam_role_arn":       "description.BackupSelection.IamRoleArn",
	"kaytu_account_id":   "metadata.SourceID",
	"list_of_tags":       "description.ListOfTags",
	"resources":          "description.Resources",
	"selection_id":       "description.BackupSelection.SelectionId",
	"selection_name":     "description.BackupSelection.SelectionName",
	"title":              "description.BackupSelection.SelectionName",
}

func GetBackupSelection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupSelection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBackupSelectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBackupSelectionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BackupSelection =============================

// ==========================  START: BackupVault =============================

type BackupVault struct {
	Description   aws.BackupVaultDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type BackupVaultHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BackupVault   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BackupVaultHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BackupVaultHit  `json:"hits"`
}

type BackupVaultSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  BackupVaultHits `json:"hits"`
}

type BackupVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupVaultPaginator(filters []essdk.BoolFilter, limit *int64) (BackupVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_vault", filters, limit)
	if err != nil {
		return BackupVaultPaginator{}, err
	}

	p := BackupVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupVaultPaginator) NextPage(ctx context.Context) ([]BackupVault, error) {
	var response BackupVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupVaultFilters = map[string]string{
	"akas":                      "description.BackupVault.BackupVaultArn",
	"arn":                       "description.BackupVault.BackupVaultArn",
	"backup_vault_events":       "description.BackupVaultEvents",
	"creation_date":             "description.BackupVault.CreationDate",
	"creator_request_id":        "description.BackupVault.CreatorRequestId",
	"encryption_key_arn":        "description.BackupVault.EncryptionKeyArn",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.BackupVault.BackupVaultName",
	"number_of_recovery_points": "description.BackupVault.NumberOfRecoveryPoints",
	"policy":                    "description.Policy",
	"policy_std":                "description.Policy",
	"sns_topic_arn":             "description.SNSTopicArn",
	"title":                     "description.BackupVault.BackupVaultName",
}

func ListBackupVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBackupVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBackupVaultFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBackupVaultFilters = map[string]string{
	"akas":                      "description.BackupVault.BackupVaultArn",
	"arn":                       "description.BackupVault.BackupVaultArn",
	"backup_vault_events":       "description.BackupVaultEvents",
	"creation_date":             "description.BackupVault.CreationDate",
	"creator_request_id":        "description.BackupVault.CreatorRequestId",
	"encryption_key_arn":        "description.BackupVault.EncryptionKeyArn",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.BackupVault.BackupVaultName",
	"number_of_recovery_points": "description.BackupVault.NumberOfRecoveryPoints",
	"policy":                    "description.Policy",
	"policy_std":                "description.Policy",
	"sns_topic_arn":             "description.SNSTopicArn",
	"title":                     "description.BackupVault.BackupVaultName",
}

func GetBackupVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBackupVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBackupVaultFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BackupVault =============================

// ==========================  START: BackupRecoveryPoint =============================

type BackupRecoveryPoint struct {
	Description   aws.BackupRecoveryPointDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type BackupRecoveryPointHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  BackupRecoveryPoint `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type BackupRecoveryPointHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []BackupRecoveryPointHit `json:"hits"`
}

type BackupRecoveryPointSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  BackupRecoveryPointHits `json:"hits"`
}

type BackupRecoveryPointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupRecoveryPointPaginator(filters []essdk.BoolFilter, limit *int64) (BackupRecoveryPointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_recoverypoint", filters, limit)
	if err != nil {
		return BackupRecoveryPointPaginator{}, err
	}

	p := BackupRecoveryPointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupRecoveryPointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupRecoveryPointPaginator) NextPage(ctx context.Context) ([]BackupRecoveryPoint, error) {
	var response BackupRecoveryPointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupRecoveryPoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupRecoveryPointFilters = map[string]string{
	"akas":                    "description.RecoveryPoint.ResourceArn",
	"backup_size_in_bytes":    "description.RecoveryPoint.BackupSizeInBytes",
	"backup_vault_arn":        "description.RecoveryPoint.BackupVaultArn",
	"backup_vault_name":       "description.RecoveryPoint.BackupVaultName",
	"calculated_lifecycle":    "description.RecoveryPoint.CalculatedLifecycle",
	"completion_date":         "description.RecoveryPoint.CompletionDate",
	"created_by":              "description.RecoveryPoint.CreatedBy",
	"creation_date":           "description.RecoveryPoint.CreationDate",
	"encryption_key_arn":      "description.RecoveryPoint.EncryptionKeyArn",
	"iam_role_arn":            "description.RecoveryPoint.IamRoleArn",
	"is_encrypted":            "description.RecoveryPoint.IsEncrypted",
	"kaytu_account_id":        "metadata.SourceID",
	"last_restore_time":       "description.RecoveryPoint.LastRestoreTime",
	"lifecycle":               "description.RecoveryPoint.Lifecycle",
	"recovery_point_arn":      "description.RecoveryPoint.RecoveryPointArn",
	"resource_arn":            "description.RecoveryPoint.ResourceArn",
	"resource_type":           "description.RecoveryPoint.ResourceType",
	"source_backup_vault_arn": "description.RecoveryPoint.SourceBackupVaultArn",
	"status":                  "description.RecoveryPoint.Status",
	"status_message":          "description.RecoveryPoint.StatusMessage",
	"storage_class":           "description.RecoveryPoint.StorageClass",
}

func ListBackupRecoveryPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupRecoveryPoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBackupRecoveryPointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBackupRecoveryPointFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBackupRecoveryPointFilters = map[string]string{
	"akas":                    "description.RecoveryPoint.ResourceArn",
	"backup_size_in_bytes":    "description.RecoveryPoint.BackupSizeInBytes",
	"backup_vault_arn":        "description.RecoveryPoint.BackupVaultArn",
	"backup_vault_name":       "description.RecoveryPoint.BackupVaultName",
	"calculated_lifecycle":    "description.RecoveryPoint.CalculatedLifecycle",
	"completion_date":         "description.RecoveryPoint.CompletionDate",
	"created_by":              "description.RecoveryPoint.CreatedBy",
	"creation_date":           "description.RecoveryPoint.CreationDate",
	"encryption_key_arn":      "description.RecoveryPoint.EncryptionKeyArn",
	"iam_role_arn":            "description.RecoveryPoint.IamRoleArn",
	"is_encrypted":            "description.RecoveryPoint.IsEncrypted",
	"kaytu_account_id":        "metadata.SourceID",
	"last_restore_time":       "description.RecoveryPoint.LastRestoreTime",
	"lifecycle":               "description.RecoveryPoint.Lifecycle",
	"recovery_point_arn":      "description.RecoveryPoint.RecoveryPointArn",
	"resource_arn":            "description.RecoveryPoint.ResourceArn",
	"resource_type":           "description.RecoveryPoint.ResourceType",
	"source_backup_vault_arn": "description.RecoveryPoint.SourceBackupVaultArn",
	"status":                  "description.RecoveryPoint.Status",
	"status_message":          "description.RecoveryPoint.StatusMessage",
	"storage_class":           "description.RecoveryPoint.StorageClass",
}

func GetBackupRecoveryPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupRecoveryPoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBackupRecoveryPointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBackupRecoveryPointFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BackupRecoveryPoint =============================

// ==========================  START: BackupProtectedResource =============================

type BackupProtectedResource struct {
	Description   aws.BackupProtectedResourceDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type BackupProtectedResourceHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  BackupProtectedResource `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type BackupProtectedResourceHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []BackupProtectedResourceHit `json:"hits"`
}

type BackupProtectedResourceSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  BackupProtectedResourceHits `json:"hits"`
}

type BackupProtectedResourcePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupProtectedResourcePaginator(filters []essdk.BoolFilter, limit *int64) (BackupProtectedResourcePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_protectedresource", filters, limit)
	if err != nil {
		return BackupProtectedResourcePaginator{}, err
	}

	p := BackupProtectedResourcePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupProtectedResourcePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupProtectedResourcePaginator) NextPage(ctx context.Context) ([]BackupProtectedResource, error) {
	var response BackupProtectedResourceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupProtectedResource
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupProtectedResourceFilters = map[string]string{
	"akas":             "description.ProtectedResource.ResourceArn",
	"kaytu_account_id": "metadata.SourceID",
	"last_backup_time": "description.ProtectedResource.LastBackupTime",
	"resource_arn":     "description.ProtectedResource.ResourceArn",
	"resource_type":    "description.ProtectedResource.ResourceType",
}

func ListBackupProtectedResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupProtectedResource")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBackupProtectedResourcePaginator(essdk.BuildFilter(d.KeyColumnQuals, listBackupProtectedResourceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBackupProtectedResourceFilters = map[string]string{
	"akas":             "description.ProtectedResource.ResourceArn",
	"kaytu_account_id": "metadata.SourceID",
	"last_backup_time": "description.ProtectedResource.LastBackupTime",
	"resource_arn":     "description.ProtectedResource.ResourceArn",
	"resource_type":    "description.ProtectedResource.ResourceType",
}

func GetBackupProtectedResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupProtectedResource")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBackupProtectedResourcePaginator(essdk.BuildFilter(d.KeyColumnQuals, getBackupProtectedResourceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BackupProtectedResource =============================

// ==========================  START: BackupFramework =============================

type BackupFramework struct {
	Description   aws.BackupFrameworkDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type BackupFrameworkHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  BackupFramework `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type BackupFrameworkHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []BackupFrameworkHit `json:"hits"`
}

type BackupFrameworkSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  BackupFrameworkHits `json:"hits"`
}

type BackupFrameworkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupFrameworkPaginator(filters []essdk.BoolFilter, limit *int64) (BackupFrameworkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_framework", filters, limit)
	if err != nil {
		return BackupFrameworkPaginator{}, err
	}

	p := BackupFrameworkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupFrameworkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupFrameworkPaginator) NextPage(ctx context.Context) ([]BackupFramework, error) {
	var response BackupFrameworkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupFramework
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupFrameworkFilters = map[string]string{
	"akas":                  "description.Framework.FrameworkArn",
	"arn":                   "description.Framework.FrameworkArn",
	"creation_time":         "description.Framework.CreationTime",
	"deployment_status":     "description.Framework.DeploymentStatus",
	"framework_controls":    "description.Framework.FrameworkControls",
	"framework_description": "description.Framework.FrameworkDescription",
	"framework_name":        "description.Framework.FrameworkName",
	"framework_status":      "description.Framework.FrameworkStatus",
	"kaytu_account_id":      "metadata.SourceID",
	"tags":                  "description.Tags",
	"title":                 "description.Framework.FrameworkName",
}

func ListBackupFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupFramework")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBackupFrameworkPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBackupFrameworkFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBackupFrameworkFilters = map[string]string{
	"akas":                  "description.Framework.FrameworkArn",
	"arn":                   "description.Framework.FrameworkArn",
	"creation_time":         "description.Framework.CreationTime",
	"deployment_status":     "description.Framework.DeploymentStatus",
	"framework_controls":    "description.Framework.FrameworkControls",
	"framework_description": "description.Framework.FrameworkDescription",
	"framework_name":        "description.Framework.FrameworkName",
	"framework_status":      "description.Framework.FrameworkStatus",
	"kaytu_account_id":      "metadata.SourceID",
	"tags":                  "description.Tags",
	"title":                 "description.Framework.FrameworkName",
}

func GetBackupFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupFramework")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBackupFrameworkPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBackupFrameworkFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BackupFramework =============================

// ==========================  START: BackupLegalHold =============================

type BackupLegalHold struct {
	Description   aws.BackupLegalHoldDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type BackupLegalHoldHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  BackupLegalHold `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type BackupLegalHoldHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []BackupLegalHoldHit `json:"hits"`
}

type BackupLegalHoldSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  BackupLegalHoldHits `json:"hits"`
}

type BackupLegalHoldPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupLegalHoldPaginator(filters []essdk.BoolFilter, limit *int64) (BackupLegalHoldPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_legalhold", filters, limit)
	if err != nil {
		return BackupLegalHoldPaginator{}, err
	}

	p := BackupLegalHoldPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupLegalHoldPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupLegalHoldPaginator) NextPage(ctx context.Context) ([]BackupLegalHold, error) {
	var response BackupLegalHoldSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupLegalHold
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupLegalHoldFilters = map[string]string{
	"akas":                     "description.LegalHold.LegalHoldArn",
	"arn":                      "description.LegalHold.LegalHoldArn",
	"cancellation_date":        "description.LegalHold.CancellationDate",
	"creation_date":            "description.LegalHold.CreationDate",
	"description":              "description.LegalHold.Description",
	"kaytu_account_id":         "metadata.SourceID",
	"legal_hold_id":            "description.LegalHold.LegalHoldId",
	"recovery_point_selection": "description.LegalHold.RecoveryPointSelection",
	"retain_record_until":      "description.LegalHold.RetainRecordUntil",
	"status":                   "description.LegalHold.Status",
	"title":                    "description.LegalHold.Title",
}

func ListBackupLegalHold(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupLegalHold")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBackupLegalHoldPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBackupLegalHoldFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBackupLegalHoldFilters = map[string]string{
	"akas":                     "description.LegalHold.LegalHoldArn",
	"arn":                      "description.LegalHold.LegalHoldArn",
	"cancellation_date":        "description.LegalHold.CancellationDate",
	"creation_date":            "description.LegalHold.CreationDate",
	"description":              "description.LegalHold.Description",
	"kaytu_account_id":         "metadata.SourceID",
	"legal_hold_id":            "description.Framework.LegalHoldId",
	"recovery_point_selection": "description.LegalHold.RecoveryPointSelection",
	"retain_record_until":      "description.LegalHold.RetainRecordUntil",
	"status":                   "description.LegalHold.Status",
	"title":                    "description.LegalHold.Title",
}

func GetBackupLegalHold(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupLegalHold")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBackupLegalHoldPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBackupLegalHoldFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BackupLegalHold =============================

// ==========================  START: CloudFrontDistribution =============================

type CloudFrontDistribution struct {
	Description   aws.CloudFrontDistributionDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CloudFrontDistributionHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CloudFrontDistribution `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CloudFrontDistributionHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CloudFrontDistributionHit `json:"hits"`
}

type CloudFrontDistributionSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CloudFrontDistributionHits `json:"hits"`
}

type CloudFrontDistributionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontDistributionPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontDistributionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_distribution", filters, limit)
	if err != nil {
		return CloudFrontDistributionPaginator{}, err
	}

	p := CloudFrontDistributionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontDistributionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontDistributionPaginator) NextPage(ctx context.Context) ([]CloudFrontDistribution, error) {
	var response CloudFrontDistributionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontDistribution
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontDistributionFilters = map[string]string{
	"active_trusted_key_groups":        "description.Distribution.ActiveTrustedKeyGroups",
	"active_trusted_signers":           "description.Distribution.ActiveTrustedSigners",
	"akas":                             "description.Distribution.ARN",
	"alias_icp_recordals":              "description.Distribution.AliasICPRecordals",
	"aliases":                          "description.Distribution.DistributionConfig.Aliases",
	"arn":                              "description.Distribution.ARN",
	"cache_behaviors":                  "description.Distribution.DistributionConfig.CacheBehaviors",
	"caller_reference":                 "description.Distribution.DistributionConfig.CallerReference",
	"comment":                          "description.Distribution.DistributionConfig.Comment",
	"custom_error_responses":           "description.Distribution.DistributionConfig.CustomErrorResponses",
	"default_cache_behavior":           "description.Distribution.DistributionConfig.DefaultCacheBehavior",
	"default_root_object":              "description.Distribution.DistributionConfig.DefaultRootObject",
	"domain_name":                      "description.Distribution.DomainName",
	"e_tag":                            "description.ETag",
	"enabled":                          "description.Distribution.DistributionConfig.Enabled",
	"http_version":                     "description.Distribution.DistributionConfig.HttpVersion",
	"id":                               "description.Distribution.Id",
	"in_progress_invalidation_batches": "description.Distribution.InProgressInvalidationBatches",
	"is_ipv6_enabled":                  "description.Distribution.DistributionConfig.IsIPV6Enabled",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_modified_time":               "description.Distribution.DistributionConfig.LastModifiedTime",
	"logging":                          "description.Distribution.DistributionConfig.Logging",
	"origin_groups":                    "description.Distribution.DistributionConfig.OriginGroups",
	"origins":                          "description.Distribution.DistributionConfig.Origins.Items",
	"price_class":                      "description.Distribution.DistributionConfig.PriceClass",
	"restrictions":                     "description.Distribution.DistributionConfig.Restrictions",
	"status":                           "description.Distribution.Status",
	"tags_src":                         "description.Tags",
	"title":                            "description.Distribution.Id",
	"viewer_certificate":               "description.Distribution.DistributionConfig.ViewerCertificate",
	"web_acl_id":                       "description.Distribution.DistributionConfig.WebACLId",
}

func ListCloudFrontDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontDistribution")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontDistributionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontDistributionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontDistributionFilters = map[string]string{
	"active_trusted_key_groups":        "description.Distribution.ActiveTrustedKeyGroups",
	"active_trusted_signers":           "description.Distribution.ActiveTrustedSigners",
	"akas":                             "description.Distribution.ARN",
	"alias_icp_recordals":              "description.Distribution.AliasICPRecordals",
	"aliases":                          "description.Distribution.DistributionConfig.Aliases",
	"arn":                              "description.Distribution.ARN",
	"cache_behaviors":                  "description.Distribution.DistributionConfig.CacheBehaviors",
	"caller_reference":                 "description.Distribution.DistributionConfig.CallerReference",
	"comment":                          "description.Distribution.DistributionConfig.Comment",
	"custom_error_responses":           "description.Distribution.DistributionConfig.CustomErrorResponses",
	"default_cache_behavior":           "description.Distribution.DistributionConfig.DefaultCacheBehavior",
	"default_root_object":              "description.Distribution.DistributionConfig.DefaultRootObject",
	"domain_name":                      "description.Distribution.DomainName",
	"e_tag":                            "description.ETag",
	"enabled":                          "description.Distribution.DistributionConfig.Enabled",
	"http_version":                     "description.Distribution.DistributionConfig.HttpVersion",
	"id":                               "description.Distribution.Id",
	"in_progress_invalidation_batches": "description.Distribution.InProgressInvalidationBatches",
	"is_ipv6_enabled":                  "description.Distribution.DistributionConfig.IsIPV6Enabled",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_modified_time":               "description.Distribution.DistributionConfig.LastModifiedTime",
	"logging":                          "description.Distribution.DistributionConfig.Logging",
	"origin_groups":                    "description.Distribution.DistributionConfig.OriginGroups",
	"origins":                          "description.Distribution.DistributionConfig.Origins.Items",
	"price_class":                      "description.Distribution.DistributionConfig.PriceClass",
	"restrictions":                     "description.Distribution.DistributionConfig.Restrictions",
	"status":                           "description.Distribution.Status",
	"tags_src":                         "description.Tags",
	"title":                            "description.Distribution.Id",
	"viewer_certificate":               "description.Distribution.DistributionConfig.ViewerCertificate",
	"web_acl_id":                       "description.Distribution.DistributionConfig.WebACLId",
}

func GetCloudFrontDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontDistribution")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontDistributionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontDistributionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontDistribution =============================

// ==========================  START: CloudFrontStreamingDistribution =============================

type CloudFrontStreamingDistribution struct {
	Description   aws.CloudFrontStreamingDistributionDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CloudFrontStreamingDistributionHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CloudFrontStreamingDistribution `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CloudFrontStreamingDistributionHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CloudFrontStreamingDistributionHit `json:"hits"`
}

type CloudFrontStreamingDistributionSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CloudFrontStreamingDistributionHits `json:"hits"`
}

type CloudFrontStreamingDistributionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontStreamingDistributionPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontStreamingDistributionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_streamingdistribution", filters, limit)
	if err != nil {
		return CloudFrontStreamingDistributionPaginator{}, err
	}

	p := CloudFrontStreamingDistributionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontStreamingDistributionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontStreamingDistributionPaginator) NextPage(ctx context.Context) ([]CloudFrontStreamingDistribution, error) {
	var response CloudFrontStreamingDistributionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontStreamingDistribution
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontStreamingDistributionFilters = map[string]string{
	"akas":             "description.StreamingDistribution.ARN",
	"arn":              "description.StreamingDistribution.ARN",
	"id":               "description.StreamingDistribution.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.StreamingDistribution.Name",
	"tags":             "description.StreamingDistribution.Tags",
	"title":            "description.StreamingDistribution.Name",
}

func ListCloudFrontStreamingDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontStreamingDistribution")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontStreamingDistributionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontStreamingDistributionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontStreamingDistributionFilters = map[string]string{
	"akas":             "description.StreamingDistribution.ARN",
	"arn":              "description.StreamingDistribution.ARN",
	"id":               "description.StreamingDistribution.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.StreamingDistribution.Name",
	"tags":             "description.StreamingDistribution.Tags",
	"title":            "description.StreamingDistribution.Name",
}

func GetCloudFrontStreamingDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontStreamingDistribution")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontStreamingDistributionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontStreamingDistributionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontStreamingDistribution =============================

// ==========================  START: CloudFrontOriginAccessControl =============================

type CloudFrontOriginAccessControl struct {
	Description   aws.CloudFrontOriginAccessControlDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CloudFrontOriginAccessControlHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CloudFrontOriginAccessControl `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CloudFrontOriginAccessControlHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CloudFrontOriginAccessControlHit `json:"hits"`
}

type CloudFrontOriginAccessControlSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CloudFrontOriginAccessControlHits `json:"hits"`
}

type CloudFrontOriginAccessControlPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontOriginAccessControlPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontOriginAccessControlPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_originaccesscontrol", filters, limit)
	if err != nil {
		return CloudFrontOriginAccessControlPaginator{}, err
	}

	p := CloudFrontOriginAccessControlPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontOriginAccessControlPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontOriginAccessControlPaginator) NextPage(ctx context.Context) ([]CloudFrontOriginAccessControl, error) {
	var response CloudFrontOriginAccessControlSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontOriginAccessControl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontOriginAccessControlFilters = map[string]string{
	"id":               "description.OriginAccessControl.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.OriginAccessControl.Name",
	"title":            "description.OriginAccessControl.Name",
}

func ListCloudFrontOriginAccessControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontOriginAccessControl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontOriginAccessControlPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontOriginAccessControlFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontOriginAccessControlFilters = map[string]string{
	"id":               "description.OriginAccessControl.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.OriginAccessControl.Name",
	"title":            "description.OriginAccessControl.Name",
}

func GetCloudFrontOriginAccessControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontOriginAccessControl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontOriginAccessControlPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontOriginAccessControlFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontOriginAccessControl =============================

// ==========================  START: CloudFrontCachePolicy =============================

type CloudFrontCachePolicy struct {
	Description   aws.CloudFrontCachePolicyDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type CloudFrontCachePolicyHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  CloudFrontCachePolicy `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type CloudFrontCachePolicyHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []CloudFrontCachePolicyHit `json:"hits"`
}

type CloudFrontCachePolicySearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  CloudFrontCachePolicyHits `json:"hits"`
}

type CloudFrontCachePolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontCachePolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontCachePolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_cachepolicy", filters, limit)
	if err != nil {
		return CloudFrontCachePolicyPaginator{}, err
	}

	p := CloudFrontCachePolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontCachePolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontCachePolicyPaginator) NextPage(ctx context.Context) ([]CloudFrontCachePolicy, error) {
	var response CloudFrontCachePolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontCachePolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontCachePolicyFilters = map[string]string{
	"akas":               "aRN",
	"comment":            "description.CachePolicy.CachePolicy.CachePolicyConfig.Comment",
	"default_ttl":        "description.CachePolicy.CachePolicy.CachePolicyConfig.DefaultTTL",
	"etag":               "description.CachePolicy.ETag",
	"id":                 "description.CachePolicy.CachePolicy.Id",
	"kaytu_account_id":   "metadata.SourceID",
	"last_modified_time": "description.CachePolicy.CachePolicy.LastModifiedTime",
	"max_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MaxTTL",
	"min_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MinTTL",
	"name":               "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
	"parameters_in_cache_key_and_forwarded_to_origin": "description.CachePolicy.CachePolicy.CachePolicyConfig.ParametersInCacheKeyAndForwardedToOrigin",
	"title": "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
}

func ListCloudFrontCachePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontCachePolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontCachePolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontCachePolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontCachePolicyFilters = map[string]string{
	"akas":               "aRN",
	"comment":            "description.CachePolicy.CachePolicy.CachePolicyConfig.Comment",
	"default_ttl":        "description.CachePolicy.CachePolicy.CachePolicyConfig.DefaultTTL",
	"etag":               "description.CachePolicy.ETag",
	"id":                 "description.CachePolicy.Id",
	"kaytu_account_id":   "metadata.SourceID",
	"last_modified_time": "description.CachePolicy.CachePolicy.LastModifiedTime",
	"max_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MaxTTL",
	"min_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MinTTL",
	"name":               "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
	"parameters_in_cache_key_and_forwarded_to_origin": "description.CachePolicy.CachePolicy.CachePolicyConfig.ParametersInCacheKeyAndForwardedToOrigin",
	"title": "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
}

func GetCloudFrontCachePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontCachePolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontCachePolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontCachePolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontCachePolicy =============================

// ==========================  START: CloudFrontFunction =============================

type CloudFrontFunction struct {
	Description   aws.CloudFrontFunctionDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type CloudFrontFunctionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  CloudFrontFunction `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type CloudFrontFunctionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []CloudFrontFunctionHit `json:"hits"`
}

type CloudFrontFunctionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  CloudFrontFunctionHits `json:"hits"`
}

type CloudFrontFunctionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontFunctionPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontFunctionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_function", filters, limit)
	if err != nil {
		return CloudFrontFunctionPaginator{}, err
	}

	p := CloudFrontFunctionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontFunctionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontFunctionPaginator) NextPage(ctx context.Context) ([]CloudFrontFunction, error) {
	var response CloudFrontFunctionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontFunction
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontFunctionFilters = map[string]string{
	"akas":              "description.Function.FunctionSummary.FunctionMetadata.FunctionARN",
	"arn":               "description.Function.FunctionSummary.FunctionMetadata.FunctionARN",
	"e_tag":             "description.Function.ETag",
	"function_config":   "description.Function.FunctionSummary.FunctionConfig",
	"function_metadata": "description.Function.FunctionSummary.FunctionMetadata",
	"kaytu_account_id":  "metadata.SourceID",
	"name":              "description.Function.FunctionSummary.Name",
	"status":            "description.Function.FunctionSummary.Status",
	"title":             "description.Function.FunctionSummary.Name",
}

func ListCloudFrontFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontFunction")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontFunctionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontFunctionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontFunctionFilters = map[string]string{
	"akas":              "description.Function.FunctionSummary.FunctionMetadata.FunctionARN",
	"arn":               "description.Function.FunctionSummary.FunctionMetadata.FunctionARN",
	"e_tag":             "description.Function.ETag",
	"function_config":   "description.Function.FunctionSummary.FunctionConfig",
	"function_metadata": "description.Function.FunctionSummary.FunctionMetadata",
	"kaytu_account_id":  "metadata.SourceID",
	"name":              "description.Function.FunctionSummary.Name",
	"status":            "description.Function.FunctionSummary.Status",
	"title":             "description.Function.FunctionSummary.Name",
}

func GetCloudFrontFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontFunction")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontFunctionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontFunctionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontFunction =============================

// ==========================  START: CloudFrontOriginAccessIdentity =============================

type CloudFrontOriginAccessIdentity struct {
	Description   aws.CloudFrontOriginAccessIdentityDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type CloudFrontOriginAccessIdentityHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  CloudFrontOriginAccessIdentity `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type CloudFrontOriginAccessIdentityHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []CloudFrontOriginAccessIdentityHit `json:"hits"`
}

type CloudFrontOriginAccessIdentitySearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  CloudFrontOriginAccessIdentityHits `json:"hits"`
}

type CloudFrontOriginAccessIdentityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontOriginAccessIdentityPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontOriginAccessIdentityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_originaccessidentity", filters, limit)
	if err != nil {
		return CloudFrontOriginAccessIdentityPaginator{}, err
	}

	p := CloudFrontOriginAccessIdentityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontOriginAccessIdentityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontOriginAccessIdentityPaginator) NextPage(ctx context.Context) ([]CloudFrontOriginAccessIdentity, error) {
	var response CloudFrontOriginAccessIdentitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontOriginAccessIdentity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontOriginAccessIdentityFilters = map[string]string{
	"akas":                 "aRN",
	"arn":                  "aRN",
	"caller_reference":     "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.CallerReference",
	"comment":              "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.Comment",
	"etag":                 "description.OriginAccessIdentity.ETag",
	"id":                   "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.Id",
	"kaytu_account_id":     "metadata.SourceID",
	"s3_canonical_user_id": "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.S3CanonicalUserId",
	"title":                "description.OriginAccessIdentity.ResultMetadata",
}

func ListCloudFrontOriginAccessIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontOriginAccessIdentity")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontOriginAccessIdentityPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontOriginAccessIdentityFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontOriginAccessIdentityFilters = map[string]string{
	"akas":                 "aRN",
	"arn":                  "aRN",
	"caller_reference":     "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.CallerReference",
	"comment":              "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.Comment",
	"etag":                 "description.OriginAccessIdentity.ETag",
	"id":                   "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.Id",
	"kaytu_account_id":     "metadata.SourceID",
	"s3_canonical_user_id": "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.S3CanonicalUserId",
	"title":                "description.OriginAccessIdentity.ResultMetadata",
}

func GetCloudFrontOriginAccessIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontOriginAccessIdentity")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontOriginAccessIdentityPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontOriginAccessIdentityFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontOriginAccessIdentity =============================

// ==========================  START: CloudFrontOriginRequestPolicy =============================

type CloudFrontOriginRequestPolicy struct {
	Description   aws.CloudFrontOriginRequestPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CloudFrontOriginRequestPolicyHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CloudFrontOriginRequestPolicy `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CloudFrontOriginRequestPolicyHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CloudFrontOriginRequestPolicyHit `json:"hits"`
}

type CloudFrontOriginRequestPolicySearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CloudFrontOriginRequestPolicyHits `json:"hits"`
}

type CloudFrontOriginRequestPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontOriginRequestPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontOriginRequestPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_originrequestpolicy", filters, limit)
	if err != nil {
		return CloudFrontOriginRequestPolicyPaginator{}, err
	}

	p := CloudFrontOriginRequestPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontOriginRequestPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontOriginRequestPolicyPaginator) NextPage(ctx context.Context) ([]CloudFrontOriginRequestPolicy, error) {
	var response CloudFrontOriginRequestPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontOriginRequestPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontOriginRequestPolicyFilters = map[string]string{
	"akas":                 "aRN",
	"comment":              "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Comment",
	"cookies_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.CookiesConfig",
	"etag":                 "description.OriginRequestPolicy.ETag",
	"headers_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.HeadersConfig",
	"id":                   "description.OriginRequestPolicy.OriginRequestPolicy.Id",
	"kaytu_account_id":     "metadata.SourceID",
	"last_modified_time":   "description.OriginRequestPolicy.OriginRequestPolicy.LastModifiedTime",
	"name":                 "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
	"query_strings_config": "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.QueryStringsConfig",
	"title":                "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
}

func ListCloudFrontOriginRequestPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontOriginRequestPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontOriginRequestPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontOriginRequestPolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontOriginRequestPolicyFilters = map[string]string{
	"akas":                 "aRN",
	"comment":              "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Comment",
	"cookies_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.CookiesConfig",
	"etag":                 "description.OriginRequestPolicy.ETag",
	"headers_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.HeadersConfig",
	"id":                   "description.OriginRequestPolicy.OriginRequestPolicy.Id",
	"kaytu_account_id":     "metadata.SourceID",
	"last_modified_time":   "description.OriginRequestPolicy.OriginRequestPolicy.LastModifiedTime",
	"name":                 "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
	"query_strings_config": "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.QueryStringsConfig",
	"title":                "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
}

func GetCloudFrontOriginRequestPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontOriginRequestPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontOriginRequestPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontOriginRequestPolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontOriginRequestPolicy =============================

// ==========================  START: CloudFrontResponseHeadersPolicy =============================

type CloudFrontResponseHeadersPolicy struct {
	Description   aws.CloudFrontResponseHeadersPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CloudFrontResponseHeadersPolicyHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CloudFrontResponseHeadersPolicy `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CloudFrontResponseHeadersPolicyHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CloudFrontResponseHeadersPolicyHit `json:"hits"`
}

type CloudFrontResponseHeadersPolicySearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CloudFrontResponseHeadersPolicyHits `json:"hits"`
}

type CloudFrontResponseHeadersPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontResponseHeadersPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontResponseHeadersPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_responseheaderspolicy", filters, limit)
	if err != nil {
		return CloudFrontResponseHeadersPolicyPaginator{}, err
	}

	p := CloudFrontResponseHeadersPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontResponseHeadersPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontResponseHeadersPolicyPaginator) NextPage(ctx context.Context) ([]CloudFrontResponseHeadersPolicy, error) {
	var response CloudFrontResponseHeadersPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontResponseHeadersPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontResponseHeadersPolicyFilters = map[string]string{
	"akas":                           "aRN",
	"arn":                            "aRN",
	"etag":                           "description.ResponseHeadersPolicy.ETag",
	"id":                             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.Id",
	"kaytu_account_id":               "metadata.SourceID",
	"last_modified_time":             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.LastModifiedTime",
	"name":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"response_headers_policy_config": "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig",
	"title":                          "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"type":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.SecurityHeadersConfig.ContentTypeOptions",
}

func ListCloudFrontResponseHeadersPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontResponseHeadersPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFrontResponseHeadersPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFrontResponseHeadersPolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFrontResponseHeadersPolicyFilters = map[string]string{
	"akas":                           "aRN",
	"arn":                            "aRN",
	"etag":                           "description.ResponseHeadersPolicy.ETag",
	"id":                             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.Id",
	"kaytu_account_id":               "metadata.SourceID",
	"last_modified_time":             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.LastModifiedTime",
	"name":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"response_headers_policy_config": "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig",
	"title":                          "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"type":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.SecurityHeadersConfig.ContentTypeOptions",
}

func GetCloudFrontResponseHeadersPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontResponseHeadersPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFrontResponseHeadersPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFrontResponseHeadersPolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFrontResponseHeadersPolicy =============================

// ==========================  START: CloudWatchAlarm =============================

type CloudWatchAlarm struct {
	Description   aws.CloudWatchAlarmDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CloudWatchAlarmHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CloudWatchAlarm `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CloudWatchAlarmHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CloudWatchAlarmHit `json:"hits"`
}

type CloudWatchAlarmSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CloudWatchAlarmHits `json:"hits"`
}

type CloudWatchAlarmPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchAlarmPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchAlarmPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_alarm", filters, limit)
	if err != nil {
		return CloudWatchAlarmPaginator{}, err
	}

	p := CloudWatchAlarmPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchAlarmPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchAlarmPaginator) NextPage(ctx context.Context) ([]CloudWatchAlarm, error) {
	var response CloudWatchAlarmSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchAlarm
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchAlarmFilters = map[string]string{
	"actions_enabled":                       "description.MetricAlarm.ActionsEnabled",
	"akas":                                  "description.MetricAlarm.AlarmArn",
	"alarm_actions":                         "description.MetricAlarm.AlarmActions",
	"alarm_configuration_updated_timestamp": "description.MetricAlarm.AlarmConfigurationUpdatedTimestamp",
	"alarm_description":                     "description.MetricAlarm.AlarmDescription",
	"arn":                                   "description.MetricAlarm.AlarmArn",
	"comparison_operator":                   "description.MetricAlarm.ComparisonOperator",
	"datapoints_to_alarm":                   "description.MetricAlarm.DatapointsToAlarm",
	"dimensions":                            "description.MetricAlarm.Dimensions",
	"evaluate_low_sample_count_percentile":  "description.MetricAlarm.EvaluateLowSampleCountPercentile",
	"evaluation_periods":                    "description.MetricAlarm.EvaluationPeriods",
	"extended_statistic":                    "description.MetricAlarm.ExtendedStatistic",
	"insufficient_data_actions":             "description.MetricAlarm.InsufficientDataActions",
	"kaytu_account_id":                      "metadata.SourceID",
	"metric_name":                           "description.MetricAlarm.MetricName",
	"metrics":                               "description.MetricAlarm.Metrics",
	"name":                                  "description.MetricAlarm.AlarmName",
	"namespace":                             "description.MetricAlarm.Namespace",
	"ok_actions":                            "description.MetricAlarm.OKActions",
	"period":                                "description.MetricAlarm.EvaluationPeriods",
	"state_reason":                          "description.MetricAlarm.StateReason",
	"state_reason_data":                     "description.MetricAlarm.StateReasonData",
	"state_updated_timestamp":               "description.MetricAlarm.StateUpdatedTimestamp",
	"state_value":                           "description.MetricAlarm.StateValue",
	"statistic":                             "description.MetricAlarm.ExtendedStatistic",
	"tags_src":                              "description.Tags",
	"threshold":                             "description.MetricAlarm.Threshold",
	"threshold_metric_id":                   "description.MetricAlarm.ThresholdMetricId",
	"title":                                 "description.MetricAlarm.ActionsEnabled",
	"treat_missing_data":                    "description.MetricAlarm.TreatMissingData",
	"unit":                                  "description.MetricAlarm.Unit",
}

func ListCloudWatchAlarm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchAlarm")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchAlarmPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchAlarmFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchAlarmFilters = map[string]string{
	"actions_enabled":                       "description.MetricAlarm.ActionsEnabled",
	"akas":                                  "description.MetricAlarm.AlarmArn",
	"alarm_actions":                         "description.MetricAlarm.AlarmActions",
	"alarm_configuration_updated_timestamp": "description.MetricAlarm.AlarmConfigurationUpdatedTimestamp",
	"alarm_description":                     "description.MetricAlarm.AlarmDescription",
	"arn":                                   "description.MetricAlarm.AlarmArn",
	"comparison_operator":                   "description.MetricAlarm.ComparisonOperator",
	"datapoints_to_alarm":                   "description.MetricAlarm.DatapointsToAlarm",
	"dimensions":                            "description.MetricAlarm.Dimensions",
	"evaluate_low_sample_count_percentile":  "description.MetricAlarm.EvaluateLowSampleCountPercentile",
	"evaluation_periods":                    "description.MetricAlarm.EvaluationPeriods",
	"extended_statistic":                    "description.MetricAlarm.ExtendedStatistic",
	"insufficient_data_actions":             "description.MetricAlarm.InsufficientDataActions",
	"kaytu_account_id":                      "metadata.SourceID",
	"metric_name":                           "description.MetricAlarm.MetricName",
	"metrics":                               "description.MetricAlarm.Metrics",
	"name":                                  "description.MetricAlarm.AlarmName",
	"namespace":                             "description.MetricAlarm.Namespace",
	"ok_actions":                            "description.MetricAlarm.OKActions",
	"period":                                "description.MetricAlarm.EvaluationPeriods",
	"state_reason":                          "description.MetricAlarm.StateReason",
	"state_reason_data":                     "description.MetricAlarm.StateReasonData",
	"state_updated_timestamp":               "description.MetricAlarm.StateUpdatedTimestamp",
	"state_value":                           "description.MetricAlarm.StateValue",
	"statistic":                             "description.MetricAlarm.ExtendedStatistic",
	"tags_src":                              "description.Tags",
	"threshold":                             "description.MetricAlarm.Threshold",
	"threshold_metric_id":                   "description.MetricAlarm.ThresholdMetricId",
	"title":                                 "description.MetricAlarm.ActionsEnabled",
	"treat_missing_data":                    "description.MetricAlarm.TreatMissingData",
	"unit":                                  "description.MetricAlarm.Unit",
}

func GetCloudWatchAlarm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchAlarm")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchAlarmPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchAlarmFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchAlarm =============================

// ==========================  START: CloudWatchLogEvent =============================

type CloudWatchLogEvent struct {
	Description   aws.CloudWatchLogEventDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type CloudWatchLogEventHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  CloudWatchLogEvent `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type CloudWatchLogEventHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []CloudWatchLogEventHit `json:"hits"`
}

type CloudWatchLogEventSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  CloudWatchLogEventHits `json:"hits"`
}

type CloudWatchLogEventPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogEventPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogEventPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logevent", filters, limit)
	if err != nil {
		return CloudWatchLogEventPaginator{}, err
	}

	p := CloudWatchLogEventPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogEventPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogEventPaginator) NextPage(ctx context.Context) ([]CloudWatchLogEvent, error) {
	var response CloudWatchLogEventSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogEvent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogEventFilters = map[string]string{
	"event_id":         "description.LogEvent.EventId",
	"ingestion_time":   "description.LogEvent.IngestionTime",
	"kaytu_account_id": "metadata.SourceID",
	"log_group_name":   "description.LogGroupName",
	"log_stream_name":  "description.LogEvent.LogStreamName",
	"message":          "description.LogEvent.Message",
	"message_json":     "description.LogEvent.Message",
	"timestamp":        "description.LogEvent.Timestamp",
}

func ListCloudWatchLogEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogEvent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchLogEventPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchLogEventFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchLogEventFilters = map[string]string{
	"event_id":         "description.LogEvent.EventId",
	"ingestion_time":   "description.LogEvent.IngestionTime",
	"kaytu_account_id": "metadata.SourceID",
	"log_group_name":   "description.LogGroupName",
	"log_stream_name":  "description.LogEvent.LogStreamName",
	"message":          "description.LogEvent.Message",
	"message_json":     "description.LogEvent.Message",
	"timestamp":        "description.LogEvent.Timestamp",
}

func GetCloudWatchLogEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogEvent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogEventPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchLogEventFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogEvent =============================

// ==========================  START: CloudWatchLogResourcePolicy =============================

type CloudWatchLogResourcePolicy struct {
	Description   aws.CloudWatchLogResourcePolicyDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type CloudWatchLogResourcePolicyHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  CloudWatchLogResourcePolicy `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type CloudWatchLogResourcePolicyHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []CloudWatchLogResourcePolicyHit `json:"hits"`
}

type CloudWatchLogResourcePolicySearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  CloudWatchLogResourcePolicyHits `json:"hits"`
}

type CloudWatchLogResourcePolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogResourcePolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogResourcePolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logresourcepolicy", filters, limit)
	if err != nil {
		return CloudWatchLogResourcePolicyPaginator{}, err
	}

	p := CloudWatchLogResourcePolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogResourcePolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogResourcePolicyPaginator) NextPage(ctx context.Context) ([]CloudWatchLogResourcePolicy, error) {
	var response CloudWatchLogResourcePolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogResourcePolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogResourcePolicyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"last_updated_time": "description.ResourcePolicy.LastUpdatedTime",
	"policy":            "description.ResourcePolicy.PolicyDocument",
	"policy_name":       "description.ResourcePolicy.PolicyName",
	"policy_std":        "description.ResourcePolicy.PolicyDocument",
	"title":             "description.ResourcePolicy.PolicyName",
}

func ListCloudWatchLogResourcePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogResourcePolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchLogResourcePolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchLogResourcePolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchLogResourcePolicyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"last_updated_time": "description.ResourcePolicy.LastUpdatedTime",
	"policy":            "description.ResourcePolicy.PolicyDocument",
	"policy_name":       "description.ResourcePolicy.PolicyName",
	"policy_std":        "description.ResourcePolicy.PolicyDocument",
	"title":             "description.ResourcePolicy.PolicyName",
}

func GetCloudWatchLogResourcePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogResourcePolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogResourcePolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchLogResourcePolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogResourcePolicy =============================

// ==========================  START: CloudWatchLogStream =============================

type CloudWatchLogStream struct {
	Description   aws.CloudWatchLogStreamDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type CloudWatchLogStreamHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  CloudWatchLogStream `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type CloudWatchLogStreamHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []CloudWatchLogStreamHit `json:"hits"`
}

type CloudWatchLogStreamSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  CloudWatchLogStreamHits `json:"hits"`
}

type CloudWatchLogStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogStreamPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logstream", filters, limit)
	if err != nil {
		return CloudWatchLogStreamPaginator{}, err
	}

	p := CloudWatchLogStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogStreamPaginator) NextPage(ctx context.Context) ([]CloudWatchLogStream, error) {
	var response CloudWatchLogStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogStreamFilters = map[string]string{
	"akas":                  "description.LogStream.Arn",
	"arn":                   "description.LogStream.Arn",
	"creation_time":         "description.LogStream.CreationTime",
	"first_event_timestamp": "description.LogStream.FirstEventTimestamp",
	"kaytu_account_id":      "metadata.SourceID",
	"last_event_timestamp":  "description.LogStream.LastEventTimestamp",
	"last_ingestion_time":   "description.LogStream.LastIngestionTime",
	"log_group_name":        "description.LogGroupName",
	"name":                  "description.LogStream.LogStreamName",
	"title":                 "description.LogStream.LogStreamName",
	"upload_sequence_token": "description.LogStream.UploadSequenceToken",
}

func ListCloudWatchLogStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchLogStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchLogStreamFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchLogStreamFilters = map[string]string{
	"akas":                  "description.LogStream.Arn",
	"arn":                   "description.LogStream.Arn",
	"creation_time":         "description.LogStream.CreationTime",
	"first_event_timestamp": "description.LogStream.FirstEventTimestamp",
	"kaytu_account_id":      "metadata.SourceID",
	"last_event_timestamp":  "description.LogStream.LastEventTimestamp",
	"last_ingestion_time":   "description.LogStream.LastIngestionTime",
	"log_group_name":        "description.LogGroupName",
	"name":                  "description.LogStream.LogStreamName",
	"title":                 "description.LogStream.LogStreamName",
	"upload_sequence_token": "description.LogStream.UploadSequenceToken",
}

func GetCloudWatchLogStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchLogStreamFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogStream =============================

// ==========================  START: CloudWatchLogSubscriptionFilter =============================

type CloudWatchLogSubscriptionFilter struct {
	Description   aws.CloudWatchLogSubscriptionFilterDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CloudWatchLogSubscriptionFilterHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CloudWatchLogSubscriptionFilter `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CloudWatchLogSubscriptionFilterHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CloudWatchLogSubscriptionFilterHit `json:"hits"`
}

type CloudWatchLogSubscriptionFilterSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CloudWatchLogSubscriptionFilterHits `json:"hits"`
}

type CloudWatchLogSubscriptionFilterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogSubscriptionFilterPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogSubscriptionFilterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logsubscriptionfilter", filters, limit)
	if err != nil {
		return CloudWatchLogSubscriptionFilterPaginator{}, err
	}

	p := CloudWatchLogSubscriptionFilterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogSubscriptionFilterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogSubscriptionFilterPaginator) NextPage(ctx context.Context) ([]CloudWatchLogSubscriptionFilter, error) {
	var response CloudWatchLogSubscriptionFilterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogSubscriptionFilter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogSubscriptionFilterFilters = map[string]string{
	"akas":             "aRN",
	"creation_time":    "description.SubscriptionFilter.CreationTime",
	"destination_arn":  "description.SubscriptionFilter.DestinationArn",
	"distribution":     "description.SubscriptionFilter.Distribution",
	"filter_pattern":   "description.SubscriptionFilter.FilterPattern",
	"kaytu_account_id": "metadata.SourceID",
	"log_group_name":   "description.SubscriptionFilter.LogGroupName",
	"name":             "description.SubscriptionFilter.FilterName",
	"role_arn":         "description.SubscriptionFilter.RoleArn",
	"title":            "description.SubscriptionFilter.FilterName",
}

func ListCloudWatchLogSubscriptionFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogSubscriptionFilter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchLogSubscriptionFilterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchLogSubscriptionFilterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchLogSubscriptionFilterFilters = map[string]string{
	"akas":             "aRN",
	"creation_time":    "description.SubscriptionFilter.CreationTime",
	"destination_arn":  "description.SubscriptionFilter.DestinationArn",
	"distribution":     "description.SubscriptionFilter.Distribution",
	"filter_pattern":   "description.SubscriptionFilter.FilterPattern",
	"kaytu_account_id": "metadata.SourceID",
	"log_group_name":   "description.SubscriptionFilter.LogGroupName",
	"name":             "description.SubscriptionFilter.FilterName",
	"role_arn":         "description.SubscriptionFilter.RoleArn",
	"title":            "description.SubscriptionFilter.FilterName",
}

func GetCloudWatchLogSubscriptionFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogSubscriptionFilter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogSubscriptionFilterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchLogSubscriptionFilterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogSubscriptionFilter =============================

// ==========================  START: CloudWatchMetric =============================

type CloudWatchMetric struct {
	Description   aws.CloudWatchMetricDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type CloudWatchMetricHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CloudWatchMetric `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CloudWatchMetricHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CloudWatchMetricHit `json:"hits"`
}

type CloudWatchMetricSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CloudWatchMetricHits `json:"hits"`
}

type CloudWatchMetricPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchMetricPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchMetricPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_metric", filters, limit)
	if err != nil {
		return CloudWatchMetricPaginator{}, err
	}

	p := CloudWatchMetricPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchMetricPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchMetricPaginator) NextPage(ctx context.Context) ([]CloudWatchMetric, error) {
	var response CloudWatchMetricSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchMetric
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchMetricFilters = map[string]string{
	"dimensions":       "description.Metric.Dimensions",
	"kaytu_account_id": "metadata.SourceID",
	"metric_name":      "description.Metric.MetricName",
	"namespace":        "description.Metric.Namespace",
	"title":            "description.Metric.MetricName",
}

func ListCloudWatchMetric(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchMetric")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchMetricPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchMetricFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchMetricFilters = map[string]string{
	"dimensions":       "description.Metric.Dimensions",
	"kaytu_account_id": "metadata.SourceID",
	"metric_name":      "description.Metric.MetricName",
	"namespace":        "description.Metric.Namespace",
	"title":            "description.Metric.MetricName",
}

func GetCloudWatchMetric(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchMetric")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchMetricPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchMetricFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchMetric =============================

// ==========================  START: CloudWatchLogsLogGroup =============================

type CloudWatchLogsLogGroup struct {
	Description   aws.CloudWatchLogsLogGroupDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CloudWatchLogsLogGroupHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CloudWatchLogsLogGroup `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CloudWatchLogsLogGroupHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CloudWatchLogsLogGroupHit `json:"hits"`
}

type CloudWatchLogsLogGroupSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CloudWatchLogsLogGroupHits `json:"hits"`
}

type CloudWatchLogsLogGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogsLogGroupPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogsLogGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_logs_loggroup", filters, limit)
	if err != nil {
		return CloudWatchLogsLogGroupPaginator{}, err
	}

	p := CloudWatchLogsLogGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogsLogGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogsLogGroupPaginator) NextPage(ctx context.Context) ([]CloudWatchLogsLogGroup, error) {
	var response CloudWatchLogsLogGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogsLogGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogsLogGroupFilters = map[string]string{
	"akas":                "description.LogGroup.Arn",
	"arn":                 "description.LogGroup.Arn",
	"creation_time":       "description.LogGroup.CreationTime",
	"kaytu_account_id":    "metadata.SourceID",
	"kms_key_id":          "description.LogGroup.KmsKeyId",
	"metric_filter_count": "description.LogGroup.MetricFilterCount",
	"name":                "description.LogGroup.LogGroupName",
	"retention_in_days":   "description.LogGroup.RetentionInDays",
	"stored_bytes":        "description.LogGroup.StoredBytes",
	"tags":                "description.Tags",
	"title":               "description.LogGroup.LogGroupName",
}

func ListCloudWatchLogsLogGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogsLogGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchLogsLogGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchLogsLogGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchLogsLogGroupFilters = map[string]string{
	"akas":                "description.LogGroup.Arn",
	"arn":                 "description.LogGroup.Arn",
	"creation_time":       "description.LogGroup.CreationTime",
	"kaytu_account_id":    "metadata.SourceID",
	"kms_key_id":          "description.LogGroup.KmsKeyId",
	"metric_filter_count": "description.LogGroup.MetricFilterCount",
	"name":                "description.LogGroup.LogGroupName",
	"retention_in_days":   "description.LogGroup.RetentionInDays",
	"stored_bytes":        "description.LogGroup.StoredBytes",
	"tags":                "description.Tags",
	"title":               "description.LogGroup.LogGroupName",
}

func GetCloudWatchLogsLogGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogsLogGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogsLogGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchLogsLogGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogsLogGroup =============================

// ==========================  START: CloudWatchLogsMetricFilter =============================

type CloudWatchLogsMetricFilter struct {
	Description   aws.CloudWatchLogsMetricFilterDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CloudWatchLogsMetricFilterHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CloudWatchLogsMetricFilter `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CloudWatchLogsMetricFilterHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CloudWatchLogsMetricFilterHit `json:"hits"`
}

type CloudWatchLogsMetricFilterSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CloudWatchLogsMetricFilterHits `json:"hits"`
}

type CloudWatchLogsMetricFilterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogsMetricFilterPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogsMetricFilterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_logs_metricfilter", filters, limit)
	if err != nil {
		return CloudWatchLogsMetricFilterPaginator{}, err
	}

	p := CloudWatchLogsMetricFilterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogsMetricFilterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogsMetricFilterPaginator) NextPage(ctx context.Context) ([]CloudWatchLogsMetricFilter, error) {
	var response CloudWatchLogsMetricFilterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogsMetricFilter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogsMetricFilterFilters = map[string]string{
	"creation_time":                   "description.MetricFilter.CreationTime",
	"filter_pattern":                  "description.MetricFilter.FilterPattern",
	"kaytu_account_id":                "metadata.SourceID",
	"log_group_name":                  "decsription.MetricFilter.LogGroupName",
	"metric_transformation_name":      "decsription.MetricFilter.MetricTransformations.MetricName",
	"metric_transformation_namespace": "decsription.MetricFilter.MetricTransformations.MetricNamespace",
	"name":                            "decsription.MetricFilter.FilterName",
	"title":                           "description.MetricFilter.FilterName",
}

func ListCloudWatchLogsMetricFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogsMetricFilter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudWatchLogsMetricFilterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudWatchLogsMetricFilterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudWatchLogsMetricFilterFilters = map[string]string{
	"creation_time":    "description.MetricFilter.CreationTime",
	"filter_pattern":   "description.MetricFilter.FilterPattern",
	"kaytu_account_id": "metadata.SourceID",
	"log_group_name":   "description.MetricFilter.LogGroupName",
	"name":             "decsription.MetricFilter.FilterName",
	"title":            "description.MetricFilter.FilterName",
}

func GetCloudWatchLogsMetricFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogsMetricFilter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogsMetricFilterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudWatchLogsMetricFilterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogsMetricFilter =============================

// ==========================  START: CodeBuildProject =============================

type CodeBuildProject struct {
	Description   aws.CodeBuildProjectDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type CodeBuildProjectHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CodeBuildProject `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CodeBuildProjectHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CodeBuildProjectHit `json:"hits"`
}

type CodeBuildProjectSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CodeBuildProjectHits `json:"hits"`
}

type CodeBuildProjectPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeBuildProjectPaginator(filters []essdk.BoolFilter, limit *int64) (CodeBuildProjectPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codebuild_project", filters, limit)
	if err != nil {
		return CodeBuildProjectPaginator{}, err
	}

	p := CodeBuildProjectPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeBuildProjectPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeBuildProjectPaginator) NextPage(ctx context.Context) ([]CodeBuildProject, error) {
	var response CodeBuildProjectSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeBuildProject
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeBuildProjectFilters = map[string]string{
	"akas":                      "description.Project.Arn",
	"arn":                       "description.Project.Arn",
	"artifacts":                 "description.Project.Artifacts",
	"badge":                     "description.Project.Badge",
	"build_batch_config":        "description.Project.BuildBatchConfig",
	"cache":                     "description.Project.Cache",
	"concurrent_build_limit":    "description.Project.ConcurrentBuildLimit",
	"created":                   "description.Project.Created",
	"description":               "description.Project.Description",
	"encryption_key":            "description.Project.EncryptionKey",
	"environment":               "description.Project.Environment",
	"file_system_locations":     "description.Project.FileSystemLocations",
	"kaytu_account_id":          "metadata.SourceID",
	"last_modified":             "description.Project.LastModified",
	"logs_config":               "description.Project.LogsConfig",
	"name":                      "description.Project.Name",
	"project_visibility":        "description.Project.ProjectVisibility",
	"queued_timeout_in_minutes": "description.Project.QueuedTimeoutInMinutes",
	"secondary_artifacts":       "description.Project.SecondaryArtifacts",
	"secondary_source_versions": "description.Project.SecondarySourceVersions",
	"secondary_sources":         "description.Project.SecondarySources",
	"service_role":              "description.Project.ServiceRole",
	"source":                    "description.Project.Source",
	"source_version":            "description.Project.SourceVersion",
	"tags":                      "description",
	"tags_src":                  "description.Project.Tags",
	"timeout_in_minutes":        "description.Project.TimeoutInMinutes",
	"title":                     "description.Project.Name",
	"vpc_config":                "description.Project.VpcConfig",
	"webhook":                   "description.Project.Webhook",
}

func ListCodeBuildProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeBuildProject")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeBuildProjectPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeBuildProjectFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeBuildProjectFilters = map[string]string{
	"akas":                      "description.Project.Arn",
	"arn":                       "description.Project.Arn",
	"artifacts":                 "description.Project.Artifacts",
	"badge":                     "description.Project.Badge",
	"build_batch_config":        "description.Project.BuildBatchConfig",
	"cache":                     "description.Project.Cache",
	"concurrent_build_limit":    "description.Project.ConcurrentBuildLimit",
	"created":                   "description.Project.Created",
	"description":               "description.Project.Description",
	"encryption_key":            "description.Project.EncryptionKey",
	"environment":               "description.Project.Environment",
	"file_system_locations":     "description.Project.FileSystemLocations",
	"kaytu_account_id":          "metadata.SourceID",
	"last_modified":             "description.Project.LastModified",
	"logs_config":               "description.Project.LogsConfig",
	"name":                      "description.Project.Name",
	"project_visibility":        "description.Project.ProjectVisibility",
	"queued_timeout_in_minutes": "description.Project.QueuedTimeoutInMinutes",
	"secondary_artifacts":       "description.Project.SecondaryArtifacts",
	"secondary_source_versions": "description.Project.SecondarySourceVersions",
	"secondary_sources":         "description.Project.SecondarySources",
	"service_role":              "description.Project.ServiceRole",
	"source":                    "description.Project.Source",
	"source_version":            "description.Project.SourceVersion",
	"tags":                      "description",
	"tags_src":                  "description.Project.Tags",
	"timeout_in_minutes":        "description.Project.TimeoutInMinutes",
	"title":                     "description.Project.Name",
	"vpc_config":                "description.Project.VpcConfig",
	"webhook":                   "description.Project.Webhook",
}

func GetCodeBuildProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeBuildProject")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeBuildProjectPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeBuildProjectFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeBuildProject =============================

// ==========================  START: CodeBuildSourceCredential =============================

type CodeBuildSourceCredential struct {
	Description   aws.CodeBuildSourceCredentialDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type CodeBuildSourceCredentialHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  CodeBuildSourceCredential `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type CodeBuildSourceCredentialHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []CodeBuildSourceCredentialHit `json:"hits"`
}

type CodeBuildSourceCredentialSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  CodeBuildSourceCredentialHits `json:"hits"`
}

type CodeBuildSourceCredentialPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeBuildSourceCredentialPaginator(filters []essdk.BoolFilter, limit *int64) (CodeBuildSourceCredentialPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codebuild_sourcecredential", filters, limit)
	if err != nil {
		return CodeBuildSourceCredentialPaginator{}, err
	}

	p := CodeBuildSourceCredentialPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeBuildSourceCredentialPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeBuildSourceCredentialPaginator) NextPage(ctx context.Context) ([]CodeBuildSourceCredential, error) {
	var response CodeBuildSourceCredentialSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeBuildSourceCredential
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeBuildSourceCredentialFilters = map[string]string{
	"akas":             "description.SourceCredentialsInfo.Arn",
	"arn":              "description.SourceCredentialsInfo.Arn",
	"auth_type":        "description.SourceCredentialsInfo.AuthType",
	"kaytu_account_id": "metadata.SourceID",
	"server_type":      "description.SourceCredentialsInfo.ServerType",
}

func ListCodeBuildSourceCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeBuildSourceCredential")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeBuildSourceCredentialPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeBuildSourceCredentialFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeBuildSourceCredentialFilters = map[string]string{
	"akas":             "description.SourceCredentialsInfo.Arn",
	"arn":              "description.SourceCredentialsInfo.Arn",
	"auth_type":        "description.SourceCredentialsInfo.AuthType",
	"kaytu_account_id": "metadata.SourceID",
	"server_type":      "description.SourceCredentialsInfo.ServerType",
}

func GetCodeBuildSourceCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeBuildSourceCredential")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeBuildSourceCredentialPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeBuildSourceCredentialFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeBuildSourceCredential =============================

// ==========================  START: ConfigConfigurationRecorder =============================

type ConfigConfigurationRecorder struct {
	Description   aws.ConfigConfigurationRecorderDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ConfigConfigurationRecorderHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ConfigConfigurationRecorder `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ConfigConfigurationRecorderHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ConfigConfigurationRecorderHit `json:"hits"`
}

type ConfigConfigurationRecorderSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ConfigConfigurationRecorderHits `json:"hits"`
}

type ConfigConfigurationRecorderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigConfigurationRecorderPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigConfigurationRecorderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_configurationrecorder", filters, limit)
	if err != nil {
		return ConfigConfigurationRecorderPaginator{}, err
	}

	p := ConfigConfigurationRecorderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigConfigurationRecorderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigConfigurationRecorderPaginator) NextPage(ctx context.Context) ([]ConfigConfigurationRecorder, error) {
	var response ConfigConfigurationRecorderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigConfigurationRecorder
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigConfigurationRecorderFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ConfigurationRecorder.Name",
	"recording_group":  "description.ConfigurationRecorder.RecordingGroup",
	"role_arn":         "description.ConfigurationRecorder.RoleARN",
	"status":           "description.ConfigurationRecordersStatus",
	"status_recording": "description.ConfigurationRecordersStatus.Recording",
	"title":            "description.ConfigurationRecorder.Name",
}

func ListConfigConfigurationRecorder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigConfigurationRecorder")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewConfigConfigurationRecorderPaginator(essdk.BuildFilter(d.KeyColumnQuals, listConfigConfigurationRecorderFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getConfigConfigurationRecorderFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ConfigurationRecorder.Name",
	"recording_group":  "description.ConfigurationRecorder.RecordingGroup",
	"role_arn":         "description.ConfigurationRecorder.RoleARN",
	"status":           "description.ConfigurationRecordersStatus",
	"status_recording": "description.ConfigurationRecordersStatus.Recording",
	"title":            "description.ConfigurationRecorder.Name",
}

func GetConfigConfigurationRecorder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigConfigurationRecorder")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewConfigConfigurationRecorderPaginator(essdk.BuildFilter(d.KeyColumnQuals, getConfigConfigurationRecorderFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ConfigConfigurationRecorder =============================

// ==========================  START: ConfigAggregationAuthorization =============================

type ConfigAggregationAuthorization struct {
	Description   aws.ConfigAggregationAuthorizationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type ConfigAggregationAuthorizationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  ConfigAggregationAuthorization `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type ConfigAggregationAuthorizationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []ConfigAggregationAuthorizationHit `json:"hits"`
}

type ConfigAggregationAuthorizationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  ConfigAggregationAuthorizationHits `json:"hits"`
}

type ConfigAggregationAuthorizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigAggregationAuthorizationPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigAggregationAuthorizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_aggregationauthorization", filters, limit)
	if err != nil {
		return ConfigAggregationAuthorizationPaginator{}, err
	}

	p := ConfigAggregationAuthorizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigAggregationAuthorizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigAggregationAuthorizationPaginator) NextPage(ctx context.Context) ([]ConfigAggregationAuthorization, error) {
	var response ConfigAggregationAuthorizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigAggregationAuthorization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigAggregationAuthorizationFilters = map[string]string{
	"akas":                  "description.AggregationAuthorization.AggregationAuthorizationArn",
	"arn":                   "description.AggregationAuthorization.AggregationAuthorizationArn",
	"authorized_account_id": "description.AggregationAuthorization.AuthorizedAccountId",
	"authorized_aws_region": "description.AggregationAuthorization.AuthorizedAwsRegion",
	"creation_time":         "description.AggregationAuthorization.CreationTime",
	"kaytu_account_id":      "metadata.SourceID",
	"tags":                  "description.Tags",
	"tags_src":              "description.Tags",
	"title":                 "description.AggregationAuthorization.AggregationAuthorizationArn",
}

func ListConfigAggregationAuthorization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigAggregationAuthorization")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewConfigAggregationAuthorizationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listConfigAggregationAuthorizationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getConfigAggregationAuthorizationFilters = map[string]string{
	"akas":                  "description.AggregationAuthorization.AggregationAuthorizationArn",
	"arn":                   "description.AggregationAuthorization.AggregationAuthorizationArn",
	"authorized_account_id": "description.AggregationAuthorization.AuthorizedAccountId",
	"authorized_aws_region": "description.AggregationAuthorization.AuthorizedAwsRegion",
	"creation_time":         "description.AggregationAuthorization.CreationTime",
	"kaytu_account_id":      "metadata.SourceID",
	"tags":                  "description.Tags",
	"tags_src":              "description.Tags",
	"title":                 "description.AggregationAuthorization.AggregationAuthorizationArn",
}

func GetConfigAggregationAuthorization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigAggregationAuthorization")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewConfigAggregationAuthorizationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getConfigAggregationAuthorizationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ConfigAggregationAuthorization =============================

// ==========================  START: ConfigConformancePack =============================

type ConfigConformancePack struct {
	Description   aws.ConfigConformancePackDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ConfigConformancePackHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ConfigConformancePack `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ConfigConformancePackHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ConfigConformancePackHit `json:"hits"`
}

type ConfigConformancePackSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ConfigConformancePackHits `json:"hits"`
}

type ConfigConformancePackPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigConformancePackPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigConformancePackPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_conformancepack", filters, limit)
	if err != nil {
		return ConfigConformancePackPaginator{}, err
	}

	p := ConfigConformancePackPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigConformancePackPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigConformancePackPaginator) NextPage(ctx context.Context) ([]ConfigConformancePack, error) {
	var response ConfigConformancePackSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigConformancePack
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigConformancePackFilters = map[string]string{
	"akas":                       "description.ConformancePack.ConformancePackArn",
	"arn":                        "description.ConformancePack.ConformancePackArn",
	"conformance_pack_id":        "description.ConformancePack.ConformancePackId",
	"created_by":                 "description.ConformancePack.CreatedBy",
	"delivery_s3_bucket":         "description.ConformancePack.DeliveryS3Bucket",
	"delivery_s3_key_prefix":     "description.ConformancePack.DeliveryS3KeyPrefix",
	"input_parameters":           "description.ConformancePack.ConformancePackInputParameters",
	"kaytu_account_id":           "metadata.SourceID",
	"last_update_requested_time": "description.ConformancePack.LastUpdateRequestedTime",
	"name":                       "description.ConformancePack.ConformancePackName",
	"title":                      "description.ConformancePack.ConformancePackName",
}

func ListConfigConformancePack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigConformancePack")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewConfigConformancePackPaginator(essdk.BuildFilter(d.KeyColumnQuals, listConfigConformancePackFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getConfigConformancePackFilters = map[string]string{
	"akas":                       "description.ConformancePack.ConformancePackArn",
	"arn":                        "description.ConformancePack.ConformancePackArn",
	"conformance_pack_id":        "description.ConformancePack.ConformancePackId",
	"created_by":                 "description.ConformancePack.CreatedBy",
	"delivery_s3_bucket":         "description.ConformancePack.DeliveryS3Bucket",
	"delivery_s3_key_prefix":     "description.ConformancePack.DeliveryS3KeyPrefix",
	"input_parameters":           "description.ConformancePack.ConformancePackInputParameters",
	"kaytu_account_id":           "metadata.SourceID",
	"last_update_requested_time": "description.ConformancePack.LastUpdateRequestedTime",
	"name":                       "description.ConformancePack.ConformancePackName",
	"title":                      "description.ConformancePack.ConformancePackName",
}

func GetConfigConformancePack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigConformancePack")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewConfigConformancePackPaginator(essdk.BuildFilter(d.KeyColumnQuals, getConfigConformancePackFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ConfigConformancePack =============================

// ==========================  START: ConfigRule =============================

type ConfigRule struct {
	Description   aws.ConfigRuleDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ConfigRuleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ConfigRule    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ConfigRuleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ConfigRuleHit   `json:"hits"`
}

type ConfigRuleSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ConfigRuleHits `json:"hits"`
}

type ConfigRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigRulePaginator(filters []essdk.BoolFilter, limit *int64) (ConfigRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_rule", filters, limit)
	if err != nil {
		return ConfigRulePaginator{}, err
	}

	p := ConfigRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigRulePaginator) NextPage(ctx context.Context) ([]ConfigRule, error) {
	var response ConfigRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigRuleFilters = map[string]string{
	"akas":                        "description.Rule.ConfigRuleArn",
	"arn":                         "configRuleArn",
	"compliance_by_config_rule":   "description.Compliance.ConfigRuleName",
	"created_by":                  "description.Rule.CreatedBy",
	"description":                 "description.Rule.Description",
	"evaluation_modes":            "description.Rule.EvaluationModes",
	"input_parameters":            "description.Rule.InputParameters",
	"kaytu_account_id":            "metadata.SourceID",
	"maximum_execution_frequency": "description.Rule.MaximumExecutionFrequency",
	"name":                        "description.Rule.ConfigRuleName",
	"rule_id":                     "description.Rule.ConfigRuleId",
	"rule_state":                  "description.Rule.ConfigRuleState",
	"scope":                       "description.Rule.Scope",
	"source":                      "description.Rule.Source",
	"tags_src":                    "description.Tags",
	"title":                       "description.Rule.ConfigRuleName",
}

func ListConfigRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewConfigRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listConfigRuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getConfigRuleFilters = map[string]string{
	"akas":                        "description.Rule.ConfigRuleArn",
	"arn":                         "configRuleArn",
	"compliance_by_config_rule":   "description.Compliance.ConfigRuleName",
	"created_by":                  "description.Rule.CreatedBy",
	"description":                 "description.Rule.Description",
	"evaluation_modes":            "description.Rule.EvaluationModes",
	"input_parameters":            "description.Rule.InputParameters",
	"kaytu_account_id":            "metadata.SourceID",
	"maximum_execution_frequency": "description.Rule.MaximumExecutionFrequency",
	"name":                        "description.Rule.ConfigRuleName",
	"rule_id":                     "description.Rule.ConfigRuleId",
	"rule_state":                  "description.Rule.ConfigRuleState",
	"scope":                       "description.Rule.Scope",
	"source":                      "description.Rule.Source",
	"tags_src":                    "description.Tags",
	"title":                       "description.Rule.ConfigRuleName",
}

func GetConfigRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewConfigRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getConfigRuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ConfigRule =============================

// ==========================  START: DAXCluster =============================

type DAXCluster struct {
	Description   aws.DAXClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type DAXClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DAXCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DAXClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DAXClusterHit   `json:"hits"`
}

type DAXClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  DAXClusterHits `json:"hits"`
}

type DAXClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXClusterPaginator(filters []essdk.BoolFilter, limit *int64) (DAXClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_cluster", filters, limit)
	if err != nil {
		return DAXClusterPaginator{}, err
	}

	p := DAXClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXClusterPaginator) NextPage(ctx context.Context) ([]DAXCluster, error) {
	var response DAXClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXClusterFilters = map[string]string{
	"active_nodes":                 "description.Cluster.ActiveNodes",
	"akas":                         "description.Cluster.ClusterArn",
	"arn":                          "description.Cluster.ClusterArn",
	"cluster_discovery_endpoint":   "description.Cluster.ClusterDiscoveryEndpoint",
	"cluster_name":                 "description.Cluster.ClusterName",
	"description":                  "description.Cluster.Description",
	"iam_role_arn":                 "description.Cluster.IamRoleArn",
	"kaytu_account_id":             "metadata.SourceID",
	"node_ids_to_remove":           "description.Cluster.NodeIdsToRemove",
	"node_type":                    "description.Cluster.NodeType",
	"nodes":                        "description.Cluster.Nodes",
	"notification_configuration":   "description.Cluster.NotificationConfiguration",
	"parameter_group":              "description.Cluster.ParameterGroup",
	"preferred_maintenance_window": "description.Cluster.PreferredMaintenanceWindow",
	"security_groups":              "description.Cluster.SecurityGroups",
	"sse_description":              "description.Cluster.SSEDescription",
	"status":                       "description.Cluster.Status",
	"subnet_group":                 "description.Cluster.SubnetGroup",
	"tags_src":                     "description.Tags",
	"title":                        "description.Cluster.ClusterName",
	"total_nodes":                  "description.Cluster.TotalNodes",
}

func ListDAXCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDAXClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDAXClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDAXClusterFilters = map[string]string{
	"active_nodes":                 "description.Cluster.ActiveNodes",
	"akas":                         "description.Cluster.ClusterArn",
	"arn":                          "description.Cluster.ClusterArn",
	"cluster_discovery_endpoint":   "description.Cluster.ClusterDiscoveryEndpoint",
	"cluster_name":                 "description.Cluster.ClusterName",
	"description":                  "description.Cluster.Description",
	"iam_role_arn":                 "description.Cluster.IamRoleArn",
	"kaytu_account_id":             "metadata.SourceID",
	"node_ids_to_remove":           "description.Cluster.NodeIdsToRemove",
	"node_type":                    "description.Cluster.NodeType",
	"nodes":                        "description.Cluster.Nodes",
	"notification_configuration":   "description.Cluster.NotificationConfiguration",
	"parameter_group":              "description.Cluster.ParameterGroup",
	"preferred_maintenance_window": "description.Cluster.PreferredMaintenanceWindow",
	"security_groups":              "description.Cluster.SecurityGroups",
	"sse_description":              "description.Cluster.SSEDescription",
	"status":                       "description.Cluster.Status",
	"subnet_group":                 "description.Cluster.SubnetGroup",
	"tags_src":                     "description.Tags",
	"title":                        "description.Cluster.ClusterName",
	"total_nodes":                  "description.Cluster.TotalNodes",
}

func GetDAXCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDAXClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDAXClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DAXCluster =============================

// ==========================  START: DAXParameterGroup =============================

type DAXParameterGroup struct {
	Description   aws.DAXParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type DAXParameterGroupHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DAXParameterGroup `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DAXParameterGroupHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []DAXParameterGroupHit `json:"hits"`
}

type DAXParameterGroupSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DAXParameterGroupHits `json:"hits"`
}

type DAXParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (DAXParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_parametergroup", filters, limit)
	if err != nil {
		return DAXParameterGroupPaginator{}, err
	}

	p := DAXParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXParameterGroupPaginator) NextPage(ctx context.Context) ([]DAXParameterGroup, error) {
	var response DAXParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXParameterGroupFilters = map[string]string{
	"description":          "description.ParameterGroup.Description",
	"kaytu_account_id":     "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroup.ParameterGroupName",
	"title":                "description.ParameterGroup.ParameterGroupName",
}

func ListDAXParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDAXParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDAXParameterGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDAXParameterGroupFilters = map[string]string{
	"description":          "description.ParameterGroup.Description",
	"kaytu_account_id":     "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroup.ParameterGroupName",
	"title":                "description.ParameterGroup.ParameterGroupName",
}

func GetDAXParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDAXParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDAXParameterGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DAXParameterGroup =============================

// ==========================  START: DAXParameter =============================

type DAXParameter struct {
	Description   aws.DAXParameterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type DAXParameterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DAXParameter  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DAXParameterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DAXParameterHit `json:"hits"`
}

type DAXParameterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  DAXParameterHits `json:"hits"`
}

type DAXParameterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXParameterPaginator(filters []essdk.BoolFilter, limit *int64) (DAXParameterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_parameter", filters, limit)
	if err != nil {
		return DAXParameterPaginator{}, err
	}

	p := DAXParameterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXParameterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXParameterPaginator) NextPage(ctx context.Context) ([]DAXParameter, error) {
	var response DAXParameterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXParameter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXParameterFilters = map[string]string{
	"allowed_values":       "description.Parameter.AllowedValues",
	"change_type":          "description.Parameter.ChangeType",
	"data_type":            "description.Parameter.DataType",
	"description":          "description.Parameter.Description",
	"is_modifiable":        "description.Parameter.IsModifiable",
	"kaytu_account_id":     "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroupName",
	"parameter_name":       "description.Parameter.ParameterName",
	"parameter_type":       "description.Parameter.ParameterType",
	"parameter_value":      "description.Parameter.ParameterValue",
	"source":               "description.Parameter.Source",
	"title":                "description.Parameter.ParameterName",
}

func ListDAXParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXParameter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDAXParameterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDAXParameterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDAXParameterFilters = map[string]string{
	"allowed_values":       "description.Parameter.AllowedValues",
	"change_type":          "description.Parameter.ChangeType",
	"data_type":            "description.Parameter.DataType",
	"description":          "description.Parameter.Description",
	"is_modifiable":        "description.Parameter.IsModifiable",
	"kaytu_account_id":     "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroupName",
	"parameter_name":       "description.Parameter.ParameterName",
	"parameter_type":       "description.Parameter.ParameterType",
	"parameter_value":      "description.Parameter.ParameterValue",
	"source":               "description.Parameter.Source",
	"title":                "description.Parameter.ParameterName",
}

func GetDAXParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXParameter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDAXParameterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDAXParameterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DAXParameter =============================

// ==========================  START: DAXSubnetGroup =============================

type DAXSubnetGroup struct {
	Description   aws.DAXSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type DAXSubnetGroupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  DAXSubnetGroup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type DAXSubnetGroupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []DAXSubnetGroupHit `json:"hits"`
}

type DAXSubnetGroupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  DAXSubnetGroupHits `json:"hits"`
}

type DAXSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (DAXSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_subnetgroup", filters, limit)
	if err != nil {
		return DAXSubnetGroupPaginator{}, err
	}

	p := DAXSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXSubnetGroupPaginator) NextPage(ctx context.Context) ([]DAXSubnetGroup, error) {
	var response DAXSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXSubnetGroupFilters = map[string]string{
	"akas":              "aRN",
	"description":       "description.SubnetGroup.Description",
	"kaytu_account_id":  "metadata.SourceID",
	"subnet_group_name": "description.SubnetGroup.SubnetGroupName",
	"subnets":           "description.SubnetGroup.Subnets",
	"title":             "description.SubnetGroup.SubnetGroupName",
	"vpc_id":            "description.SubnetGroup.VpcId",
}

func ListDAXSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDAXSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDAXSubnetGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDAXSubnetGroupFilters = map[string]string{
	"akas":              "aRN",
	"description":       "description.SubnetGroup.Description",
	"kaytu_account_id":  "metadata.SourceID",
	"subnet_group_name": "description.SubnetGroup.SubnetGroupName",
	"subnets":           "description.SubnetGroup.Subnets",
	"title":             "description.SubnetGroup.SubnetGroupName",
	"vpc_id":            "description.SubnetGroup.VpcId",
}

func GetDAXSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDAXSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDAXSubnetGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DAXSubnetGroup =============================

// ==========================  START: DMSReplicationInstance =============================

type DMSReplicationInstance struct {
	Description   aws.DMSReplicationInstanceDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type DMSReplicationInstanceHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  DMSReplicationInstance `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type DMSReplicationInstanceHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []DMSReplicationInstanceHit `json:"hits"`
}

type DMSReplicationInstanceSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  DMSReplicationInstanceHits `json:"hits"`
}

type DMSReplicationInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDMSReplicationInstancePaginator(filters []essdk.BoolFilter, limit *int64) (DMSReplicationInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dms_replicationinstance", filters, limit)
	if err != nil {
		return DMSReplicationInstancePaginator{}, err
	}

	p := DMSReplicationInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DMSReplicationInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DMSReplicationInstancePaginator) NextPage(ctx context.Context) ([]DMSReplicationInstance, error) {
	var response DMSReplicationInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DMSReplicationInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDMSReplicationInstanceFilters = map[string]string{
	"akas":                                      "description.ReplicationInstance.ReplicationInstanceArn",
	"allocated_storage":                         "description.ReplicationInstance.AllocatedStorage",
	"arn":                                       "description.ReplicationInstance.ReplicationInstanceArn",
	"auto_minor_version_upgrade":                "description.ReplicationInstance.AutoMinorVersionUpgrade",
	"availability_zone":                         "description.ReplicationInstance.AvailabilityZone",
	"dns_name_servers":                          "description.ReplicationInstance.DnsNameServers",
	"engine_version":                            "description.ReplicationInstance.EngineVersion",
	"free_until":                                "description.ReplicationInstance.FreeUntil",
	"instance_create_time":                      "description.ReplicationInstance.InstanceCreateTime",
	"kaytu_account_id":                          "metadata.SourceID",
	"kms_key_id":                                "description.ReplicationInstance.KmsKeyId",
	"multi_az":                                  "description.ReplicationInstance.MultiAZ",
	"pending_modified_values":                   "description.ReplicationInstance.PendingModifiedValues",
	"preferred_maintenance_window":              "description.ReplicationInstance.PreferredMaintenanceWindow",
	"publicly_accessible":                       "description.ReplicationInstance.PubliclyAccessible",
	"replication_instance_class":                "description.ReplicationInstance.ReplicationInstanceClass",
	"replication_instance_identifier":           "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"replication_instance_private_ip_address":   "description.ReplicationInstance.ReplicationInstancePrivateIpAddress",
	"replication_instance_private_ip_addresses": "description.ReplicationInstance.ReplicationInstancePrivateIpAddresses",
	"replication_instance_public_ip_address":    "description.ReplicationInstance.ReplicationInstancePublicIpAddress",
	"replication_instance_public_ip_addresses":  "description.ReplicationInstance.ReplicationInstancePublicIpAddresses",
	"replication_instance_status":               "description.ReplicationInstance.ReplicationInstanceStatus",
	"replication_subnet_group":                  "description.ReplicationInstance.ReplicationSubnetGroup",
	"secondary_availability_zone":               "description.ReplicationInstance.SecondaryAvailabilityZone",
	"tags_src":                                  "description.Tags",
	"title":                                     "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"vpc_security_groups":                       "description.ReplicationInstance.VpcSecurityGroups",
}

func ListDMSReplicationInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDMSReplicationInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDMSReplicationInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDMSReplicationInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDMSReplicationInstanceFilters = map[string]string{
	"akas":                                      "description.ReplicationInstance.ReplicationInstanceArn",
	"allocated_storage":                         "description.ReplicationInstance.AllocatedStorage",
	"arn":                                       "description.ReplicationInstance.ReplicationInstanceArn",
	"auto_minor_version_upgrade":                "description.ReplicationInstance.AutoMinorVersionUpgrade",
	"availability_zone":                         "description.ReplicationInstance.AvailabilityZone",
	"dns_name_servers":                          "description.ReplicationInstance.DnsNameServers",
	"engine_version":                            "description.ReplicationInstance.EngineVersion",
	"free_until":                                "description.ReplicationInstance.FreeUntil",
	"instance_create_time":                      "description.ReplicationInstance.InstanceCreateTime",
	"kaytu_account_id":                          "metadata.SourceID",
	"kms_key_id":                                "description.ReplicationInstance.KmsKeyId",
	"multi_az":                                  "description.ReplicationInstance.MultiAZ",
	"pending_modified_values":                   "description.ReplicationInstance.PendingModifiedValues",
	"preferred_maintenance_window":              "description.ReplicationInstance.PreferredMaintenanceWindow",
	"publicly_accessible":                       "description.ReplicationInstance.PubliclyAccessible",
	"replication_instance_class":                "description.ReplicationInstance.ReplicationInstanceClass",
	"replication_instance_identifier":           "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"replication_instance_private_ip_address":   "description.ReplicationInstance.ReplicationInstancePrivateIpAddress",
	"replication_instance_private_ip_addresses": "description.ReplicationInstance.ReplicationInstancePrivateIpAddresses",
	"replication_instance_public_ip_address":    "description.ReplicationInstance.ReplicationInstancePublicIpAddress",
	"replication_instance_public_ip_addresses":  "description.ReplicationInstance.ReplicationInstancePublicIpAddresses",
	"replication_instance_status":               "description.ReplicationInstance.ReplicationInstanceStatus",
	"replication_subnet_group":                  "description.ReplicationInstance.ReplicationSubnetGroup",
	"secondary_availability_zone":               "description.ReplicationInstance.SecondaryAvailabilityZone",
	"tags_src":                                  "description.Tags",
	"title":                                     "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"vpc_security_groups":                       "description.ReplicationInstance.VpcSecurityGroups",
}

func GetDMSReplicationInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDMSReplicationInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDMSReplicationInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDMSReplicationInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DMSReplicationInstance =============================

// ==========================  START: DynamoDbTable =============================

type DynamoDbTable struct {
	Description   aws.DynamoDbTableDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type DynamoDbTableHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DynamoDbTable `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DynamoDbTableHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []DynamoDbTableHit `json:"hits"`
}

type DynamoDbTableSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  DynamoDbTableHits `json:"hits"`
}

type DynamoDbTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbTablePaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_table", filters, limit)
	if err != nil {
		return DynamoDbTablePaginator{}, err
	}

	p := DynamoDbTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbTablePaginator) NextPage(ctx context.Context) ([]DynamoDbTable, error) {
	var response DynamoDbTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbTableFilters = map[string]string{
	"akas":                               "description.Table.TableArn",
	"archival_summary":                   "description.Table.ArchivalSummary",
	"arn":                                "description.Table.TableArn",
	"attribute_definitions":              "description.Table.AttributeDefinitions",
	"billing_mode":                       "description.Table.BillingModeSummary.BillingMode",
	"continuous_backups_status":          "description.ContinuousBackup.ContinuousBackupsStatus",
	"creation_date_time":                 "description.Table.CreationDateTime",
	"global_table_version":               "description.Table.GlobalTableVersion",
	"item_count":                         "description.Table.ItemCount",
	"kaytu_account_id":                   "metadata.SourceID",
	"key_schema":                         "description.Table.KeySchema",
	"latest_stream_arn":                  "description.Table.LatestStreamArn",
	"latest_stream_label":                "description.Table.LatestStreamLabel",
	"name":                               "description.Table.TableName",
	"point_in_time_recovery_description": "description.ContinuousBackup.PointInTimeRecoveryDescription",
	"read_capacity":                      "description.Table.ProvisionedThroughput.ReadCapacityUnits",
	"sse_description":                    "description.Table.SSEDescription",
	"table_class":                        "description.Table.TableClassSummary.TableClass",
	"table_id":                           "description.Table.TableId",
	"table_size_bytes":                   "description.Table.TableSizeBytes",
	"table_status":                       "description.Table.TableStatus",
	"tags_src":                           "description.Tags",
	"title":                              "description.Table.TableName",
	"write_capacity":                     "description.Table.ProvisionedThroughput.WriteCapacityUnits",
}

func ListDynamoDbTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDynamoDbTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDynamoDbTableFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDynamoDbTableFilters = map[string]string{
	"akas":                               "description.Table.TableArn",
	"archival_summary":                   "description.Table.ArchivalSummary",
	"arn":                                "description.Table.TableArn",
	"attribute_definitions":              "description.Table.AttributeDefinitions",
	"billing_mode":                       "description.Table.BillingModeSummary.BillingMode",
	"continuous_backups_status":          "description.ContinuousBackup.ContinuousBackupsStatus",
	"creation_date_time":                 "description.Table.CreationDateTime",
	"global_table_version":               "description.Table.GlobalTableVersion",
	"item_count":                         "description.Table.ItemCount",
	"kaytu_account_id":                   "metadata.SourceID",
	"key_schema":                         "description.Table.KeySchema",
	"latest_stream_arn":                  "description.Table.LatestStreamArn",
	"latest_stream_label":                "description.Table.LatestStreamLabel",
	"name":                               "description.Table.TableName",
	"point_in_time_recovery_description": "description.ContinuousBackup.PointInTimeRecoveryDescription",
	"read_capacity":                      "description.Table.ProvisionedThroughput.ReadCapacityUnits",
	"sse_description":                    "description.Table.SSEDescription",
	"table_class":                        "description.Table.TableClassSummary.TableClass",
	"table_id":                           "description.Table.TableId",
	"table_size_bytes":                   "description.Table.TableSizeBytes",
	"table_status":                       "description.Table.TableStatus",
	"tags_src":                           "description.Tags",
	"title":                              "description.Table.TableName",
	"write_capacity":                     "description.Table.ProvisionedThroughput.WriteCapacityUnits",
}

func GetDynamoDbTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDynamoDbTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDynamoDbTableFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DynamoDbTable =============================

// ==========================  START: DynamoDbGlobalSecondaryIndex =============================

type DynamoDbGlobalSecondaryIndex struct {
	Description   aws.DynamoDbGlobalSecondaryIndexDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type DynamoDbGlobalSecondaryIndexHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  DynamoDbGlobalSecondaryIndex `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type DynamoDbGlobalSecondaryIndexHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []DynamoDbGlobalSecondaryIndexHit `json:"hits"`
}

type DynamoDbGlobalSecondaryIndexSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  DynamoDbGlobalSecondaryIndexHits `json:"hits"`
}

type DynamoDbGlobalSecondaryIndexPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbGlobalSecondaryIndexPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbGlobalSecondaryIndexPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_globalsecondaryindex", filters, limit)
	if err != nil {
		return DynamoDbGlobalSecondaryIndexPaginator{}, err
	}

	p := DynamoDbGlobalSecondaryIndexPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbGlobalSecondaryIndexPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbGlobalSecondaryIndexPaginator) NextPage(ctx context.Context) ([]DynamoDbGlobalSecondaryIndex, error) {
	var response DynamoDbGlobalSecondaryIndexSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbGlobalSecondaryIndex
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbGlobalSecondaryIndexFilters = map[string]string{
	"akas":             "description.GlobalSecondaryIndex.IndexArn",
	"index_arn":        "description.GlobalSecondaryIndex.IndexArn",
	"index_name":       "description.GlobalSecondaryIndex.IndexName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.GlobalSecondaryIndex.IndexName",
}

func ListDynamoDbGlobalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbGlobalSecondaryIndex")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDynamoDbGlobalSecondaryIndexPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDynamoDbGlobalSecondaryIndexFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDynamoDbGlobalSecondaryIndexFilters = map[string]string{
	"akas":             "description.GlobalSecondaryIndex.IndexArn",
	"index_arn":        "description.GlobalSecondaryIndex.IndexArn",
	"index_name":       "description.GlobalSecondaryIndex.IndexName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.GlobalSecondaryIndex.IndexName",
}

func GetDynamoDbGlobalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbGlobalSecondaryIndex")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDynamoDbGlobalSecondaryIndexPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDynamoDbGlobalSecondaryIndexFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DynamoDbGlobalSecondaryIndex =============================

// ==========================  START: DynamoDbLocalSecondaryIndex =============================

type DynamoDbLocalSecondaryIndex struct {
	Description   aws.DynamoDbLocalSecondaryIndexDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type DynamoDbLocalSecondaryIndexHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  DynamoDbLocalSecondaryIndex `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type DynamoDbLocalSecondaryIndexHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []DynamoDbLocalSecondaryIndexHit `json:"hits"`
}

type DynamoDbLocalSecondaryIndexSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  DynamoDbLocalSecondaryIndexHits `json:"hits"`
}

type DynamoDbLocalSecondaryIndexPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbLocalSecondaryIndexPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbLocalSecondaryIndexPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_localsecondaryindex", filters, limit)
	if err != nil {
		return DynamoDbLocalSecondaryIndexPaginator{}, err
	}

	p := DynamoDbLocalSecondaryIndexPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbLocalSecondaryIndexPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbLocalSecondaryIndexPaginator) NextPage(ctx context.Context) ([]DynamoDbLocalSecondaryIndex, error) {
	var response DynamoDbLocalSecondaryIndexSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbLocalSecondaryIndex
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbLocalSecondaryIndexFilters = map[string]string{
	"akas":             "description.LocalSecondaryIndex.IndexArn",
	"index_arn":        "description.LocalSecondaryIndex.IndexArn",
	"index_name":       "description.LocalSecondaryIndex.IndexName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.LocalSecondaryIndex.IndexName",
}

func ListDynamoDbLocalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbLocalSecondaryIndex")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDynamoDbLocalSecondaryIndexPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDynamoDbLocalSecondaryIndexFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDynamoDbLocalSecondaryIndexFilters = map[string]string{
	"akas":             "description.LocalSecondaryIndex.IndexArn",
	"index_arn":        "description.LocalSecondaryIndex.IndexArn",
	"index_name":       "description.LocalSecondaryIndex.IndexName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.LocalSecondaryIndex.IndexName",
}

func GetDynamoDbLocalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbLocalSecondaryIndex")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDynamoDbLocalSecondaryIndexPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDynamoDbLocalSecondaryIndexFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DynamoDbLocalSecondaryIndex =============================

// ==========================  START: DynamoDbStream =============================

type DynamoDbStream struct {
	Description   aws.DynamoDbStreamDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type DynamoDbStreamHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  DynamoDbStream `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type DynamoDbStreamHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []DynamoDbStreamHit `json:"hits"`
}

type DynamoDbStreamSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  DynamoDbStreamHits `json:"hits"`
}

type DynamoDbStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbStreamPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodbstreams_stream", filters, limit)
	if err != nil {
		return DynamoDbStreamPaginator{}, err
	}

	p := DynamoDbStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbStreamPaginator) NextPage(ctx context.Context) ([]DynamoDbStream, error) {
	var response DynamoDbStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbStreamFilters = map[string]string{
	"akas":             "description.Stream.StreamArn",
	"kaytu_account_id": "metadata.SourceID",
	"stream_arn":       "description.Stream.StreamArn",
	"stream_label":     "description.Stream.StreamLabel",
	"title":            "description.Stream.StreamLabel",
}

func ListDynamoDbStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDynamoDbStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDynamoDbStreamFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDynamoDbStreamFilters = map[string]string{
	"akas":             "description.Stream.StreamArn",
	"kaytu_account_id": "metadata.SourceID",
	"stream_arn":       "description.Stream.StreamArn",
	"stream_label":     "description.Stream.StreamLabel",
	"title":            "description.Stream.StreamLabel",
}

func GetDynamoDbStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDynamoDbStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDynamoDbStreamFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DynamoDbStream =============================

// ==========================  START: DynamoDbBackup =============================

type DynamoDbBackup struct {
	Description   aws.DynamoDbBackupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type DynamoDbBackupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  DynamoDbBackup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type DynamoDbBackupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []DynamoDbBackupHit `json:"hits"`
}

type DynamoDbBackupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  DynamoDbBackupHits `json:"hits"`
}

type DynamoDbBackupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbBackupPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbBackupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_backup", filters, limit)
	if err != nil {
		return DynamoDbBackupPaginator{}, err
	}

	p := DynamoDbBackupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbBackupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbBackupPaginator) NextPage(ctx context.Context) ([]DynamoDbBackup, error) {
	var response DynamoDbBackupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbBackup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbBackupFilters = map[string]string{
	"akas":                     "description.Backup.BackupArn",
	"arn":                      "description.Backup.BackupArn",
	"backup_creation_datetime": "description.Backup.BackupCreationDateTime",
	"backup_expiry_datetime":   "description.Backup.BackupExpiryDateTime",
	"backup_size_bytes":        "description.Backup.BackupSizeBytes",
	"backup_status":            "description.Backup.BackupStatus",
	"backup_type":              "description.Backup.BackupType",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.Backup.BackupName",
	"table_arn":                "description.Backup.TableArn",
	"table_id":                 "description.Backup.TableId",
	"table_name":               "description.Backup.TableName",
	"title":                    "description.Backup.BackupName",
}

func ListDynamoDbBackup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbBackup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDynamoDbBackupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDynamoDbBackupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDynamoDbBackupFilters = map[string]string{
	"akas":                     "description.Backup.BackupArn",
	"arn":                      "description.Backup.BackupArn",
	"backup_creation_datetime": "description.Backup.BackupCreationDateTime",
	"backup_expiry_datetime":   "description.Backup.BackupExpiryDateTime",
	"backup_size_bytes":        "description.Backup.BackupSizeBytes",
	"backup_status":            "description.Backup.BackupStatus",
	"backup_type":              "description.Backup.BackupType",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.Backup.BackupName",
	"table_arn":                "description.Backup.TableArn",
	"table_id":                 "description.Backup.TableId",
	"table_name":               "description.Backup.TableName",
	"title":                    "description.Backup.BackupName",
}

func GetDynamoDbBackup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbBackup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDynamoDbBackupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDynamoDbBackupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DynamoDbBackup =============================

// ==========================  START: DynamoDbGlobalTable =============================

type DynamoDbGlobalTable struct {
	Description   aws.DynamoDbGlobalTableDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type DynamoDbGlobalTableHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DynamoDbGlobalTable `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DynamoDbGlobalTableHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DynamoDbGlobalTableHit `json:"hits"`
}

type DynamoDbGlobalTableSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DynamoDbGlobalTableHits `json:"hits"`
}

type DynamoDbGlobalTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbGlobalTablePaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbGlobalTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_globaltable", filters, limit)
	if err != nil {
		return DynamoDbGlobalTablePaginator{}, err
	}

	p := DynamoDbGlobalTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbGlobalTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbGlobalTablePaginator) NextPage(ctx context.Context) ([]DynamoDbGlobalTable, error) {
	var response DynamoDbGlobalTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbGlobalTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbGlobalTableFilters = map[string]string{
	"akas":                "description.GlobalTable.GlobalTableArn",
	"creation_date_time":  "description.GlobalTable.CreationDateTime",
	"global_table_arn":    "description.GlobalTable.GlobalTableArn",
	"global_table_name":   "description.GlobalTable.GlobalTableName",
	"global_table_status": "description.GlobalTable.GlobalTableStatus",
	"kaytu_account_id":    "metadata.SourceID",
	"replication_group":   "description.GlobalTable.ReplicationGroup",
	"title":               "description.GlobalTable.GlobalTableName",
}

func ListDynamoDbGlobalTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbGlobalTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDynamoDbGlobalTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDynamoDbGlobalTableFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDynamoDbGlobalTableFilters = map[string]string{
	"akas":                "description.GlobalTable.GlobalTableArn",
	"creation_date_time":  "description.GlobalTable.CreationDateTime",
	"global_table_arn":    "description.GlobalTable.GlobalTableArn",
	"global_table_name":   "description.GlobalTable.GlobalTableName",
	"global_table_status": "description.GlobalTable.GlobalTableStatus",
	"kaytu_account_id":    "metadata.SourceID",
	"replication_group":   "description.GlobalTable.ReplicationGroup",
	"title":               "description.GlobalTable.GlobalTableName",
}

func GetDynamoDbGlobalTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbGlobalTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDynamoDbGlobalTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDynamoDbGlobalTableFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DynamoDbGlobalTable =============================

// ==========================  START: DynamoDbTableExport =============================

type DynamoDbTableExport struct {
	Description   aws.DynamoDbTableExportDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type DynamoDbTableExportHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DynamoDbTableExport `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DynamoDbTableExportHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DynamoDbTableExportHit `json:"hits"`
}

type DynamoDbTableExportSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DynamoDbTableExportHits `json:"hits"`
}

type DynamoDbTableExportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbTableExportPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbTableExportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_tableexport", filters, limit)
	if err != nil {
		return DynamoDbTableExportPaginator{}, err
	}

	p := DynamoDbTableExportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbTableExportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbTableExportPaginator) NextPage(ctx context.Context) ([]DynamoDbTableExport, error) {
	var response DynamoDbTableExportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbTableExport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbTableExportFilters = map[string]string{
	"akas":              "description.Export.ExportArn",
	"arn":               "description.Export.ExportArn",
	"billed_size_bytes": "description.Export.BilledSizeBytes",
	"client_token":      "description.Export.ClientToken",
	"end_time":          "description.Export.EndTime",
	"export_format":     "description.Export.ExportFormat",
	"export_manifest":   "description.Export.ExportManifest",
	"export_status":     "description.Export.ExportStatus",
	"export_time":       "description.Export.ExportTime",
	"failure_code":      "description.Export.FailureCode",
	"failure_message":   "description.Export.FailureMessage",
	"item_count":        "description.Export.ItemCount",
	"kaytu_account_id":  "metadata.SourceID",
	"s3_bucket":         "description.Export.S3Bucket",
	"s3_bucket_owner":   "description.Export.S3BucketOwner",
	"s3_prefix":         "description.Export.S3Prefix",
	"s3_sse_algorithm":  "description.Export.S3SseAlgorithm",
	"s3_sse_kms_key_id": "description.Export.S3SseKmsKeyId",
	"start_time":        "description.Export.StartTime",
	"table_arn":         "description.Export.TableArn",
	"table_id":          "description.Export.TableId",
}

func ListDynamoDbTableExport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbTableExport")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDynamoDbTableExportPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDynamoDbTableExportFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDynamoDbTableExportFilters = map[string]string{
	"akas":              "description.Export.ExportArn",
	"arn":               "description.Export.ExportArn",
	"billed_size_bytes": "description.Export.BilledSizeBytes",
	"client_token":      "description.Export.ClientToken",
	"end_time":          "description.Export.EndTime",
	"export_format":     "description.Export.ExportFormat",
	"export_manifest":   "description.Export.ExportManifest",
	"export_status":     "description.Export.ExportStatus",
	"export_time":       "description.Export.ExportTime",
	"failure_code":      "description.Export.FailureCode",
	"failure_message":   "description.Export.FailureMessage",
	"item_count":        "description.Export.ItemCount",
	"kaytu_account_id":  "metadata.SourceID",
	"s3_bucket":         "description.Export.S3Bucket",
	"s3_bucket_owner":   "description.Export.S3BucketOwner",
	"s3_prefix":         "description.Export.S3Prefix",
	"s3_sse_algorithm":  "description.Export.S3SseAlgorithm",
	"s3_sse_kms_key_id": "description.Export.S3SseKmsKeyId",
	"start_time":        "description.Export.StartTime",
	"table_arn":         "description.Export.TableArn",
	"table_id":          "description.Export.TableId",
}

func GetDynamoDbTableExport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbTableExport")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDynamoDbTableExportPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDynamoDbTableExportFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DynamoDbTableExport =============================

// ==========================  START: OAMLink =============================

type OAMLink struct {
	Description   aws.OAMLinkDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type OAMLinkHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  OAMLink       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OAMLinkHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OAMLinkHit      `json:"hits"`
}

type OAMLinkSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  OAMLinkHits `json:"hits"`
}

type OAMLinkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOAMLinkPaginator(filters []essdk.BoolFilter, limit *int64) (OAMLinkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_oam_link", filters, limit)
	if err != nil {
		return OAMLinkPaginator{}, err
	}

	p := OAMLinkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OAMLinkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OAMLinkPaginator) NextPage(ctx context.Context) ([]OAMLink, error) {
	var response OAMLinkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OAMLink
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOAMLinkFilters = map[string]string{
	"akas":             "description.Link.Tags",
	"arn":              "description.Link.Arn",
	"id":               "description.Link.Id",
	"kaytu_account_id": "metadata.SourceID",
	"label":            "description.Link.Label",
	"label_template":   "description.Link.LabelTemplate",
	"resource_types":   "description.Link.ResourceTypes",
	"sink_arn":         "description.Link.SinkArn",
	"tags":             "description.Link.Tags",
	"title":            "description.Link.Label",
}

func ListOAMLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOAMLink")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewOAMLinkPaginator(essdk.BuildFilter(d.KeyColumnQuals, listOAMLinkFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getOAMLinkFilters = map[string]string{
	"akas":             "description.Link.Tags",
	"arn":              "description.Link.Arn",
	"id":               "description.Link.Id",
	"kaytu_account_id": "metadata.SourceID",
	"label":            "description.Link.Label",
	"label_template":   "description.Link.LabelTemplate",
	"resource_types":   "description.Link.ResourceTypes",
	"sink_arn":         "description.Link.SinkArn",
	"tags":             "description.Link.Tags",
	"title":            "description.Link.Label",
}

func GetOAMLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOAMLink")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewOAMLinkPaginator(essdk.BuildFilter(d.KeyColumnQuals, getOAMLinkFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: OAMLink =============================

// ==========================  START: OAMSink =============================

type OAMSink struct {
	Description   aws.OAMSinkDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type OAMSinkHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  OAMSink       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OAMSinkHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OAMSinkHit      `json:"hits"`
}

type OAMSinkSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  OAMSinkHits `json:"hits"`
}

type OAMSinkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOAMSinkPaginator(filters []essdk.BoolFilter, limit *int64) (OAMSinkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_oam_sink", filters, limit)
	if err != nil {
		return OAMSinkPaginator{}, err
	}

	p := OAMSinkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OAMSinkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OAMSinkPaginator) NextPage(ctx context.Context) ([]OAMSink, error) {
	var response OAMSinkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OAMSink
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOAMSinkFilters = map[string]string{
	"akas":             "description.Sink.Arn",
	"arn":              "description.Sink.Arn",
	"id":               "description.Sink.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Sink.Name",
	"tags":             "description.Tags",
	"title":            "description.Sink.Name",
}

func ListOAMSink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOAMSink")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewOAMSinkPaginator(essdk.BuildFilter(d.KeyColumnQuals, listOAMSinkFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getOAMSinkFilters = map[string]string{
	"akas":             "description.Sink.Arn",
	"arn":              "description.Sink.Arn",
	"id":               "description.Sink.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Sink.Name",
	"tags":             "description.Tags",
	"title":            "description.Sink.Name",
}

func GetOAMSink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOAMSink")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewOAMSinkPaginator(essdk.BuildFilter(d.KeyColumnQuals, getOAMSinkFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: OAMSink =============================

// ==========================  START: EC2VolumeSnapshot =============================

type EC2VolumeSnapshot struct {
	Description   aws.EC2VolumeSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2VolumeSnapshotHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2VolumeSnapshot `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2VolumeSnapshotHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2VolumeSnapshotHit `json:"hits"`
}

type EC2VolumeSnapshotSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2VolumeSnapshotHits `json:"hits"`
}

type EC2VolumeSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VolumeSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VolumeSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_volumesnapshot", filters, limit)
	if err != nil {
		return EC2VolumeSnapshotPaginator{}, err
	}

	p := EC2VolumeSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VolumeSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VolumeSnapshotPaginator) NextPage(ctx context.Context) ([]EC2VolumeSnapshot, error) {
	var response EC2VolumeSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VolumeSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VolumeSnapshotFilters = map[string]string{
	"create_volume_permissions": "description.CreateVolumePermissions",
	"data_encryption_key_id":    "description.Snapshot.DataEncryptionKeyId",
	"description":               "description.Snapshot.Description",
	"encrypted":                 "description.Snapshot.Encrypted",
	"kaytu_account_id":          "metadata.SourceID",
	"kms_key_id":                "description.Snapshot.KmsKeyId",
	"owner_alias":               "description.Snapshot.OwnerAlias",
	"owner_id":                  "description.Snapshot.OwnerId",
	"progress":                  "description.Snapshot.Progress",
	"snapshot_id":               "description.Snapshot.SnapshotId",
	"start_time":                "description.Snapshot.StartTime",
	"state":                     "description.Snapshot.State",
	"state_message":             "description.Snapshot.StateMessage",
	"tags_src":                  "description.Snapshot.Tags",
	"title":                     "description.Snapshot.SnapshotId",
	"volume_id":                 "description.Snapshot.VolumeId",
	"volume_size":               "description.Snapshot.VolumeSize",
}

func ListEC2VolumeSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VolumeSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VolumeSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VolumeSnapshotFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VolumeSnapshotFilters = map[string]string{
	"create_volume_permissions": "description.CreateVolumePermissions",
	"data_encryption_key_id":    "description.Snapshot.DataEncryptionKeyId",
	"description":               "description.Snapshot.Description",
	"encrypted":                 "description.Snapshot.Encrypted",
	"kaytu_account_id":          "metadata.SourceID",
	"kms_key_id":                "description.Snapshot.KmsKeyId",
	"owner_alias":               "description.Snapshot.OwnerAlias",
	"owner_id":                  "description.Snapshot.OwnerId",
	"progress":                  "description.Snapshot.Progress",
	"snapshot_id":               "description.Snapshot.SnapshotId",
	"start_time":                "description.Snapshot.StartTime",
	"state":                     "description.Snapshot.State",
	"state_message":             "description.Snapshot.StateMessage",
	"tags_src":                  "description.Snapshot.Tags",
	"title":                     "description.Snapshot.SnapshotId",
	"volume_id":                 "description.Snapshot.VolumeId",
	"volume_size":               "description.Snapshot.VolumeSize",
}

func GetEC2VolumeSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VolumeSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VolumeSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VolumeSnapshotFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VolumeSnapshot =============================

// ==========================  START: EC2CustomerGateway =============================

type EC2CustomerGateway struct {
	Description   aws.EC2CustomerGatewayDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type EC2CustomerGatewayHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  EC2CustomerGateway `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type EC2CustomerGatewayHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []EC2CustomerGatewayHit `json:"hits"`
}

type EC2CustomerGatewaySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  EC2CustomerGatewayHits `json:"hits"`
}

type EC2CustomerGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2CustomerGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2CustomerGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_customergateway", filters, limit)
	if err != nil {
		return EC2CustomerGatewayPaginator{}, err
	}

	p := EC2CustomerGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2CustomerGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2CustomerGatewayPaginator) NextPage(ctx context.Context) ([]EC2CustomerGateway, error) {
	var response EC2CustomerGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2CustomerGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2CustomerGatewayFilters = map[string]string{
	"akas":                "description.CustomerGateway.Tags",
	"bgp_asn":             "description.CustomerGateway.BgpAsn",
	"certificate_arn":     "description.CustomerGateway.CertificateArn",
	"customer_gateway_id": "description.CustomerGateway.CustomerGatewayId",
	"device_name":         "description.CustomerGateway.DeviceName",
	"ip_address":          "description.CustomerGateway.IpAddress",
	"kaytu_account_id":    "metadata.SourceID",
	"state":               "description.CustomerGateway.State",
	"tags_src":            "description.CustomerGateway.Tags",
	"type":                "description.CustomerGateway.Type",
}

func ListEC2CustomerGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2CustomerGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2CustomerGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2CustomerGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2CustomerGatewayFilters = map[string]string{
	"akas":                "description.CustomerGateway.Tags",
	"bgp_asn":             "description.CustomerGateway.BgpAsn",
	"certificate_arn":     "description.CustomerGateway.CertificateArn",
	"customer_gateway_id": "description.CustomerGateway.CustomerGatewayId",
	"device_name":         "description.CustomerGateway.DeviceName",
	"ip_address":          "description.CustomerGateway.IpAddress",
	"kaytu_account_id":    "metadata.SourceID",
	"state":               "description.CustomerGateway.State",
	"tags_src":            "description.CustomerGateway.Tags",
	"type":                "description.CustomerGateway.Type",
}

func GetEC2CustomerGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2CustomerGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2CustomerGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2CustomerGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2CustomerGateway =============================

// ==========================  START: EC2VerifiedAccessInstance =============================

type EC2VerifiedAccessInstance struct {
	Description   aws.EC2VerifiedAccessInstanceDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type EC2VerifiedAccessInstanceHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  EC2VerifiedAccessInstance `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type EC2VerifiedAccessInstanceHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []EC2VerifiedAccessInstanceHit `json:"hits"`
}

type EC2VerifiedAccessInstanceSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  EC2VerifiedAccessInstanceHits `json:"hits"`
}

type EC2VerifiedAccessInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessInstancePaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccessinstance", filters, limit)
	if err != nil {
		return EC2VerifiedAccessInstancePaginator{}, err
	}

	p := EC2VerifiedAccessInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessInstancePaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessInstance, error) {
	var response EC2VerifiedAccessInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessInstanceFilters = map[string]string{
	"creation_time":                   "description.VerifiedAccountInstance.CreationTime",
	"description":                     "description.VerifiedAccountInstance.Description",
	"kaytu_account_id":                "metadata.SourceID",
	"last_updated_time":               "description.VerifiedAccountInstance.LastUpdatedTime",
	"tags_src":                        "description.VerifiedAccountInstance.Tags",
	"verified_access_instance_id":     "description.VerifiedAccountInstance.VerifiedAccessInstanceId",
	"verified_access_trust_providers": "description.VerifiedAccountInstance.VerifiedAccessTrustProviders",
}

func ListEC2VerifiedAccessInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VerifiedAccessInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VerifiedAccessInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VerifiedAccessInstanceFilters = map[string]string{
	"creation_time":                   "description.VerifiedAccountInstance.CreationTime",
	"description":                     "description.VerifiedAccountInstance.Description",
	"kaytu_account_id":                "metadata.SourceID",
	"last_updated_time":               "description.VerifiedAccountInstance.LastUpdatedTime",
	"tags_src":                        "description.VerifiedAccountInstance.Tags",
	"verified_access_instance_id":     "description.VerifiedAccountInstance.VerifiedAccessInstanceId",
	"verified_access_trust_providers": "description.VerifiedAccountInstance.VerifiedAccessTrustProviders",
}

func GetEC2VerifiedAccessInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VerifiedAccessInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessInstance =============================

// ==========================  START: EC2VerifiedAccessEndpoint =============================

type EC2VerifiedAccessEndpoint struct {
	Description   aws.EC2VerifiedAccessEndpointDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type EC2VerifiedAccessEndpointHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  EC2VerifiedAccessEndpoint `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type EC2VerifiedAccessEndpointHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []EC2VerifiedAccessEndpointHit `json:"hits"`
}

type EC2VerifiedAccessEndpointSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  EC2VerifiedAccessEndpointHits `json:"hits"`
}

type EC2VerifiedAccessEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccessendpoint", filters, limit)
	if err != nil {
		return EC2VerifiedAccessEndpointPaginator{}, err
	}

	p := EC2VerifiedAccessEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessEndpointPaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessEndpoint, error) {
	var response EC2VerifiedAccessEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessEndpointFilters = map[string]string{
	"application_domain":          "description.VerifiedAccountEndpoint.ApplicationDomain",
	"attachment_type":             "description.VerifiedAccountEndpoint.AttachmentType",
	"creation_time":               "description.VerifiedAccountEndpoint.CreationTime",
	"deletion_time":               "description.VerifiedAccountEndpoint.DeletionTime",
	"description":                 "description.VerifiedAccountEndpoint.Description",
	"device_validation_domain":    "description.VerifiedAccountEndpoint.DeviceValidationDomain",
	"domain_certificate_arn":      "description.VerifiedAccountEndpoint.DomainCertificateArn",
	"endpoint_domain":             "description.VerifiedAccountEndpoint.EndpointDomain",
	"endpoint_type":               "description.VerifiedAccountEndpoint.EndpointType",
	"kaytu_account_id":            "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountEndpoint.LastUpdatedTime",
	"load_balancer_options":       "description.VerifiedAccountEndpoint.LoadBalancerOptions",
	"network_interface_options":   "description.VerifiedAccountEndpoint.NetworkInterfaceOptions",
	"status":                      "description.VerifiedAccountEndpoint.Status",
	"status_code":                 "description.VerifiedAccountEndpoint.Status.Code",
	"tags_src":                    "description.VerifiedAccountEndpoint.Tags",
	"verified_access_endpoint_id": "description.VerifiedAccountEndpoint.VerifiedAccessEndpointId",
	"verified_access_group_id":    "description.VerifiedAccountEndpoint.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountEndpoint.VerifiedAccessInstanceId",
}

func ListEC2VerifiedAccessEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VerifiedAccessEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VerifiedAccessEndpointFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VerifiedAccessEndpointFilters = map[string]string{
	"application_domain":          "description.VerifiedAccountEndpoint.ApplicationDomain",
	"attachment_type":             "description.VerifiedAccountEndpoint.AttachmentType",
	"creation_time":               "description.VerifiedAccountEndpoint.CreationTime",
	"deletion_time":               "description.VerifiedAccountEndpoint.DeletionTime",
	"description":                 "description.VerifiedAccountEndpoint.Description",
	"device_validation_domain":    "description.VerifiedAccountEndpoint.DeviceValidationDomain",
	"domain_certificate_arn":      "description.VerifiedAccountEndpoint.DomainCertificateArn",
	"endpoint_domain":             "description.VerifiedAccountEndpoint.EndpointDomain",
	"endpoint_type":               "description.VerifiedAccountEndpoint.EndpointType",
	"kaytu_account_id":            "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountEndpoint.LastUpdatedTime",
	"load_balancer_options":       "description.VerifiedAccountEndpoint.LoadBalancerOptions",
	"network_interface_options":   "description.VerifiedAccountEndpoint.NetworkInterfaceOptions",
	"status":                      "description.VerifiedAccountEndpoint.Status",
	"status_code":                 "description.VerifiedAccountEndpoint.Status.Code",
	"tags_src":                    "description.VerifiedAccountEndpoint.Tags",
	"verified_access_endpoint_id": "description.VerifiedAccountEndpoint.VerifiedAccessEndpointId",
	"verified_access_group_id":    "description.VerifiedAccountEndpoint.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountEndpoint.VerifiedAccessInstanceId",
}

func GetEC2VerifiedAccessEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VerifiedAccessEndpointFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessEndpoint =============================

// ==========================  START: EC2VerifiedAccessGroup =============================

type EC2VerifiedAccessGroup struct {
	Description   aws.EC2VerifiedAccessGroupDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type EC2VerifiedAccessGroupHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  EC2VerifiedAccessGroup `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type EC2VerifiedAccessGroupHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []EC2VerifiedAccessGroupHit `json:"hits"`
}

type EC2VerifiedAccessGroupSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  EC2VerifiedAccessGroupHits `json:"hits"`
}

type EC2VerifiedAccessGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccessgroup", filters, limit)
	if err != nil {
		return EC2VerifiedAccessGroupPaginator{}, err
	}

	p := EC2VerifiedAccessGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessGroupPaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessGroup, error) {
	var response EC2VerifiedAccessGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessGroupFilters = map[string]string{
	"akas":                        "description.VerifiedAccountGroup.VerifiedAccessGroupArn",
	"arn":                         "description.VerifiedAccountGroup.VerifiedAccessGroupArn",
	"creation_time":               "description.VerifiedAccountGroup.CreationTime",
	"deletion_time":               "description.VerifiedAccountGroup.DeletionTime",
	"description":                 "description.VerifiedAccountGroup.Description",
	"kaytu_account_id":            "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountGroup.LastUpdatedTime",
	"owner":                       "description.VerifiedAccountGroup.Owner",
	"tags_src":                    "description.VerifiedAccountGroup.Tags",
	"verified_access_group_id":    "description.VerifiedAccountGroup.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountGroup.VerifiedAccessInstanceId",
}

func ListEC2VerifiedAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VerifiedAccessGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VerifiedAccessGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VerifiedAccessGroupFilters = map[string]string{
	"akas":                        "description.VerifiedAccountGroup.VerifiedAccessGroupArn",
	"arn":                         "description.VerifiedAccountGroup.VerifiedAccessGroupArn",
	"creation_time":               "description.VerifiedAccountGroup.CreationTime",
	"deletion_time":               "description.VerifiedAccountGroup.DeletionTime",
	"description":                 "description.VerifiedAccountGroup.Description",
	"kaytu_account_id":            "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountGroup.LastUpdatedTime",
	"owner":                       "description.VerifiedAccountGroup.Owner",
	"tags_src":                    "description.VerifiedAccountGroup.Tags",
	"verified_access_group_id":    "description.VerifiedAccountEndpoint.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountGroup.VerifiedAccessInstanceId",
}

func GetEC2VerifiedAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VerifiedAccessGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessGroup =============================

// ==========================  START: EC2VerifiedAccessTrustProvider =============================

type EC2VerifiedAccessTrustProvider struct {
	Description   aws.EC2VerifiedAccessTrustProviderDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type EC2VerifiedAccessTrustProviderHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  EC2VerifiedAccessTrustProvider `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type EC2VerifiedAccessTrustProviderHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []EC2VerifiedAccessTrustProviderHit `json:"hits"`
}

type EC2VerifiedAccessTrustProviderSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  EC2VerifiedAccessTrustProviderHits `json:"hits"`
}

type EC2VerifiedAccessTrustProviderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessTrustProviderPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessTrustProviderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccesstrustprovider", filters, limit)
	if err != nil {
		return EC2VerifiedAccessTrustProviderPaginator{}, err
	}

	p := EC2VerifiedAccessTrustProviderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessTrustProviderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessTrustProviderPaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessTrustProvider, error) {
	var response EC2VerifiedAccessTrustProviderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessTrustProvider
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessTrustProviderFilters = map[string]string{
	"creation_time":                     "description.VerifiedAccountGroup.CreationTime",
	"description":                       "description.VerifiedAccountGroup.Description",
	"device_trust_provider_type":        "description.VerifiedAccountGroup.DeviceTrustProviderType",
	"kaytu_account_id":                  "metadata.SourceID",
	"last_updated_time":                 "description.VerifiedAccountGroup.LastUpdatedTime",
	"oidc_options":                      "description.VerifiedAccountGroup.OidcOptions",
	"policy_reference_name":             "description.VerifiedAccountGroup.PolicyReferenceName",
	"tags":                              "description.VerifiedAccountGroup.Tags",
	"tags_src":                          "description.VerifiedAccountGroup.Tags",
	"trust_provider_type":               "description.VerifiedAccountGroup.TrustProviderType",
	"user_trust_provider_type":          "description.VerifiedAccountGroup.UserTrustProviderType",
	"verified_access_trust_provider_id": "description.VerifiedAccessTrustProvider.VerifiedAccessTrustProviderId",
}

func ListEC2VerifiedAccessTrustProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessTrustProvider")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VerifiedAccessTrustProviderPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VerifiedAccessTrustProviderFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VerifiedAccessTrustProviderFilters = map[string]string{
	"creation_time":                     "description.VerifiedAccountGroup.CreationTime",
	"description":                       "description.VerifiedAccountGroup.Description",
	"device_trust_provider_type":        "description.VerifiedAccountGroup.DeviceTrustProviderType",
	"kaytu_account_id":                  "metadata.SourceID",
	"last_updated_time":                 "description.VerifiedAccountGroup.LastUpdatedTime",
	"oidc_options":                      "description.VerifiedAccountGroup.OidcOptions",
	"policy_reference_name":             "description.VerifiedAccountGroup.PolicyReferenceName",
	"tags":                              "description.VerifiedAccountGroup.Tags",
	"tags_src":                          "description.VerifiedAccountGroup.Tags",
	"trust_provider_type":               "description.VerifiedAccountGroup.TrustProviderType",
	"user_trust_provider_type":          "description.VerifiedAccountGroup.UserTrustProviderType",
	"verified_access_trust_provider_id": "description.VerifiedAccountGroup.VerifiedAccessTrustProviderId",
}

func GetEC2VerifiedAccessTrustProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessTrustProvider")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessTrustProviderPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VerifiedAccessTrustProviderFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessTrustProvider =============================

// ==========================  START: EC2VPNGateway =============================

type EC2VPNGateway struct {
	Description   aws.EC2VPNGatewayDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2VPNGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2VPNGateway `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2VPNGatewayHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2VPNGatewayHit `json:"hits"`
}

type EC2VPNGatewaySearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2VPNGatewayHits `json:"hits"`
}

type EC2VPNGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPNGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPNGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpngateway", filters, limit)
	if err != nil {
		return EC2VPNGatewayPaginator{}, err
	}

	p := EC2VPNGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPNGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPNGatewayPaginator) NextPage(ctx context.Context) ([]EC2VPNGateway, error) {
	var response EC2VPNGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPNGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPNGatewayFilters = map[string]string{
	"akas":              "aRN",
	"amazon_side_asn":   "description.VPNGateway.AmazonSideAsn",
	"availability_zone": "description.VPNGateway.AvailabilityZone",
	"kaytu_account_id":  "metadata.SourceID",
	"state":             "description.VPNGateway.State",
	"tags_src":          "description.VPNGateway.Tags",
	"type":              "description.VPNGateway.Type",
	"vpc_attachments":   "description.VPNGateway.VpcAttachments",
	"vpn_gateway_id":    "description.VPNGateway.VpnGatewayId",
}

func ListEC2VPNGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPNGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VPNGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VPNGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VPNGatewayFilters = map[string]string{
	"akas":              "aRN",
	"amazon_side_asn":   "description.VPNGateway.AmazonSideAsn",
	"availability_zone": "description.VPNGateway.AvailabilityZone",
	"kaytu_account_id":  "metadata.SourceID",
	"state":             "description.VPNGateway.State",
	"tags_src":          "description.VPNGateway.Tags",
	"type":              "description.VPNGateway.Type",
	"vpc_attachments":   "description.VPNGateway.VpcAttachments",
	"vpn_gateway_id":    "description.VPNGateway.VpnGatewayId",
}

func GetEC2VPNGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPNGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VPNGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VPNGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VPNGateway =============================

// ==========================  START: EC2Volume =============================

type EC2Volume struct {
	Description   aws.EC2VolumeDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type EC2VolumeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Volume     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2VolumeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2VolumeHit    `json:"hits"`
}

type EC2VolumeSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  EC2VolumeHits `json:"hits"`
}

type EC2VolumePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VolumePaginator(filters []essdk.BoolFilter, limit *int64) (EC2VolumePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_volume", filters, limit)
	if err != nil {
		return EC2VolumePaginator{}, err
	}

	p := EC2VolumePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VolumePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VolumePaginator) NextPage(ctx context.Context) ([]EC2Volume, error) {
	var response EC2VolumeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Volume
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VolumeFilters = map[string]string{
	"attachments":          "description.Volume.Attachments",
	"auto_enable_io":       "description.Attributes.AutoEnableIO",
	"availability_zone":    "description.Volume.AvailabilityZone",
	"create_time":          "description.Volume.CreateTime",
	"encrypted":            "description.Volume.Encrypted",
	"fast_restored":        "description.Volume.FastRestored",
	"iops":                 "description.Volume.Iops",
	"kaytu_account_id":     "metadata.SourceID",
	"kms_key_id":           "description.Volume.KmsKeyId",
	"multi_attach_enabled": "description.Volume.MultiAttachEnabled",
	"outpost_arn":          "description.Volume.OutpostArn",
	"product_codes":        "description.Attributes.ProductCodes",
	"size":                 "description.Volume.Size",
	"snapshot_id":          "description.Volume.SnapshotId",
	"state":                "description.Volume.State",
	"tags_src":             "description.Volume.Tags",
	"volume_id":            "description.Volume.VolumeId",
	"volume_type":          "description.Volume.VolumeType",
}

func ListEC2Volume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Volume")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VolumePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VolumeFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VolumeFilters = map[string]string{
	"attachments":          "description.Volume.Attachments",
	"auto_enable_io":       "description.Attributes.AutoEnableIO",
	"availability_zone":    "description.Volume.AvailabilityZone",
	"create_time":          "description.Volume.CreateTime",
	"encrypted":            "description.Volume.Encrypted",
	"fast_restored":        "description.Volume.FastRestored",
	"iops":                 "description.Volume.Iops",
	"kaytu_account_id":     "metadata.SourceID",
	"kms_key_id":           "description.Volume.KmsKeyId",
	"multi_attach_enabled": "description.Volume.MultiAttachEnabled",
	"outpost_arn":          "description.Volume.OutpostArn",
	"product_codes":        "description.Attributes.ProductCodes",
	"size":                 "description.Volume.Size",
	"snapshot_id":          "description.Volume.SnapshotId",
	"state":                "description.Volume.State",
	"tags_src":             "description.Volume.Tags",
	"volume_id":            "description.Volume.VolumeId",
	"volume_type":          "description.Volume.VolumeType",
}

func GetEC2Volume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Volume")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VolumePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VolumeFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Volume =============================

// ==========================  START: EC2Instance =============================

type EC2Instance struct {
	Description   aws.EC2InstanceDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type EC2InstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Instance   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2InstanceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2InstanceHit  `json:"hits"`
}

type EC2InstanceSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  EC2InstanceHits `json:"hits"`
}

type EC2InstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InstancePaginator(filters []essdk.BoolFilter, limit *int64) (EC2InstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_instance", filters, limit)
	if err != nil {
		return EC2InstancePaginator{}, err
	}

	p := EC2InstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InstancePaginator) NextPage(ctx context.Context) ([]EC2Instance, error) {
	var response EC2InstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Instance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InstanceFilters = map[string]string{
	"ami_launch_index":                           "description.Instance.AmiLaunchIndex",
	"architecture":                               "description.Instance.Architecture",
	"block_device_mappings":                      "description.Instance.BlockDeviceMappings",
	"boot_mode":                                  "description.Instance.BootMode",
	"capacity_reservation_id":                    "description.Instance.CapacityReservationId",
	"capacity_reservation_specification":         "description.Instance.CapacityReservationSpecification",
	"client_token":                               "description.Instance.ClientToken",
	"cpu_options_core_count":                     "description.Instance.CpuOptions.CoreCount",
	"cpu_options_threads_per_core":               "description.Instance.CpuOptions.ThreadsPerCore",
	"disable_api_termination":                    "description.Attributes.DisableApiTermination",
	"ebs_optimized":                              "description.Instance.EbsOptimized",
	"elastic_gpu_associations":                   "description.Instance.ElasticGpuAssociations",
	"elastic_inference_accelerator_associations": "description.Instance.ElasticInferenceAcceleratorAssociations",
	"ena_support":                                "description.Instance.EnaSupport",
	"enclave_options":                            "description.Instance.EnclaveOptions",
	"hibernation_options":                        "description.Instance.HibernationOptions",
	"hypervisor":                                 "description.Instance.Hypervisor",
	"iam_instance_profile_arn":                   "description.Instance.IamInstanceProfile.Arn",
	"iam_instance_profile_id":                    "description.Instance.IamInstanceProfile.Id",
	"image_id":                                   "description.Instance.ImageId",
	"instance_id":                                "description.Instance.InstanceId",
	"instance_initiated_shutdown_behavior":       "description.Attributes.InstanceInitiatedShutdownBehavior",
	"instance_lifecycle":                         "description.Instance.InstanceLifecycle",
	"instance_state":                             "description.Instance.State.Name",
	"instance_status":                            "description.Attributes.InstanceStatus",
	"instance_type":                              "description.Instance.InstanceType",
	"kaytu_account_id":                           "metadata.SourceID",
	"kernel_id":                                  "description.Instance.KernelId",
	"key_name":                                   "description.Instance.KeyName",
	"launch_time":                                "description.Instance.LaunchTime",
	"metadata_options":                           "description.Instance.MetadataOptions",
	"monitoring_state":                           "description.Instance.Monitoring.State",
	"network_interfaces":                         "description.Instance.NetworkInterfaces",
	"outpost_arn":                                "description.Instance.OutpostArn",
	"placement_availability_zone":                "description.Instance.Placement.AvailabilityZone",
	"placement_group_name":                       "description.Instance.Placement.GroupName",
	"placement_tenancy":                          "description.Instance.Placement.Tenancy",
	"platform":                                   "description.Instance.Platform",
	"platform_details":                           "description.Instance.PlatformDetails",
	"private_dns_name":                           "description.Instance.PrivateDnsName",
	"private_dns_name_options":                   "description.Instance.PrivateDnsNameOptions",
	"private_ip_address":                         "description.Instance.PrivateIpAddress",
	"product_codes":                              "description.Instance.ProductCodes",
	"public_dns_name":                            "description.Instance.PublicDnsName",
	"public_ip_address":                          "description.Instance.PublicIpAddress",
	"ram_disk_id":                                "description.Instance.RamdiskId",
	"root_device_name":                           "description.Instance.RootDeviceName",
	"root_device_type":                           "description.Instance.RootDeviceType",
	"security_groups":                            "description.Instance.SecurityGroups",
	"source_dest_check":                          "description.Instance.SourceDestCheck",
	"sriov_net_support":                          "description.Instance.SriovNetSupport",
	"state_code":                                 "description.Instance.State.Code",
	"state_transition_reason":                    "description.Instance.StateTransitionReason",
	"subnet_id":                                  "description.Instance.SubnetId",
	"tags_src":                                   "description.Instance.Tags",
	"tpm_support":                                "description.Instance.TpmSupport",
	"usage_operation":                            "description.Instance.UsageOperation",
	"usage_operation_update_time":                "description.Instance.UsageOperationUpdateTime",
	"user_data":                                  "description.Attributes.UserData",
	"virtualization_type":                        "description.Instance.VirtualizationType",
	"vpc_id":                                     "description.Instance.VpcId",
}

func ListEC2Instance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Instance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2InstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2InstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2InstanceFilters = map[string]string{
	"ami_launch_index":                           "description.Instance.AmiLaunchIndex",
	"architecture":                               "description.Instance.Architecture",
	"block_device_mappings":                      "description.Instance.BlockDeviceMappings",
	"boot_mode":                                  "description.Instance.BootMode",
	"capacity_reservation_id":                    "description.Instance.CapacityReservationId",
	"capacity_reservation_specification":         "description.Instance.CapacityReservationSpecification",
	"client_token":                               "description.Instance.ClientToken",
	"cpu_options_core_count":                     "description.Instance.CpuOptions.CoreCount",
	"cpu_options_threads_per_core":               "description.Instance.CpuOptions.ThreadsPerCore",
	"disable_api_termination":                    "description.Attributes.DisableApiTermination",
	"ebs_optimized":                              "description.Instance.EbsOptimized",
	"elastic_gpu_associations":                   "description.Instance.ElasticGpuAssociations",
	"elastic_inference_accelerator_associations": "description.Instance.ElasticInferenceAcceleratorAssociations",
	"ena_support":                                "description.Instance.EnaSupport",
	"enclave_options":                            "description.Instance.EnclaveOptions",
	"hibernation_options":                        "description.Instance.HibernationOptions",
	"hypervisor":                                 "description.Instance.Hypervisor",
	"iam_instance_profile_arn":                   "description.Instance.IamInstanceProfile.Arn",
	"iam_instance_profile_id":                    "description.Instance.IamInstanceProfile.Id",
	"image_id":                                   "description.Instance.ImageId",
	"instance_id":                                "description.Instance.InstanceId",
	"instance_initiated_shutdown_behavior":       "description.Attributes.InstanceInitiatedShutdownBehavior",
	"instance_lifecycle":                         "description.Instance.InstanceLifecycle",
	"instance_state":                             "description.Instance.State.Name",
	"instance_status":                            "description.Attributes.InstanceStatus",
	"instance_type":                              "description.Instance.InstanceType",
	"kaytu_account_id":                           "metadata.SourceID",
	"kernel_id":                                  "description.Instance.KernelId",
	"key_name":                                   "description.Instance.KeyName",
	"launch_time":                                "description.Instance.LaunchTime",
	"metadata_options":                           "description.Instance.MetadataOptions",
	"monitoring_state":                           "description.Instance.Monitoring.State",
	"network_interfaces":                         "description.Instance.NetworkInterfaces",
	"outpost_arn":                                "description.Instance.OutpostArn",
	"placement_availability_zone":                "description.Instance.Placement.AvailabilityZone",
	"placement_group_name":                       "description.Instance.Placement.GroupName",
	"placement_tenancy":                          "description.Instance.Placement.Tenancy",
	"platform":                                   "description.Instance.Platform",
	"platform_details":                           "description.Instance.PlatformDetails",
	"private_dns_name":                           "description.Instance.PrivateDnsName",
	"private_dns_name_options":                   "description.Instance.PrivateDnsNameOptions",
	"private_ip_address":                         "description.Instance.PrivateIpAddress",
	"product_codes":                              "description.Instance.ProductCodes",
	"public_dns_name":                            "description.Instance.PublicDnsName",
	"public_ip_address":                          "description.Instance.PublicIpAddress",
	"ram_disk_id":                                "description.Instance.RamdiskId",
	"root_device_name":                           "description.Instance.RootDeviceName",
	"root_device_type":                           "description.Instance.RootDeviceType",
	"security_groups":                            "description.Instance.SecurityGroups",
	"source_dest_check":                          "description.Instance.SourceDestCheck",
	"sriov_net_support":                          "description.Instance.SriovNetSupport",
	"state_code":                                 "description.Instance.State.Code",
	"state_transition_reason":                    "description.Instance.StateTransitionReason",
	"subnet_id":                                  "description.Instance.SubnetId",
	"tags_src":                                   "description.Instance.Tags",
	"tpm_support":                                "description.Instance.TpmSupport",
	"usage_operation":                            "description.Instance.UsageOperation",
	"usage_operation_update_time":                "description.Instance.UsageOperationUpdateTime",
	"user_data":                                  "description.Attributes.UserData",
	"virtualization_type":                        "description.Instance.VirtualizationType",
	"vpc_id":                                     "description.Instance.VpcId",
}

func GetEC2Instance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Instance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2InstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2InstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Instance =============================

// ==========================  START: EC2Vpc =============================

type EC2Vpc struct {
	Description   aws.EC2VpcDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type EC2VpcHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Vpc        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2VpcHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2VpcHit       `json:"hits"`
}

type EC2VpcSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  EC2VpcHits `json:"hits"`
}

type EC2VpcPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VpcPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VpcPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpc", filters, limit)
	if err != nil {
		return EC2VpcPaginator{}, err
	}

	p := EC2VpcPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VpcPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VpcPaginator) NextPage(ctx context.Context) ([]EC2Vpc, error) {
	var response EC2VpcSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Vpc
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VpcFilters = map[string]string{
	"cidr_block":                      "description.Vpc.CidrBlock",
	"cidr_block_association_set":      "description.Vpc.CidrBlockAssociationSet",
	"dhcp_options_id":                 "description.Vpc.DhcpOptionsId",
	"instance_tenancy":                "description.Vpc.InstanceTenancy",
	"ipv6_cidr_block_association_set": "description.Vpc.Ipv6CidrBlockAssociationSet",
	"is_default":                      "description.Vpc.IsDefault",
	"kaytu_account_id":                "metadata.SourceID",
	"owner_id":                        "description.Vpc.OwnerId",
	"state":                           "description.Vpc.State",
	"tags_src":                        "description.Vpc.Tags",
	"vpc_id":                          "description.Vpc.VpcId",
}

func ListEC2Vpc(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Vpc")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VpcPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VpcFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VpcFilters = map[string]string{
	"cidr_block":                      "description.Vpc.CidrBlock",
	"cidr_block_association_set":      "description.Vpc.CidrBlockAssociationSet",
	"dhcp_options_id":                 "description.Vpc.DhcpOptionsId",
	"instance_tenancy":                "description.Vpc.InstanceTenancy",
	"ipv6_cidr_block_association_set": "description.Vpc.Ipv6CidrBlockAssociationSet",
	"is_default":                      "description.Vpc.IsDefault",
	"kaytu_account_id":                "metadata.SourceID",
	"owner_id":                        "description.Vpc.OwnerId",
	"state":                           "description.Vpc.State",
	"tags_src":                        "description.Vpc.Tags",
	"vpc_id":                          "description.Vpc.VpcId",
}

func GetEC2Vpc(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Vpc")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VpcPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VpcFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Vpc =============================

// ==========================  START: EC2NetworkInterface =============================

type EC2NetworkInterface struct {
	Description   aws.EC2NetworkInterfaceDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type EC2NetworkInterfaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  EC2NetworkInterface `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type EC2NetworkInterfaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []EC2NetworkInterfaceHit `json:"hits"`
}

type EC2NetworkInterfaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  EC2NetworkInterfaceHits `json:"hits"`
}

type EC2NetworkInterfacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2NetworkInterfacePaginator(filters []essdk.BoolFilter, limit *int64) (EC2NetworkInterfacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_networkinterface", filters, limit)
	if err != nil {
		return EC2NetworkInterfacePaginator{}, err
	}

	p := EC2NetworkInterfacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2NetworkInterfacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2NetworkInterfacePaginator) NextPage(ctx context.Context) ([]EC2NetworkInterface, error) {
	var response EC2NetworkInterfaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2NetworkInterface
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2NetworkInterfaceFilters = map[string]string{
	"association_allocation_id":      "description.NetworkInterface.Association.AllocationId",
	"association_carrier_ip":         "description.NetworkInterface.Association.CarrierIp",
	"association_customer_owned_ip":  "description.NetworkInterface.Association.CustomerOwnedIp",
	"association_id":                 "description.NetworkInterface.Association.AssociationId",
	"association_ip_owner_id":        "description.NetworkInterface.Association.IpOwnerId",
	"association_public_dns_name":    "description.NetworkInterface.Association.PublicDnsName",
	"association_public_ip":          "description.NetworkInterface.Association.PublicIp",
	"attached_instance_id":           "description.NetworkInterface.Attachment.InstanceId",
	"attached_instance_owner_id":     "description.NetworkInterface.Attachment.InstanceOwnerId",
	"attachment_id":                  "description.NetworkInterface.Attachment.AttachmentId",
	"attachment_status":              "description.NetworkInterface.Attachment.Status",
	"attachment_time":                "description.NetworkInterface.Attachment.AttachTime",
	"availability_zone":              "description.NetworkInterface.AvailabilityZone",
	"delete_on_instance_termination": "description.NetworkInterface.Attachment.DeleteOnTermination",
	"description":                    "description.NetworkInterface.Description",
	"device_index":                   "description.NetworkInterface.Attachment.DeviceIndex",
	"groups":                         "description.NetworkInterface.Groups",
	"interface_type":                 "description.NetworkInterface.InterfaceType",
	"ipv6_addresses":                 "description.NetworkInterface.Ipv6Addresses",
	"kaytu_account_id":               "metadata.SourceID",
	"mac_address":                    "description.NetworkInterface.MacAddress",
	"network_interface_id":           "description.NetworkInterface.NetworkInterfaceId",
	"outpost_arn":                    "description.NetworkInterface.OutpostArn",
	"owner_id":                       "description.NetworkInterface.OwnerId",
	"private_dns_name":               "description.NetworkInterface.PrivateDnsName",
	"private_ip_address":             "description.NetworkInterface.PrivateIpAddress",
	"private_ip_addresses":           "description.NetworkInterface.PrivateIpAddresses",
	"requester_id":                   "description.NetworkInterface.RequesterId",
	"requester_managed":              "description.NetworkInterface.RequesterManaged",
	"source_dest_check":              "description.NetworkInterface.SourceDestCheck",
	"status":                         "description.NetworkInterface.Status",
	"subnet_id":                      "description.NetworkInterface.SubnetId",
	"tags_src":                       "description.NetworkInterface.TagSet",
	"title":                          "description.NetworkInterface.NetworkInterfaceId",
	"vpc_id":                         "description.NetworkInterface.VpcId",
}

func ListEC2NetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2NetworkInterface")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2NetworkInterfacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2NetworkInterfaceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2NetworkInterfaceFilters = map[string]string{
	"association_allocation_id":      "description.NetworkInterface.Association.AllocationId",
	"association_carrier_ip":         "description.NetworkInterface.Association.CarrierIp",
	"association_customer_owned_ip":  "description.NetworkInterface.Association.CustomerOwnedIp",
	"association_id":                 "description.NetworkInterface.Association.AssociationId",
	"association_ip_owner_id":        "description.NetworkInterface.Association.IpOwnerId",
	"association_public_dns_name":    "description.NetworkInterface.Association.PublicDnsName",
	"association_public_ip":          "description.NetworkInterface.Association.PublicIp",
	"attached_instance_id":           "description.NetworkInterface.Attachment.InstanceId",
	"attached_instance_owner_id":     "description.NetworkInterface.Attachment.InstanceOwnerId",
	"attachment_id":                  "description.NetworkInterface.Attachment.AttachmentId",
	"attachment_status":              "description.NetworkInterface.Attachment.Status",
	"attachment_time":                "description.NetworkInterface.Attachment.AttachTime",
	"availability_zone":              "description.NetworkInterface.AvailabilityZone",
	"delete_on_instance_termination": "description.NetworkInterface.Attachment.DeleteOnTermination",
	"description":                    "description.NetworkInterface.Description",
	"device_index":                   "description.NetworkInterface.Attachment.DeviceIndex",
	"groups":                         "description.NetworkInterface.Groups",
	"interface_type":                 "description.NetworkInterface.InterfaceType",
	"ipv6_addresses":                 "description.NetworkInterface.Ipv6Addresses",
	"kaytu_account_id":               "metadata.SourceID",
	"mac_address":                    "description.NetworkInterface.MacAddress",
	"network_interface_id":           "description.NetworkInterface.NetworkInterfaceId",
	"outpost_arn":                    "description.NetworkInterface.OutpostArn",
	"owner_id":                       "description.NetworkInterface.OwnerId",
	"private_dns_name":               "description.NetworkInterface.PrivateDnsName",
	"private_ip_address":             "description.NetworkInterface.PrivateIpAddress",
	"private_ip_addresses":           "description.NetworkInterface.PrivateIpAddresses",
	"requester_id":                   "description.NetworkInterface.RequesterId",
	"requester_managed":              "description.NetworkInterface.RequesterManaged",
	"source_dest_check":              "description.NetworkInterface.SourceDestCheck",
	"status":                         "description.NetworkInterface.Status",
	"subnet_id":                      "description.NetworkInterface.SubnetId",
	"tags_src":                       "description.NetworkInterface.TagSet",
	"title":                          "description.NetworkInterface.NetworkInterfaceId",
	"vpc_id":                         "description.NetworkInterface.VpcId",
}

func GetEC2NetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2NetworkInterface")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2NetworkInterfacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2NetworkInterfaceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2NetworkInterface =============================

// ==========================  START: EC2RegionalSettings =============================

type EC2RegionalSettings struct {
	Description   aws.EC2RegionalSettingsDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type EC2RegionalSettingsHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  EC2RegionalSettings `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type EC2RegionalSettingsHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []EC2RegionalSettingsHit `json:"hits"`
}

type EC2RegionalSettingsSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  EC2RegionalSettingsHits `json:"hits"`
}

type EC2RegionalSettingsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2RegionalSettingsPaginator(filters []essdk.BoolFilter, limit *int64) (EC2RegionalSettingsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_regionalsettings", filters, limit)
	if err != nil {
		return EC2RegionalSettingsPaginator{}, err
	}

	p := EC2RegionalSettingsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2RegionalSettingsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2RegionalSettingsPaginator) NextPage(ctx context.Context) ([]EC2RegionalSettings, error) {
	var response EC2RegionalSettingsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2RegionalSettings
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2RegionalSettingsFilters = map[string]string{
	"default_ebs_encryption_enabled": "description.EbsEncryptionByDefault",
	"default_ebs_encryption_key":     "description.KmsKeyId",
	"kaytu_account_id":               "metadata.SourceID",
}

func ListEC2RegionalSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2RegionalSettings")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2RegionalSettingsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2RegionalSettingsFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2RegionalSettingsFilters = map[string]string{
	"default_ebs_encryption_enabled": "description.EbsEncryptionByDefault",
	"default_ebs_encryption_key":     "description.KmsKeyId",
	"kaytu_account_id":               "metadata.SourceID",
}

func GetEC2RegionalSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2RegionalSettings")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2RegionalSettingsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2RegionalSettingsFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2RegionalSettings =============================

// ==========================  START: EC2Subnet =============================

type EC2Subnet struct {
	Description   aws.EC2SubnetDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type EC2SubnetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Subnet     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2SubnetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2SubnetHit    `json:"hits"`
}

type EC2SubnetSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  EC2SubnetHits `json:"hits"`
}

type EC2SubnetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2SubnetPaginator(filters []essdk.BoolFilter, limit *int64) (EC2SubnetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_subnet", filters, limit)
	if err != nil {
		return EC2SubnetPaginator{}, err
	}

	p := EC2SubnetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2SubnetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2SubnetPaginator) NextPage(ctx context.Context) ([]EC2Subnet, error) {
	var response EC2SubnetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Subnet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2SubnetFilters = map[string]string{
	"akas":                            "subnetArn",
	"assign_ipv6_address_on_creation": "description.Subnet.AssignIpv6AddressOnCreation",
	"availability_zone":               "description.Subnet.AvailabilityZone",
	"availability_zone_id":            "description.Subnet.AvailabilityZoneId",
	"available_ip_address_count":      "description.Subnet.AvailableIpAddressCount",
	"cidr_block":                      "description.Subnet.CidrBlock",
	"customer_owned_ipv4_pool":        "description.Subnet.CustomerOwnedIpv4Pool",
	"default_for_az":                  "description.Subnet.DefaultForAz",
	"ipv6_cidr_block_association_set": "description.Subnet.Ipv6CidrBlockAssociationSet",
	"kaytu_account_id":                "metadata.SourceID",
	"map_customer_owned_ip_on_launch": "description.Subnet.MapCustomerOwnedIpOnLaunch",
	"map_public_ip_on_launch":         "description.Subnet.MapPublicIpOnLaunch",
	"outpost_arn":                     "description.Subnet.OutpostArn",
	"owner_id":                        "description.Subnet.OwnerId",
	"state":                           "description.Subnet.State",
	"subnet_arn":                      "description.Subnet.SubnetArn",
	"subnet_id":                       "description.Subnet.SubnetId",
	"tags_src":                        "description.Subnet.Tags",
	"vpc_id":                          "description.Subnet.VpcId",
}

func ListEC2Subnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Subnet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2SubnetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2SubnetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2SubnetFilters = map[string]string{
	"akas":                            "subnetArn",
	"assign_ipv6_address_on_creation": "description.Subnet.AssignIpv6AddressOnCreation",
	"availability_zone":               "description.Subnet.AvailabilityZone",
	"availability_zone_id":            "description.Subnet.AvailabilityZoneId",
	"available_ip_address_count":      "description.Subnet.AvailableIpAddressCount",
	"cidr_block":                      "description.Subnet.CidrBlock",
	"customer_owned_ipv4_pool":        "description.Subnet.CustomerOwnedIpv4Pool",
	"default_for_az":                  "description.Subnet.DefaultForAz",
	"ipv6_cidr_block_association_set": "description.Subnet.Ipv6CidrBlockAssociationSet",
	"kaytu_account_id":                "metadata.SourceID",
	"map_customer_owned_ip_on_launch": "description.Subnet.MapCustomerOwnedIpOnLaunch",
	"map_public_ip_on_launch":         "description.Subnet.MapPublicIpOnLaunch",
	"outpost_arn":                     "description.Subnet.OutpostArn",
	"owner_id":                        "description.Subnet.OwnerId",
	"state":                           "description.Subnet.State",
	"subnet_arn":                      "description.Subnet.SubnetArn",
	"subnet_id":                       "description.Subnet.SubnetId",
	"tags_src":                        "description.Subnet.Tags",
	"vpc_id":                          "description.Subnet.VpcId",
}

func GetEC2Subnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Subnet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2SubnetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2SubnetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Subnet =============================

// ==========================  START: EC2VPCEndpoint =============================

type EC2VPCEndpoint struct {
	Description   aws.EC2VPCEndpointDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EC2VPCEndpointHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EC2VPCEndpoint `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EC2VPCEndpointHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EC2VPCEndpointHit `json:"hits"`
}

type EC2VPCEndpointSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EC2VPCEndpointHits `json:"hits"`
}

type EC2VPCEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPCEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPCEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpcendpoint", filters, limit)
	if err != nil {
		return EC2VPCEndpointPaginator{}, err
	}

	p := EC2VPCEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPCEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPCEndpointPaginator) NextPage(ctx context.Context) ([]EC2VPCEndpoint, error) {
	var response EC2VPCEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPCEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPCEndpointFilters = map[string]string{
	"creation_timestamp":    "description.VpcEndpoint.CreationTimestamp",
	"dns_entries":           "description.VpcEndpoint.DnsEntries",
	"groups":                "description.VpcEndpoint.Groups",
	"kaytu_account_id":      "metadata.SourceID",
	"network_interface_ids": "description.VpcEndpoint.NetworkInterfaceIds",
	"owner_id":              "description.VpcEndpoint.OwnerId",
	"policy":                "description.VpcEndpoint.PolicyDocument",
	"policy_std":            "description.VpcEndpoint.PolicyDocument",
	"private_dns_enabled":   "description.VpcEndpoint.PrivateDnsEnabled",
	"requester_managed":     "description.VpcEndpoint.RequesterManaged",
	"route_table_ids":       "description.VpcEndpoint.RouteTableIds",
	"service_name":          "description.VpcEndpoint.ServiceName",
	"state":                 "description.VpcEndpoint.State",
	"subnet_ids":            "description.VpcEndpoint.SubnetIds",
	"tags_src":              "description.VpcEndpoint.Tags",
	"vpc_endpoint_id":       "description.VpcEndpoint.VpcEndpointId",
	"vpc_id":                "description.VpcEndpoint.VpcId",
}

func ListEC2VPCEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPCEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VPCEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VPCEndpointFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VPCEndpointFilters = map[string]string{
	"creation_timestamp":    "description.VpcEndpoint.CreationTimestamp",
	"dns_entries":           "description.VpcEndpoint.DnsEntries",
	"groups":                "description.VpcEndpoint.Groups",
	"kaytu_account_id":      "metadata.SourceID",
	"network_interface_ids": "description.VpcEndpoint.NetworkInterfaceIds",
	"owner_id":              "description.VpcEndpoint.OwnerId",
	"policy":                "description.VpcEndpoint.PolicyDocument",
	"policy_std":            "description.VpcEndpoint.PolicyDocument",
	"private_dns_enabled":   "description.VpcEndpoint.PrivateDnsEnabled",
	"requester_managed":     "description.VpcEndpoint.RequesterManaged",
	"route_table_ids":       "description.VpcEndpoint.RouteTableIds",
	"service_name":          "description.VpcEndpoint.ServiceName",
	"state":                 "description.VpcEndpoint.State",
	"subnet_ids":            "description.VpcEndpoint.SubnetIds",
	"tags_src":              "description.VpcEndpoint.Tags",
	"vpc_endpoint_id":       "description.VpcEndpoint.VpcEndpointId",
	"vpc_id":                "description.VpcEndpoint.VpcId",
}

func GetEC2VPCEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPCEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VPCEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VPCEndpointFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VPCEndpoint =============================

// ==========================  START: EC2SecurityGroup =============================

type EC2SecurityGroup struct {
	Description   aws.EC2SecurityGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EC2SecurityGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EC2SecurityGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EC2SecurityGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EC2SecurityGroupHit `json:"hits"`
}

type EC2SecurityGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EC2SecurityGroupHits `json:"hits"`
}

type EC2SecurityGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2SecurityGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EC2SecurityGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_securitygroup", filters, limit)
	if err != nil {
		return EC2SecurityGroupPaginator{}, err
	}

	p := EC2SecurityGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2SecurityGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2SecurityGroupPaginator) NextPage(ctx context.Context) ([]EC2SecurityGroup, error) {
	var response EC2SecurityGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2SecurityGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2SecurityGroupFilters = map[string]string{
	"description":           "description.SecurityGroup.Description",
	"group_id":              "description.SecurityGroup.GroupId",
	"group_name":            "description.SecurityGroup.GroupName",
	"ip_permissions":        "description.SecurityGroup.IpPermissions",
	"ip_permissions_egress": "description.SecurityGroup.IpPermissionsEgress",
	"kaytu_account_id":      "metadata.SourceID",
	"owner_id":              "description.SecurityGroup.OwnerId",
	"tags_src":              "description.SecurityGroup.Tags",
	"title":                 "groupName",
	"vpc_id":                "description.SecurityGroup.VpcId",
}

func ListEC2SecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2SecurityGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2SecurityGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2SecurityGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2SecurityGroupFilters = map[string]string{
	"description":           "description.SecurityGroup.Description",
	"group_id":              "description.SecurityGroup.GroupId",
	"group_name":            "description.SecurityGroup.GroupName",
	"ip_permissions":        "description.SecurityGroup.IpPermissions",
	"ip_permissions_egress": "description.SecurityGroup.IpPermissionsEgress",
	"kaytu_account_id":      "metadata.SourceID",
	"owner_id":              "description.SecurityGroup.OwnerId",
	"tags_src":              "description.SecurityGroup.Tags",
	"title":                 "groupName",
	"vpc_id":                "description.SecurityGroup.VpcId",
}

func GetEC2SecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2SecurityGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2SecurityGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2SecurityGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2SecurityGroup =============================

// ==========================  START: EC2EIP =============================

type EC2EIP struct {
	Description   aws.EC2EIPDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type EC2EIPHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2EIP        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2EIPHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2EIPHit       `json:"hits"`
}

type EC2EIPSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  EC2EIPHits `json:"hits"`
}

type EC2EIPPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2EIPPaginator(filters []essdk.BoolFilter, limit *int64) (EC2EIPPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_eip", filters, limit)
	if err != nil {
		return EC2EIPPaginator{}, err
	}

	p := EC2EIPPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2EIPPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2EIPPaginator) NextPage(ctx context.Context) ([]EC2EIP, error) {
	var response EC2EIPSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2EIP
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2EIPFilters = map[string]string{
	"allocation_id":              "description.Address.AllocationId",
	"association_id":             "description.Address.AssociationId",
	"carrier_ip":                 "description.Address.CarrierIp",
	"customer_owned_ip":          "description.Address.CustomerOwnedIp",
	"customer_owned_ipv4_pool":   "description.Address.CustomerOwnedIpv4Pool",
	"domain":                     "description.Address.Domain",
	"instance_id":                "description.Address.InstanceId",
	"kaytu_account_id":           "metadata.SourceID",
	"network_border_group":       "description.Address.NetworkBorderGroup",
	"network_interface_id":       "description.Address.NetworkInterfaceId",
	"network_interface_owner_id": "description.Address.NetworkInterfaceOwnerId",
	"private_ip_address":         "description.Address.PrivateIpAddress",
	"public_ip":                  "description.Address.PublicIp",
	"public_ipv4_pool":           "description.Address.PublicIpv4Pool",
	"tags_src":                   "description.Address.Tags",
	"title":                      "allocationId",
}

func ListEC2EIP(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2EIP")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2EIPPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2EIPFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2EIPFilters = map[string]string{
	"allocation_id":              "description.SecurityGroup.AllocationId",
	"association_id":             "description.Address.AssociationId",
	"carrier_ip":                 "description.Address.CarrierIp",
	"customer_owned_ip":          "description.Address.CustomerOwnedIp",
	"customer_owned_ipv4_pool":   "description.Address.CustomerOwnedIpv4Pool",
	"domain":                     "description.Address.Domain",
	"instance_id":                "description.Address.InstanceId",
	"kaytu_account_id":           "metadata.SourceID",
	"network_border_group":       "description.Address.NetworkBorderGroup",
	"network_interface_id":       "description.Address.NetworkInterfaceId",
	"network_interface_owner_id": "description.Address.NetworkInterfaceOwnerId",
	"private_ip_address":         "description.Address.PrivateIpAddress",
	"public_ip":                  "description.Address.PublicIp",
	"public_ipv4_pool":           "description.Address.PublicIpv4Pool",
	"tags_src":                   "description.Address.Tags",
	"title":                      "allocationId",
}

func GetEC2EIP(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2EIP")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2EIPPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2EIPFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2EIP =============================

// ==========================  START: EC2InternetGateway =============================

type EC2InternetGateway struct {
	Description   aws.EC2InternetGatewayDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type EC2InternetGatewayHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  EC2InternetGateway `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type EC2InternetGatewayHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []EC2InternetGatewayHit `json:"hits"`
}

type EC2InternetGatewaySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  EC2InternetGatewayHits `json:"hits"`
}

type EC2InternetGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InternetGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2InternetGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_internetgateway", filters, limit)
	if err != nil {
		return EC2InternetGatewayPaginator{}, err
	}

	p := EC2InternetGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InternetGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InternetGatewayPaginator) NextPage(ctx context.Context) ([]EC2InternetGateway, error) {
	var response EC2InternetGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2InternetGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InternetGatewayFilters = map[string]string{
	"attachments":         "description.InternetGateway.Attachments",
	"internet_gateway_id": "description.InternetGateway.InternetGatewayId",
	"kaytu_account_id":    "metadata.SourceID",
	"owner_id":            "description.InternetGateway.OwnerId",
	"tags_src":            "description.InternetGateway.Tags",
}

func ListEC2InternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2InternetGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2InternetGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2InternetGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2InternetGatewayFilters = map[string]string{
	"attachments":         "description.InternetGateway.Attachments",
	"internet_gateway_id": "description.InternetGateway.InternetGatewayId",
	"kaytu_account_id":    "metadata.SourceID",
	"owner_id":            "description.InternetGateway.OwnerId",
	"tags_src":            "description.InternetGateway.Tags",
}

func GetEC2InternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2InternetGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2InternetGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2InternetGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2InternetGateway =============================

// ==========================  START: EC2NetworkAcl =============================

type EC2NetworkAcl struct {
	Description   aws.EC2NetworkAclDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2NetworkAclHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2NetworkAcl `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2NetworkAclHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2NetworkAclHit `json:"hits"`
}

type EC2NetworkAclSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2NetworkAclHits `json:"hits"`
}

type EC2NetworkAclPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2NetworkAclPaginator(filters []essdk.BoolFilter, limit *int64) (EC2NetworkAclPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_networkacl", filters, limit)
	if err != nil {
		return EC2NetworkAclPaginator{}, err
	}

	p := EC2NetworkAclPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2NetworkAclPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2NetworkAclPaginator) NextPage(ctx context.Context) ([]EC2NetworkAcl, error) {
	var response EC2NetworkAclSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2NetworkAcl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2NetworkAclFilters = map[string]string{
	"associations":     "description.NetworkAcl.Associations",
	"entries":          "description.NetworkAcl.Entries",
	"is_default":       "description.NetworkAcl.IsDefault",
	"kaytu_account_id": "metadata.SourceID",
	"network_acl_id":   "description.NetworkAcl.NetworkAclId",
	"owner_id":         "description.NetworkAcl.OwnerId",
	"tags_src":         "description.NetworkAcl.Tags",
	"vpc_id":           "description.NetworkAcl.VpcId",
}

func ListEC2NetworkAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2NetworkAcl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2NetworkAclPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2NetworkAclFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2NetworkAclFilters = map[string]string{
	"associations":     "description.NetworkAcl.Associations",
	"entries":          "description.NetworkAcl.Entries",
	"is_default":       "description.NetworkAcl.IsDefault",
	"kaytu_account_id": "metadata.SourceID",
	"network_acl_id":   "description.NetworkAcl.NetworkAclId",
	"owner_id":         "description.NetworkAcl.OwnerId",
	"tags_src":         "description.NetworkAcl.Tags",
	"vpc_id":           "description.NetworkAcl.VpcId",
}

func GetEC2NetworkAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2NetworkAcl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2NetworkAclPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2NetworkAclFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2NetworkAcl =============================

// ==========================  START: EC2VPNConnection =============================

type EC2VPNConnection struct {
	Description   aws.EC2VPNConnectionDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EC2VPNConnectionHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EC2VPNConnection `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EC2VPNConnectionHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EC2VPNConnectionHit `json:"hits"`
}

type EC2VPNConnectionSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EC2VPNConnectionHits `json:"hits"`
}

type EC2VPNConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPNConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPNConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpnconnection", filters, limit)
	if err != nil {
		return EC2VPNConnectionPaginator{}, err
	}

	p := EC2VPNConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPNConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPNConnectionPaginator) NextPage(ctx context.Context) ([]EC2VPNConnection, error) {
	var response EC2VPNConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPNConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPNConnectionFilters = map[string]string{
	"category":                       "description.VpnConnection.Category",
	"customer_gateway_configuration": "description.VpnConnection.CustomerGatewayConfiguration",
	"customer_gateway_id":            "description.VpnConnection.CustomerGatewayId",
	"kaytu_account_id":               "metadata.SourceID",
	"options":                        "description.VpnConnection.Options",
	"routes":                         "description.VpnConnection.Routes",
	"state":                          "description.VpnConnection.State",
	"tags_src":                       "description.VpnConnection.Tags",
	"transit_gateway_id":             "description.VpnConnection.TransitGatewayId",
	"type":                           "description.VpnConnection.Type",
	"vgw_telemetry":                  "description.VpnConnection.VgwTelemetry",
	"vpn_connection_id":              "description.VpnConnection.VpnConnectionId",
	"vpn_gateway_id":                 "description.VpnConnection.VpnGatewayId",
}

func ListEC2VPNConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPNConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VPNConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VPNConnectionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VPNConnectionFilters = map[string]string{
	"category":                       "description.VpnConnection.Category",
	"customer_gateway_configuration": "description.VpnConnection.CustomerGatewayConfiguration",
	"customer_gateway_id":            "description.VpnConnection.CustomerGatewayId",
	"kaytu_account_id":               "metadata.SourceID",
	"options":                        "description.VpnConnection.Options",
	"routes":                         "description.VpnConnection.Routes",
	"state":                          "description.VpnConnection.State",
	"tags_src":                       "description.VpnConnection.Tags",
	"transit_gateway_id":             "description.VpnConnection.TransitGatewayId",
	"type":                           "description.VpnConnection.Type",
	"vgw_telemetry":                  "description.VpnConnection.VgwTelemetry",
	"vpn_connection_id":              "description.VpnConnection.VpnConnectionId",
	"vpn_gateway_id":                 "description.VpnConnection.VpnGatewayId",
}

func GetEC2VPNConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPNConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VPNConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VPNConnectionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VPNConnection =============================

// ==========================  START: EC2RouteTable =============================

type EC2RouteTable struct {
	Description   aws.EC2RouteTableDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2RouteTableHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2RouteTable `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2RouteTableHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2RouteTableHit `json:"hits"`
}

type EC2RouteTableSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2RouteTableHits `json:"hits"`
}

type EC2RouteTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2RouteTablePaginator(filters []essdk.BoolFilter, limit *int64) (EC2RouteTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_routetable", filters, limit)
	if err != nil {
		return EC2RouteTablePaginator{}, err
	}

	p := EC2RouteTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2RouteTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2RouteTablePaginator) NextPage(ctx context.Context) ([]EC2RouteTable, error) {
	var response EC2RouteTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2RouteTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2RouteTableFilters = map[string]string{
	"akas":             "aRN",
	"associations":     "description.RouteTable.Associations",
	"kaytu_account_id": "metadata.SourceID",
	"owner_id":         "description.RouteTable.OwnerId",
	"propagating_vgws": "description.RouteTable.PropagatingVgws",
	"route_table_id":   "description.RouteTable.RouteTableId",
	"routes":           "description.RouteTable.Routes",
	"tags_src":         "description.RouteTable.Tags",
	"title":            "routeTableId",
	"vpc_id":           "description.RouteTable.VpcId",
}

func ListEC2RouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2RouteTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2RouteTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2RouteTableFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2RouteTableFilters = map[string]string{
	"akas":             "aRN",
	"associations":     "description.RouteTable.Associations",
	"kaytu_account_id": "metadata.SourceID",
	"owner_id":         "description.RouteTable.OwnerId",
	"propagating_vgws": "description.RouteTable.PropagatingVgws",
	"route_table_id":   "description.RouteTable.RouteTableId",
	"routes":           "description.RouteTable.Routes",
	"tags_src":         "description.RouteTable.Tags",
	"title":            "routeTableId",
	"vpc_id":           "description.RouteTable.VpcId",
}

func GetEC2RouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2RouteTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2RouteTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2RouteTableFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2RouteTable =============================

// ==========================  START: EC2NatGateway =============================

type EC2NatGateway struct {
	Description   aws.EC2NatGatewayDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2NatGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2NatGateway `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2NatGatewayHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2NatGatewayHit `json:"hits"`
}

type EC2NatGatewaySearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2NatGatewayHits `json:"hits"`
}

type EC2NatGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2NatGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2NatGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_natgateway", filters, limit)
	if err != nil {
		return EC2NatGatewayPaginator{}, err
	}

	p := EC2NatGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2NatGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2NatGatewayPaginator) NextPage(ctx context.Context) ([]EC2NatGateway, error) {
	var response EC2NatGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2NatGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2NatGatewayFilters = map[string]string{
	"create_time":           "description.NatGateway.CreateTime",
	"delete_time":           "description.NatGateway.DeleteTime",
	"failure_code":          "description.NatGateway.FailureCode",
	"failure_message":       "description.NatGateway.FailureMessage",
	"kaytu_account_id":      "metadata.SourceID",
	"nat_gateway_addresses": "description.NatGateway.NatGatewayAddresses",
	"nat_gateway_id":        "description.NatGateway.NatGatewayId",
	"provisioned_bandwidth": "description.NatGateway.ProvisionedBandwidth",
	"state":                 "description.NatGateway.State",
	"subnet_id":             "description.NatGateway.SubnetId",
	"tags_src":              "description.NatGateway.Tags",
	"vpc_id":                "description.NatGateway.VpcId",
}

func ListEC2NatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2NatGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2NatGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2NatGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2NatGatewayFilters = map[string]string{
	"create_time":           "description.NatGateway.CreateTime",
	"delete_time":           "description.NatGateway.DeleteTime",
	"failure_code":          "description.NatGateway.FailureCode",
	"failure_message":       "description.NatGateway.FailureMessage",
	"kaytu_account_id":      "metadata.SourceID",
	"nat_gateway_addresses": "description.NatGateway.NatGatewayAddresses",
	"nat_gateway_id":        "description.NatGateway.NatGatewayId",
	"provisioned_bandwidth": "description.NatGateway.ProvisionedBandwidth",
	"state":                 "description.NatGateway.State",
	"subnet_id":             "description.NatGateway.SubnetId",
	"tags_src":              "description.NatGateway.Tags",
	"vpc_id":                "description.NatGateway.VpcId",
}

func GetEC2NatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2NatGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2NatGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2NatGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2NatGateway =============================

// ==========================  START: EC2Region =============================

type EC2Region struct {
	Description   aws.EC2RegionDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type EC2RegionHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Region     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2RegionHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2RegionHit    `json:"hits"`
}

type EC2RegionSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  EC2RegionHits `json:"hits"`
}

type EC2RegionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2RegionPaginator(filters []essdk.BoolFilter, limit *int64) (EC2RegionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_region", filters, limit)
	if err != nil {
		return EC2RegionPaginator{}, err
	}

	p := EC2RegionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2RegionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2RegionPaginator) NextPage(ctx context.Context) ([]EC2Region, error) {
	var response EC2RegionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Region
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2RegionFilters = map[string]string{
	"account_id":       "metadata.AccountID",
	"kaytu_account_id": "metadata.SourceID",
	"keibi_metadata":   "metadata",
	"name":             "description.Region.RegionName",
	"opt_in_status":    "description.Region.OptInStatus",
	"partition":        "metadata.Partition",
	"region":           "description.Region.RegionName",
	"title":            "description.Region.RegionName",
}

func ListEC2Region(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Region")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2RegionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2RegionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2RegionFilters = map[string]string{
	"account_id":       "metadata.AccountID",
	"kaytu_account_id": "metadata.SourceID",
	"keibi_metadata":   "metadata",
	"name":             "description.Region.RegionName",
	"opt_in_status":    "description.Region.OptInStatus",
	"partition":        "metadata.Partition",
	"region":           "description.Region.RegionName",
	"title":            "description.Region.RegionName",
}

func GetEC2Region(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Region")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2RegionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2RegionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Region =============================

// ==========================  START: EC2AvailabilityZone =============================

type EC2AvailabilityZone struct {
	Description   aws.EC2AvailabilityZoneDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type EC2AvailabilityZoneHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  EC2AvailabilityZone `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type EC2AvailabilityZoneHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []EC2AvailabilityZoneHit `json:"hits"`
}

type EC2AvailabilityZoneSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  EC2AvailabilityZoneHits `json:"hits"`
}

type EC2AvailabilityZonePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2AvailabilityZonePaginator(filters []essdk.BoolFilter, limit *int64) (EC2AvailabilityZonePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_availabilityzone", filters, limit)
	if err != nil {
		return EC2AvailabilityZonePaginator{}, err
	}

	p := EC2AvailabilityZonePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2AvailabilityZonePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2AvailabilityZonePaginator) NextPage(ctx context.Context) ([]EC2AvailabilityZone, error) {
	var response EC2AvailabilityZoneSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2AvailabilityZone
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2AvailabilityZoneFilters = map[string]string{
	"akas":             "aRN",
	"group_name":       "description.AvailabilityZone.GroupName",
	"kaytu_account_id": "metadata.SourceID",
	"messages":         "description.AvailabilityZone.Messages",
	"name":             "description.AvailabilityZone.ZoneName",
	"opt_in_status":    "description.AvailabilityZone.OptInStatus",
	"parent_zone_id":   "description.AvailabilityZone.ParentZoneId",
	"parent_zone_name": "description.AvailabilityZone.ParentZoneName",
	"region_name":      "description.AvailabilityZone.RegionName",
	"title":            "description.AvailabilityZone.ZoneName",
	"zone_id":          "description.AvailabilityZone.ZoneId",
	"zone_type":        "description.AvailabilityZone.ZoneType",
}

func ListEC2AvailabilityZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2AvailabilityZone")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2AvailabilityZonePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2AvailabilityZoneFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2AvailabilityZoneFilters = map[string]string{
	"akas":             "aRN",
	"group_name":       "description.AvailabilityZone.GroupName",
	"kaytu_account_id": "metadata.SourceID",
	"messages":         "description.AvailabilityZone.Messages",
	"name":             "description.AvailabilityZone.ZoneName",
	"opt_in_status":    "description.AvailabilityZone.OptInStatus",
	"parent_zone_id":   "description.AvailabilityZone.ParentZoneId",
	"parent_zone_name": "description.AvailabilityZone.ParentZoneName",
	"region_name":      "description.AvailabilityZone.RegionName",
	"title":            "description.AvailabilityZone.ZoneName",
	"zone_id":          "description.AvailabilityZone.ZoneId",
	"zone_type":        "description.AvailabilityZone.ZoneType",
}

func GetEC2AvailabilityZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2AvailabilityZone")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2AvailabilityZonePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2AvailabilityZoneFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2AvailabilityZone =============================

// ==========================  START: EC2FlowLog =============================

type EC2FlowLog struct {
	Description   aws.EC2FlowLogDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EC2FlowLogHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2FlowLog    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2FlowLogHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2FlowLogHit   `json:"hits"`
}

type EC2FlowLogSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EC2FlowLogHits `json:"hits"`
}

type EC2FlowLogPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2FlowLogPaginator(filters []essdk.BoolFilter, limit *int64) (EC2FlowLogPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_flowlog", filters, limit)
	if err != nil {
		return EC2FlowLogPaginator{}, err
	}

	p := EC2FlowLogPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2FlowLogPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2FlowLogPaginator) NextPage(ctx context.Context) ([]EC2FlowLog, error) {
	var response EC2FlowLogSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2FlowLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2FlowLogFilters = map[string]string{
	"creation_time":               "description.FlowLog.CreationTime",
	"deliver_logs_error_message":  "description.FlowLog.DeliverLogsErrorMessage",
	"deliver_logs_permission_arn": "description.FlowLog.DeliverLogsPermissionArn",
	"deliver_logs_status":         "description.FlowLog.DeliverLogsStatus",
	"flow_log_id":                 "description.FlowLog.FlowLogId",
	"flow_log_status":             "description.FlowLog.FlowLogStatus",
	"kaytu_account_id":            "metadata.SourceID",
	"log_destination":             "description.FlowLog.LogDestination",
	"log_destination_type":        "description.FlowLog.LogDestinationType",
	"log_format":                  "description.FlowLog.LogFormat",
	"log_group_name":              "description.FlowLog.LogGroupName",
	"max_aggregation_interval":    "description.FlowLog.MaxAggregationInterval",
	"resource_id":                 "description.FlowLog.ResourceId",
	"tags_src":                    "description.FlowLog.Tags",
	"traffic_type":                "description.FlowLog.TrafficType",
}

func ListEC2FlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2FlowLog")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2FlowLogPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2FlowLogFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2FlowLogFilters = map[string]string{
	"creation_time":               "description.FlowLog.CreationTime",
	"deliver_logs_error_message":  "description.FlowLog.DeliverLogsErrorMessage",
	"deliver_logs_permission_arn": "description.FlowLog.DeliverLogsPermissionArn",
	"deliver_logs_status":         "description.FlowLog.DeliverLogsStatus",
	"flow_log_id":                 "description.FlowLog.FlowLogId",
	"flow_log_status":             "description.FlowLog.FlowLogStatus",
	"kaytu_account_id":            "metadata.SourceID",
	"log_destination":             "description.FlowLog.LogDestination",
	"log_destination_type":        "description.FlowLog.LogDestinationType",
	"log_format":                  "description.FlowLog.LogFormat",
	"log_group_name":              "description.FlowLog.LogGroupName",
	"max_aggregation_interval":    "description.FlowLog.MaxAggregationInterval",
	"resource_id":                 "description.FlowLog.ResourceId",
	"tags_src":                    "description.FlowLog.Tags",
	"traffic_type":                "description.FlowLog.TrafficType",
}

func GetEC2FlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2FlowLog")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2FlowLogPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2FlowLogFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2FlowLog =============================

// ==========================  START: EC2CapacityReservation =============================

type EC2CapacityReservation struct {
	Description   aws.EC2CapacityReservationDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type EC2CapacityReservationHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  EC2CapacityReservation `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type EC2CapacityReservationHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []EC2CapacityReservationHit `json:"hits"`
}

type EC2CapacityReservationSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  EC2CapacityReservationHits `json:"hits"`
}

type EC2CapacityReservationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2CapacityReservationPaginator(filters []essdk.BoolFilter, limit *int64) (EC2CapacityReservationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_capacityreservation", filters, limit)
	if err != nil {
		return EC2CapacityReservationPaginator{}, err
	}

	p := EC2CapacityReservationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2CapacityReservationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2CapacityReservationPaginator) NextPage(ctx context.Context) ([]EC2CapacityReservation, error) {
	var response EC2CapacityReservationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2CapacityReservation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2CapacityReservationFilters = map[string]string{
	"akas":                     "description.CapacityReservation.CapacityReservationArn",
	"availability_zone":        "description.CapacityReservation.AvailabilityZone",
	"availability_zone_id":     "description.CapacityReservation.AvailabilityZoneId",
	"available_instance_count": "description.CapacityReservation.AvailableInstanceCount",
	"capacity_reservation_arn": "description.CapacityReservation.CapacityReservationArn",
	"capacity_reservation_id":  "description.CapacityReservation.CapacityReservationId",
	"create_date":              "description.CapacityReservation.CreateDate",
	"ebs_optimized":            "description.CapacityReservation.EbsOptimized",
	"end_date":                 "description.CapacityReservation.EndDate",
	"end_date_type":            "description.CapacityReservation.EndDateType",
	"ephemeral_storage":        "description.CapacityReservation.EphemeralStorage",
	"instance_match_criteria":  "description.CapacityReservation.InstanceMatchCriteria",
	"instance_platform":        "description.CapacityReservation.InstancePlatform",
	"instance_type":            "description.CapacityReservation.InstanceType",
	"kaytu_account_id":         "metadata.SourceID",
	"owner_id":                 "description.CapacityReservation.OwnerId",
	"start_date":               "description.CapacityReservation.StartDate",
	"state":                    "description.CapacityReservation.State",
	"tag_src":                  "description.CapacityReservation.Tags",
	"tags":                     "description.CapacityReservation.Tags",
	"tenancy":                  "description.CapacityReservation.Tenancy",
	"title":                    "description.CapacityReservation.CapacityReservationId",
	"total_instance_count":     "description.CapacityReservation.TotalInstanceCount",
}

func ListEC2CapacityReservation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2CapacityReservation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2CapacityReservationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2CapacityReservationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2CapacityReservationFilters = map[string]string{
	"akas":                     "description.CapacityReservation.CapacityReservationArn",
	"availability_zone":        "description.CapacityReservation.AvailabilityZone",
	"availability_zone_id":     "description.CapacityReservation.AvailabilityZoneId",
	"available_instance_count": "description.CapacityReservation.AvailableInstanceCount",
	"capacity_reservation_arn": "description.CapacityReservation.CapacityReservationArn",
	"capacity_reservation_id":  "description.CapacityReservation.CapacityReservationId",
	"create_date":              "description.CapacityReservation.CreateDate",
	"ebs_optimized":            "description.CapacityReservation.EbsOptimized",
	"end_date":                 "description.CapacityReservation.EndDate",
	"end_date_type":            "description.CapacityReservation.EndDateType",
	"ephemeral_storage":        "description.CapacityReservation.EphemeralStorage",
	"instance_match_criteria":  "description.CapacityReservation.InstanceMatchCriteria",
	"instance_platform":        "description.CapacityReservation.InstancePlatform",
	"instance_type":            "description.CapacityReservation.InstanceType",
	"kaytu_account_id":         "metadata.SourceID",
	"owner_id":                 "description.CapacityReservation.OwnerId",
	"start_date":               "description.CapacityReservation.StartDate",
	"state":                    "description.CapacityReservation.State",
	"tag_src":                  "description.CapacityReservation.Tags",
	"tags":                     "description.CapacityReservation.Tags",
	"tenancy":                  "description.CapacityReservation.Tenancy",
	"title":                    "description.CapacityReservation.CapacityReservationId",
	"total_instance_count":     "description.CapacityReservation.TotalInstanceCount",
}

func GetEC2CapacityReservation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2CapacityReservation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2CapacityReservationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2CapacityReservationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2CapacityReservation =============================

// ==========================  START: EC2KeyPair =============================

type EC2KeyPair struct {
	Description   aws.EC2KeyPairDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EC2KeyPairHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2KeyPair    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2KeyPairHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2KeyPairHit   `json:"hits"`
}

type EC2KeyPairSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EC2KeyPairHits `json:"hits"`
}

type EC2KeyPairPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2KeyPairPaginator(filters []essdk.BoolFilter, limit *int64) (EC2KeyPairPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_keypair", filters, limit)
	if err != nil {
		return EC2KeyPairPaginator{}, err
	}

	p := EC2KeyPairPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2KeyPairPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2KeyPairPaginator) NextPage(ctx context.Context) ([]EC2KeyPair, error) {
	var response EC2KeyPairSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2KeyPair
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2KeyPairFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"key_fingerprint":  "description.KeyPair.KeyFingerprint",
	"key_name":         "description.KeyPair.KeyName",
	"key_pair_id":      "description.KeyPair.KeyPairId",
	"tags_src":         "description.KeyPair.Tags",
	"title":            "description.KeyPair.KeyName",
}

func ListEC2KeyPair(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2KeyPair")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2KeyPairPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2KeyPairFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2KeyPairFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"key_fingerprint":  "description.KeyPair.KeyFingerprint",
	"key_name":         "description.KeyPair.KeyName",
	"key_pair_id":      "description.KeyPair.KeyPairId",
	"tags_src":         "description.KeyPair.Tags",
	"title":            "description.KeyPair.KeyName",
}

func GetEC2KeyPair(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2KeyPair")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2KeyPairPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2KeyPairFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2KeyPair =============================

// ==========================  START: EC2AMI =============================

type EC2AMI struct {
	Description   aws.EC2AMIDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type EC2AMIHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2AMI        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2AMIHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2AMIHit       `json:"hits"`
}

type EC2AMISearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  EC2AMIHits `json:"hits"`
}

type EC2AMIPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2AMIPaginator(filters []essdk.BoolFilter, limit *int64) (EC2AMIPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_image", filters, limit)
	if err != nil {
		return EC2AMIPaginator{}, err
	}

	p := EC2AMIPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2AMIPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2AMIPaginator) NextPage(ctx context.Context) ([]EC2AMI, error) {
	var response EC2AMISearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2AMI
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2AMIFilters = map[string]string{
	"architecture":          "description.AMI.Architecture",
	"block_device_mappings": "description.AMI.BlockDeviceMappings",
	"creation_date":         "description.AMI.CreationDate",
	"description":           "description.AMI.Description",
	"ena_support":           "description.AMI.EnaSupport",
	"hypervisor":            "description.AMI.Hypervisor",
	"image_id":              "description.AMI.ImageId",
	"image_location":        "description.AMI.ImageLocation",
	"image_owner_alias":     "description.AMI.ImageOwnerAlias",
	"image_type":            "description.AMI.ImageType",
	"kaytu_account_id":      "metadata.SourceID",
	"kernel_id":             "description.AMI.KernelId",
	"launch_permissions":    "description.LaunchPermissions",
	"name":                  "description.AMI.Name",
	"owner_id":              "description.AMI.OwnerId",
	"platform":              "description.AMI.Platform",
	"platform_details":      "description.AMI.PlatformDetails",
	"product_codes":         "description.AMI.ProductCodes",
	"public":                "description.AMI.Public",
	"ramdisk_id":            "description.AMI.RamdiskId",
	"root_device_name":      "description.AMI.RootDeviceName",
	"root_device_type":      "description.AMI.RootDeviceType",
	"sriov_net_support":     "description.AMI.SriovNetSupport",
	"state":                 "description.AMI.State",
	"tags_src":              "description.AMI.Tags",
	"usage_operation":       "description.AMI.UsageOperation",
	"virtualization_type":   "description.AMI.VirtualizationType",
}

func ListEC2AMI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2AMI")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2AMIPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2AMIFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2AMIFilters = map[string]string{
	"architecture":          "description.AMI.Architecture",
	"block_device_mappings": "description.AMI.BlockDeviceMappings",
	"creation_date":         "description.AMI.CreationDate",
	"description":           "description.AMI.Description",
	"ena_support":           "description.AMI.EnaSupport",
	"hypervisor":            "description.AMI.Hypervisor",
	"image_id":              "description.AMI.ImageId",
	"image_location":        "description.AMI.ImageLocation",
	"image_owner_alias":     "description.AMI.ImageOwnerAlias",
	"image_type":            "description.AMI.ImageType",
	"kaytu_account_id":      "metadata.SourceID",
	"kernel_id":             "description.AMI.KernelId",
	"launch_permissions":    "description.LaunchPermissions",
	"name":                  "description.AMI.Name",
	"owner_id":              "description.AMI.OwnerId",
	"platform":              "description.AMI.Platform",
	"platform_details":      "description.AMI.PlatformDetails",
	"product_codes":         "description.AMI.ProductCodes",
	"public":                "description.AMI.Public",
	"ramdisk_id":            "description.AMI.RamdiskId",
	"root_device_name":      "description.AMI.RootDeviceName",
	"root_device_type":      "description.AMI.RootDeviceType",
	"sriov_net_support":     "description.AMI.SriovNetSupport",
	"state":                 "description.AMI.State",
	"tags_src":              "description.AMI.Tags",
	"usage_operation":       "description.AMI.UsageOperation",
	"virtualization_type":   "description.AMI.VirtualizationType",
}

func GetEC2AMI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2AMI")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2AMIPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2AMIFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2AMI =============================

// ==========================  START: EC2ReservedInstances =============================

type EC2ReservedInstances struct {
	Description   aws.EC2ReservedInstancesDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type EC2ReservedInstancesHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  EC2ReservedInstances `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type EC2ReservedInstancesHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []EC2ReservedInstancesHit `json:"hits"`
}

type EC2ReservedInstancesSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  EC2ReservedInstancesHits `json:"hits"`
}

type EC2ReservedInstancesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2ReservedInstancesPaginator(filters []essdk.BoolFilter, limit *int64) (EC2ReservedInstancesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_reservedinstances", filters, limit)
	if err != nil {
		return EC2ReservedInstancesPaginator{}, err
	}

	p := EC2ReservedInstancesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2ReservedInstancesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2ReservedInstancesPaginator) NextPage(ctx context.Context) ([]EC2ReservedInstances, error) {
	var response EC2ReservedInstancesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2ReservedInstances
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2ReservedInstancesFilters = map[string]string{
	"availability_zone":                "description.ReservedInstances.AvailabilityZone",
	"currency_code":                    "description.ReservedInstances.CurrencyCode",
	"duration":                         "description.ReservedInstances.Duration",
	"end_time":                         "description.ReservedInstances.End",
	"fixed_price":                      "description.ReservedInstances.FixedPrice",
	"instance_count":                   "description.ReservedInstances.InstanceCount",
	"instance_state":                   "description.ReservedInstances.State",
	"instance_tenancy":                 "description.ReservedInstances.InstanceTenancy",
	"instance_type":                    "description.ReservedInstances.InstanceType",
	"kaytu_account_id":                 "metadata.SourceID",
	"offering_class":                   "description.ReservedInstances.OfferingClass",
	"offering_type":                    "description.ReservedInstances.OfferingType",
	"product_description":              "description.ReservedInstances.ProductDescription",
	"reserved_instance_id":             "description.ReservedInstances.ReservedInstancesId",
	"reserved_instances_modifications": "description.ModificationDetails",
	"scope":                            "description.ReservedInstances.Scope",
	"start_time":                       "description.ReservedInstances.Start",
	"tags_src":                         "description.ReservedInstances.Tags",
	"title":                            "description.ReservedInstances.ReservedInstancesId",
	"usage_price":                      "description.ReservedInstances.UsagePrice",
}

func ListEC2ReservedInstances(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2ReservedInstances")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2ReservedInstancesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2ReservedInstancesFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2ReservedInstancesFilters = map[string]string{
	"availability_zone":                "description.ReservedInstances.AvailabilityZone",
	"currency_code":                    "description.ReservedInstances.CurrencyCode",
	"duration":                         "description.ReservedInstances.Duration",
	"end_time":                         "description.ReservedInstances.End",
	"fixed_price":                      "description.ReservedInstances.FixedPrice",
	"instance_count":                   "description.ReservedInstances.InstanceCount",
	"instance_state":                   "description.ReservedInstances.State",
	"instance_tenancy":                 "description.ReservedInstances.InstanceTenancy",
	"instance_type":                    "description.ReservedInstances.InstanceType",
	"kaytu_account_id":                 "metadata.SourceID",
	"offering_class":                   "description.ReservedInstances.OfferingClass",
	"offering_type":                    "description.ReservedInstances.OfferingType",
	"product_description":              "description.ReservedInstances.ProductDescription",
	"reserved_instance_id":             "description.ReservedInstance.ReservedInstancesId",
	"reserved_instances_modifications": "description.ModificationDetails",
	"scope":                            "description.ReservedInstances.Scope",
	"start_time":                       "description.ReservedInstances.Start",
	"tags_src":                         "description.ReservedInstances.Tags",
	"title":                            "description.ReservedInstances.ReservedInstancesId",
	"usage_price":                      "description.ReservedInstances.UsagePrice",
}

func GetEC2ReservedInstances(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2ReservedInstances")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2ReservedInstancesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2ReservedInstancesFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2ReservedInstances =============================

// ==========================  START: EC2CapacityReservationFleet =============================

type EC2CapacityReservationFleet struct {
	Description   aws.EC2CapacityReservationFleetDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type EC2CapacityReservationFleetHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  EC2CapacityReservationFleet `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type EC2CapacityReservationFleetHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []EC2CapacityReservationFleetHit `json:"hits"`
}

type EC2CapacityReservationFleetSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  EC2CapacityReservationFleetHits `json:"hits"`
}

type EC2CapacityReservationFleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2CapacityReservationFleetPaginator(filters []essdk.BoolFilter, limit *int64) (EC2CapacityReservationFleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_capacityreservationfleet", filters, limit)
	if err != nil {
		return EC2CapacityReservationFleetPaginator{}, err
	}

	p := EC2CapacityReservationFleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2CapacityReservationFleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2CapacityReservationFleetPaginator) NextPage(ctx context.Context) ([]EC2CapacityReservationFleet, error) {
	var response EC2CapacityReservationFleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2CapacityReservationFleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2CapacityReservationFleetFilters = map[string]string{
	"akas":                           "description.CapacityReservationFleet.CapacityReservationFleetArn",
	"capacity_reservation_fleet_arn": "description.CapacityReservationFleet.CapacityReservationFleetArn",
	"capacity_reservation_fleet_id":  "description.CapacityReservationFleet.CapacityReservationFleetId",
	"kaytu_account_id":               "metadata.SourceID",
	"title":                          "description.CapacityReservationFleet.CapacityReservationFleetId",
}

func ListEC2CapacityReservationFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2CapacityReservationFleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2CapacityReservationFleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2CapacityReservationFleetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2CapacityReservationFleetFilters = map[string]string{
	"akas":                           "description.CapacityReservationFleet.CapacityReservationFleetArn",
	"capacity_reservation_fleet_arn": "description.CapacityReservationFleet.CapacityReservationFleetArn",
	"capacity_reservation_fleet_id":  "description.CapacityReservationFleet.CapacityReservationFleetId",
	"kaytu_account_id":               "metadata.SourceID",
	"title":                          "description.CapacityReservationFleet.CapacityReservationFleetId",
}

func GetEC2CapacityReservationFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2CapacityReservationFleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2CapacityReservationFleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2CapacityReservationFleetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2CapacityReservationFleet =============================

// ==========================  START: EC2Fleet =============================

type EC2Fleet struct {
	Description   aws.EC2FleetDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type EC2FleetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Fleet      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2FleetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2FleetHit     `json:"hits"`
}

type EC2FleetSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  EC2FleetHits `json:"hits"`
}

type EC2FleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2FleetPaginator(filters []essdk.BoolFilter, limit *int64) (EC2FleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_fleet", filters, limit)
	if err != nil {
		return EC2FleetPaginator{}, err
	}

	p := EC2FleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2FleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2FleetPaginator) NextPage(ctx context.Context) ([]EC2Fleet, error) {
	var response EC2FleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Fleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2FleetFilters = map[string]string{
	"fleet_id":         "description.Fleet.FleetId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Fleet.FleetId",
}

func ListEC2Fleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Fleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2FleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2FleetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2FleetFilters = map[string]string{
	"fleet_id":         "description.Fleet.FleetId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Fleet.FleetId",
}

func GetEC2Fleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Fleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2FleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2FleetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Fleet =============================

// ==========================  START: EC2Host =============================

type EC2Host struct {
	Description   aws.EC2HostDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type EC2HostHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Host       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2HostHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2HostHit      `json:"hits"`
}

type EC2HostSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  EC2HostHits `json:"hits"`
}

type EC2HostPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2HostPaginator(filters []essdk.BoolFilter, limit *int64) (EC2HostPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_host", filters, limit)
	if err != nil {
		return EC2HostPaginator{}, err
	}

	p := EC2HostPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2HostPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2HostPaginator) NextPage(ctx context.Context) ([]EC2Host, error) {
	var response EC2HostSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Host
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2HostFilters = map[string]string{
	"host_id":          "description.Host.HostId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Host.HostId",
}

func ListEC2Host(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Host")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2HostPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2HostFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2HostFilters = map[string]string{
	"host_id":          "description.Host.HostId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Host.HostId",
}

func GetEC2Host(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Host")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2HostPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2HostFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Host =============================

// ==========================  START: EC2PlacementGroup =============================

type EC2PlacementGroup struct {
	Description   aws.EC2PlacementGroupDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2PlacementGroupHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2PlacementGroup `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2PlacementGroupHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2PlacementGroupHit `json:"hits"`
}

type EC2PlacementGroupSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2PlacementGroupHits `json:"hits"`
}

type EC2PlacementGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2PlacementGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EC2PlacementGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_placementgroup", filters, limit)
	if err != nil {
		return EC2PlacementGroupPaginator{}, err
	}

	p := EC2PlacementGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2PlacementGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2PlacementGroupPaginator) NextPage(ctx context.Context) ([]EC2PlacementGroup, error) {
	var response EC2PlacementGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2PlacementGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2PlacementGroupFilters = map[string]string{
	"group_id":         "description.PlacementGroup.GroupId",
	"group_name":       "description.PlacementGroup.GroupName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.PlacementGroup.GroupName",
}

func ListEC2PlacementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2PlacementGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2PlacementGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2PlacementGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2PlacementGroupFilters = map[string]string{
	"group_id":         "description.PlacementGroup.GroupId",
	"group_name":       "description.PlacementGroup.GroupName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.PlacementGroup.GroupName",
}

func GetEC2PlacementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2PlacementGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2PlacementGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2PlacementGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2PlacementGroup =============================

// ==========================  START: EC2TransitGateway =============================

type EC2TransitGateway struct {
	Description   aws.EC2TransitGatewayDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2TransitGatewayHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2TransitGateway `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2TransitGatewayHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2TransitGatewayHit `json:"hits"`
}

type EC2TransitGatewaySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2TransitGatewayHits `json:"hits"`
}

type EC2TransitGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgateway", filters, limit)
	if err != nil {
		return EC2TransitGatewayPaginator{}, err
	}

	p := EC2TransitGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayPaginator) NextPage(ctx context.Context) ([]EC2TransitGateway, error) {
	var response EC2TransitGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayFilters = map[string]string{
	"akas":                               "description.TransitGateway.TransitGatewayArn",
	"amazon_side_asn":                    "description.TransitGateway.Options.AmazonSideAsn",
	"association_default_route_table_id": "description.TransitGateway.Options.AssociationDefaultRouteTableId",
	"auto_accept_shared_attachments":     "description.TransitGateway.Options.AutoAcceptSharedAttachments",
	"cidr_blocks":                        "description.TransitGateway.Options.TransitGatewayCidrBlocks",
	"creation_time":                      "description.TransitGateway.CreationTime",
	"default_route_table_association":    "description.TransitGateway.Options.DefaultRouteTableAssociation",
	"default_route_table_propagation":    "description.TransitGateway.Options.DefaultRouteTablePropagation",
	"description":                        "description.TransitGateway.Description",
	"dns_support":                        "description.TransitGateway.Options.DnsSupport",
	"kaytu_account_id":                   "metadata.SourceID",
	"multicast_support":                  "description.TransitGateway.Options.MulticastSupport",
	"owner_id":                           "description.TransitGateway.OwnerId",
	"propagation_default_route_table_id": "description.TransitGateway.Options.PropagationDefaultRouteTableId",
	"state":                              "description.TransitGateway.State",
	"tags_src":                           "description.TransitGateway.Tags",
	"transit_gateway_arn":                "description.TransitGateway.TransitGatewayArn",
	"transit_gateway_id":                 "description.TransitGateway.TransitGatewayId",
	"vpn_ecmp_support":                   "description.TransitGateway.Options.VpnEcmpSupport",
}

func ListEC2TransitGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2TransitGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2TransitGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2TransitGatewayFilters = map[string]string{
	"akas":                               "description.TransitGateway.TransitGatewayArn",
	"amazon_side_asn":                    "description.TransitGateway.Options.AmazonSideAsn",
	"association_default_route_table_id": "description.TransitGateway.Options.AssociationDefaultRouteTableId",
	"auto_accept_shared_attachments":     "description.TransitGateway.Options.AutoAcceptSharedAttachments",
	"cidr_blocks":                        "description.TransitGateway.Options.TransitGatewayCidrBlocks",
	"creation_time":                      "description.TransitGateway.CreationTime",
	"default_route_table_association":    "description.TransitGateway.Options.DefaultRouteTableAssociation",
	"default_route_table_propagation":    "description.TransitGateway.Options.DefaultRouteTablePropagation",
	"description":                        "description.TransitGateway.Description",
	"dns_support":                        "description.TransitGateway.Options.DnsSupport",
	"kaytu_account_id":                   "metadata.SourceID",
	"multicast_support":                  "description.TransitGateway.Options.MulticastSupport",
	"owner_id":                           "description.TransitGateway.OwnerId",
	"propagation_default_route_table_id": "description.TransitGateway.Options.PropagationDefaultRouteTableId",
	"state":                              "description.TransitGateway.State",
	"tags_src":                           "description.TransitGateway.Tags",
	"transit_gateway_arn":                "description.TransitGateway.TransitGatewayArn",
	"transit_gateway_id":                 "description.TransitGateway.TransitGatewayId",
	"vpn_ecmp_support":                   "description.TransitGateway.Options.VpnEcmpSupport",
}

func GetEC2TransitGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2TransitGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2TransitGateway =============================

// ==========================  START: EC2TransitGatewayRouteTable =============================

type EC2TransitGatewayRouteTable struct {
	Description   aws.EC2TransitGatewayRouteTableDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type EC2TransitGatewayRouteTableHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  EC2TransitGatewayRouteTable `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type EC2TransitGatewayRouteTableHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []EC2TransitGatewayRouteTableHit `json:"hits"`
}

type EC2TransitGatewayRouteTableSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  EC2TransitGatewayRouteTableHits `json:"hits"`
}

type EC2TransitGatewayRouteTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayRouteTablePaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayRouteTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgatewayroutetable", filters, limit)
	if err != nil {
		return EC2TransitGatewayRouteTablePaginator{}, err
	}

	p := EC2TransitGatewayRouteTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayRouteTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayRouteTablePaginator) NextPage(ctx context.Context) ([]EC2TransitGatewayRouteTable, error) {
	var response EC2TransitGatewayRouteTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGatewayRouteTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayRouteTableFilters = map[string]string{
	"creation_time":                   "description.TransitGatewayRouteTable.CreationTime",
	"default_association_route_table": "description.TransitGatewayRouteTable.DefaultAssociationRouteTable",
	"default_propagation_route_table": "description.TransitGatewayRouteTable.DefaultPropagationRouteTable",
	"kaytu_account_id":                "metadata.SourceID",
	"state":                           "description.TransitGatewayRouteTable.State",
	"tags_src":                        "description.TransitGatewayRouteTable.Tags",
	"transit_gateway_id":              "description.TransitGatewayRouteTable.TransitGatewayId",
	"transit_gateway_route_table_id":  "description.TransitGatewayRouteTable.TransitGatewayRouteTableId",
}

func ListEC2TransitGatewayRouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGatewayRouteTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2TransitGatewayRouteTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2TransitGatewayRouteTableFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2TransitGatewayRouteTableFilters = map[string]string{
	"creation_time":                   "description.TransitGatewayRouteTable.CreationTime",
	"default_association_route_table": "description.TransitGatewayRouteTable.DefaultAssociationRouteTable",
	"default_propagation_route_table": "description.TransitGatewayRouteTable.DefaultPropagationRouteTable",
	"kaytu_account_id":                "metadata.SourceID",
	"state":                           "description.TransitGatewayRouteTable.State",
	"tags_src":                        "description.TransitGatewayRouteTable.Tags",
	"transit_gateway_id":              "description.TransitGatewayRouteTable.TransitGatewayId",
	"transit_gateway_route_table_id":  "description.TransitGatewayRouteTable.TransitGatewayRouteTableId",
}

func GetEC2TransitGatewayRouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGatewayRouteTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayRouteTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2TransitGatewayRouteTableFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2TransitGatewayRouteTable =============================

// ==========================  START: EC2DhcpOptions =============================

type EC2DhcpOptions struct {
	Description   aws.EC2DhcpOptionsDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EC2DhcpOptionsHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EC2DhcpOptions `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EC2DhcpOptionsHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EC2DhcpOptionsHit `json:"hits"`
}

type EC2DhcpOptionsSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EC2DhcpOptionsHits `json:"hits"`
}

type EC2DhcpOptionsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2DhcpOptionsPaginator(filters []essdk.BoolFilter, limit *int64) (EC2DhcpOptionsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_dhcpoptions", filters, limit)
	if err != nil {
		return EC2DhcpOptionsPaginator{}, err
	}

	p := EC2DhcpOptionsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2DhcpOptionsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2DhcpOptionsPaginator) NextPage(ctx context.Context) ([]EC2DhcpOptions, error) {
	var response EC2DhcpOptionsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2DhcpOptions
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2DhcpOptionsFilters = map[string]string{
	"dhcp_options_id":      "description.DhcpOptions.DhcpOptionsId",
	"domain_name":          "description.DhcpOptions.DhcpConfigurations",
	"domain_name_servers":  "description.DhcpOptions.DhcpConfigurations",
	"kaytu_account_id":     "metadata.SourceID",
	"netbios_name_servers": "description.DhcpOptions.DhcpConfigurations",
	"netbios_node_type":    "description.DhcpOptions.DhcpConfigurations",
	"ntp_servers":          "description.DhcpOptions.DhcpConfigurations",
	"owner_id":             "description.DhcpOptions.OwnerId",
	"tags_src":             "description.DhcpOptions.Tags",
}

func ListEC2DhcpOptions(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2DhcpOptions")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2DhcpOptionsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2DhcpOptionsFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2DhcpOptionsFilters = map[string]string{
	"dhcp_options_id":      "description.DhcpOptions.DhcpOptionsId",
	"domain_name":          "description.DhcpOptions.DhcpConfigurations",
	"domain_name_servers":  "description.DhcpOptions.DhcpConfigurations",
	"kaytu_account_id":     "metadata.SourceID",
	"netbios_name_servers": "description.DhcpOptions.DhcpConfigurations",
	"netbios_node_type":    "description.DhcpOptions.DhcpConfigurations",
	"ntp_servers":          "description.DhcpOptions.DhcpConfigurations",
	"owner_id":             "description.DhcpOptions.OwnerId",
	"tags_src":             "description.DhcpOptions.Tags",
}

func GetEC2DhcpOptions(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2DhcpOptions")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2DhcpOptionsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2DhcpOptionsFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2DhcpOptions =============================

// ==========================  START: EC2EgressOnlyInternetGateway =============================

type EC2EgressOnlyInternetGateway struct {
	Description   aws.EC2EgressOnlyInternetGatewayDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type EC2EgressOnlyInternetGatewayHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  EC2EgressOnlyInternetGateway `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type EC2EgressOnlyInternetGatewayHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []EC2EgressOnlyInternetGatewayHit `json:"hits"`
}

type EC2EgressOnlyInternetGatewaySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  EC2EgressOnlyInternetGatewayHits `json:"hits"`
}

type EC2EgressOnlyInternetGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2EgressOnlyInternetGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2EgressOnlyInternetGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_egressonlyinternetgateway", filters, limit)
	if err != nil {
		return EC2EgressOnlyInternetGatewayPaginator{}, err
	}

	p := EC2EgressOnlyInternetGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2EgressOnlyInternetGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2EgressOnlyInternetGatewayPaginator) NextPage(ctx context.Context) ([]EC2EgressOnlyInternetGateway, error) {
	var response EC2EgressOnlyInternetGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2EgressOnlyInternetGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2EgressOnlyInternetGatewayFilters = map[string]string{
	"attachments":      "description.EgressOnlyInternetGateway.Attachments",
	"id":               "description.EgressOnlyInternetGateway.EgressOnlyInternetGatewayId",
	"kaytu_account_id": "metadata.SourceID",
	"tags_src":         "description.EgressOnlyInternetGateway.Tags",
}

func ListEC2EgressOnlyInternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2EgressOnlyInternetGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2EgressOnlyInternetGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2EgressOnlyInternetGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2EgressOnlyInternetGatewayFilters = map[string]string{
	"attachments":      "description.EgressOnlyInternetGateway.Attachments",
	"id":               "description.EgressOnlyInternetGateway.EgressOnlyInternetGatewayId",
	"kaytu_account_id": "metadata.SourceID",
	"tags_src":         "description.EgressOnlyInternetGateway.Tags",
}

func GetEC2EgressOnlyInternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2EgressOnlyInternetGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2EgressOnlyInternetGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2EgressOnlyInternetGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2EgressOnlyInternetGateway =============================

// ==========================  START: EC2VpcPeeringConnection =============================

type EC2VpcPeeringConnection struct {
	Description   aws.EC2VpcPeeringConnectionDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type EC2VpcPeeringConnectionHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  EC2VpcPeeringConnection `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type EC2VpcPeeringConnectionHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []EC2VpcPeeringConnectionHit `json:"hits"`
}

type EC2VpcPeeringConnectionSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  EC2VpcPeeringConnectionHits `json:"hits"`
}

type EC2VpcPeeringConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VpcPeeringConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VpcPeeringConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpcpeeringconnection", filters, limit)
	if err != nil {
		return EC2VpcPeeringConnectionPaginator{}, err
	}

	p := EC2VpcPeeringConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VpcPeeringConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VpcPeeringConnectionPaginator) NextPage(ctx context.Context) ([]EC2VpcPeeringConnection, error) {
	var response EC2VpcPeeringConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VpcPeeringConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VpcPeeringConnectionFilters = map[string]string{
	"accepter_cidr_block":           "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlock",
	"accepter_cidr_block_set":       "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlockSet",
	"accepter_ipv6_cidr_block_set":  "description.VpcPeeringConnection.AccepterVpcInfo.Ipv6CidrBlockSet",
	"accepter_owner_id":             "description.VpcPeeringConnection.AccepterVpcInfo.OwnerId",
	"accepter_peering_options":      "description.VpcPeeringConnection.AccepterVpcInfo.PeeringOptions",
	"accepter_region":               "description.VpcPeeringConnection.AccepterVpcInfo.Region",
	"accepter_vpc_id":               "description.VpcPeeringConnection.AccepterVpcInfo.VpcId",
	"expiration_time":               "description.VpcPeeringConnection.ExpirationTime",
	"id":                            "description.VpcPeeringConnection.VpcPeeringConnectionId",
	"kaytu_account_id":              "metadata.SourceID",
	"requester_cidr_block":          "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlock",
	"requester_cidr_block_set":      "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlockSet",
	"requester_ipv6_cidr_block_set": "description.VpcPeeringConnection.RequesterVpcInfo.Ipv6CidrBlockSet",
	"requester_owner_id":            "description.VpcPeeringConnection.RequesterVpcInfo.OwnerId",
	"requester_peering_options":     "description.VpcPeeringConnection.RequesterVpcInfo.PeeringOptions",
	"requester_region":              "description.VpcPeeringConnection.RequesterVpcInfo.Region",
	"requester_vpc_id":              "description.VpcPeeringConnection.RequesterVpcInfo.VpcId",
	"status_code":                   "description.VpcPeeringConnection.Status.Code",
	"status_message":                "description.VpcPeeringConnection.Status.Message",
	"tags_src":                      "description.VpcPeeringConnection.Tags",
	"title":                         "description.VpcPeeringConnection.VpcPeeringConnectionId",
}

func ListEC2VpcPeeringConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VpcPeeringConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VpcPeeringConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VpcPeeringConnectionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VpcPeeringConnectionFilters = map[string]string{
	"accepter_cidr_block":           "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlock",
	"accepter_cidr_block_set":       "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlockSet",
	"accepter_ipv6_cidr_block_set":  "description.VpcPeeringConnection.AccepterVpcInfo.Ipv6CidrBlockSet",
	"accepter_owner_id":             "description.VpcPeeringConnection.AccepterVpcInfo.OwnerId",
	"accepter_peering_options":      "description.VpcPeeringConnection.AccepterVpcInfo.PeeringOptions",
	"accepter_region":               "description.VpcPeeringConnection.AccepterVpcInfo.Region",
	"accepter_vpc_id":               "description.VpcPeeringConnection.AccepterVpcInfo.VpcId",
	"expiration_time":               "description.VpcPeeringConnection.ExpirationTime",
	"id":                            "description.VpcPeeringConnection.VpcPeeringConnectionId",
	"kaytu_account_id":              "metadata.SourceID",
	"requester_cidr_block":          "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlock",
	"requester_cidr_block_set":      "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlockSet",
	"requester_ipv6_cidr_block_set": "description.VpcPeeringConnection.RequesterVpcInfo.Ipv6CidrBlockSet",
	"requester_owner_id":            "description.VpcPeeringConnection.RequesterVpcInfo.OwnerId",
	"requester_peering_options":     "description.VpcPeeringConnection.RequesterVpcInfo.PeeringOptions",
	"requester_region":              "description.VpcPeeringConnection.RequesterVpcInfo.Region",
	"requester_vpc_id":              "description.VpcPeeringConnection.RequesterVpcInfo.VpcId",
	"status_code":                   "description.VpcPeeringConnection.Status.Code",
	"status_message":                "description.VpcPeeringConnection.Status.Message",
	"tags_src":                      "description.VpcPeeringConnection.Tags",
	"title":                         "description.VpcPeeringConnection.VpcPeeringConnectionId",
}

func GetEC2VpcPeeringConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VpcPeeringConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VpcPeeringConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VpcPeeringConnectionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VpcPeeringConnection =============================

// ==========================  START: EC2SecurityGroupRule =============================

type EC2SecurityGroupRule struct {
	Description   aws.EC2SecurityGroupRuleDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type EC2SecurityGroupRuleHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  EC2SecurityGroupRule `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type EC2SecurityGroupRuleHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []EC2SecurityGroupRuleHit `json:"hits"`
}

type EC2SecurityGroupRuleSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  EC2SecurityGroupRuleHits `json:"hits"`
}

type EC2SecurityGroupRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2SecurityGroupRulePaginator(filters []essdk.BoolFilter, limit *int64) (EC2SecurityGroupRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_securitygrouprule", filters, limit)
	if err != nil {
		return EC2SecurityGroupRulePaginator{}, err
	}

	p := EC2SecurityGroupRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2SecurityGroupRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2SecurityGroupRulePaginator) NextPage(ctx context.Context) ([]EC2SecurityGroupRule, error) {
	var response EC2SecurityGroupRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2SecurityGroupRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2SecurityGroupRuleFilters = map[string]string{
	"akas":                           "akas",
	"cidr_ip":                        "description.IPRange.CidrIp",
	"cidr_ipv6":                      "description.Ipv6Range.CidrIpv6",
	"from_port":                      "description.Permission.FromPort",
	"group_id":                       "description.Group.GroupId",
	"group_name":                     "description.Group.GroupName",
	"ip_protocol":                    "description.Permission.IpProtocol",
	"kaytu_account_id":               "metadata.SourceID",
	"owner_id":                       "description.Group.OwnerId",
	"pair_group_id":                  "description.UserIDGroupPair.GroupId",
	"pair_group_name":                "description.UserIDGroupPair.GroupName",
	"pair_peering_status":            "description.UserIDGroupPair.PeeringStatus",
	"pair_user_id":                   "description.UserIDGroupPair.UserId",
	"pair_vpc_id":                    "description.UserIDGroupPair.VpcId",
	"pair_vpc_peering_connection_id": "description.UserIDGroupPair.VpcPeeringConnectionId",
	"prefix_list_id":                 "description.PrefixListId.PrefixListId",
	"title":                          "title",
	"to_port":                        "description.Permission.ToPort",
	"type":                           "description.Type",
	"vpc_id":                         "description.Group.VpcId",
}

func ListEC2SecurityGroupRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2SecurityGroupRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2SecurityGroupRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2SecurityGroupRuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2SecurityGroupRuleFilters = map[string]string{
	"akas":                           "akas",
	"cidr_ip":                        "description.IPRange.CidrIp",
	"cidr_ipv6":                      "description.Ipv6Range.CidrIpv6",
	"from_port":                      "description.Permission.FromPort",
	"group_id":                       "description.Group.GroupId",
	"group_name":                     "description.Group.GroupName",
	"ip_protocol":                    "description.Permission.IpProtocol",
	"kaytu_account_id":               "metadata.SourceID",
	"owner_id":                       "description.Group.OwnerId",
	"pair_group_id":                  "description.UserIDGroupPair.GroupId",
	"pair_group_name":                "description.UserIDGroupPair.GroupName",
	"pair_peering_status":            "description.UserIDGroupPair.PeeringStatus",
	"pair_user_id":                   "description.UserIDGroupPair.UserId",
	"pair_vpc_id":                    "description.UserIDGroupPair.VpcId",
	"pair_vpc_peering_connection_id": "description.UserIDGroupPair.VpcPeeringConnectionId",
	"prefix_list_id":                 "description.PrefixListId.PrefixListId",
	"title":                          "title",
	"to_port":                        "description.Permission.ToPort",
	"type":                           "description.Type",
	"vpc_id":                         "description.Group.VpcId",
}

func GetEC2SecurityGroupRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2SecurityGroupRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2SecurityGroupRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2SecurityGroupRuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2SecurityGroupRule =============================

// ==========================  START: EC2IpamPool =============================

type EC2IpamPool struct {
	Description   aws.EC2IpamPoolDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type EC2IpamPoolHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2IpamPool   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2IpamPoolHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2IpamPoolHit  `json:"hits"`
}

type EC2IpamPoolSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  EC2IpamPoolHits `json:"hits"`
}

type EC2IpamPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2IpamPoolPaginator(filters []essdk.BoolFilter, limit *int64) (EC2IpamPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_ipampool", filters, limit)
	if err != nil {
		return EC2IpamPoolPaginator{}, err
	}

	p := EC2IpamPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2IpamPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2IpamPoolPaginator) NextPage(ctx context.Context) ([]EC2IpamPool, error) {
	var response EC2IpamPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2IpamPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2IpamPoolFilters = map[string]string{
	"akas":             "description.IpamPool.IpamPoolArn",
	"arn":              "description.IpamPool.IpamPoolArn",
	"ipam_pool_id":     "description.IpamPool.IpamPoolId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.IpamPool.IpamPoolId",
}

func ListEC2IpamPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2IpamPool")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2IpamPoolPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2IpamPoolFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2IpamPoolFilters = map[string]string{
	"akas":             "description.IpamPool.IpamPoolArn",
	"arn":              "description.IpamPool.IpamPoolArn",
	"ipam_pool_id":     "description.IpamPool.IpamPoolId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.IpamPool.IpamPoolId",
}

func GetEC2IpamPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2IpamPool")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2IpamPoolPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2IpamPoolFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2IpamPool =============================

// ==========================  START: EC2Ipam =============================

type EC2Ipam struct {
	Description   aws.EC2IpamDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type EC2IpamHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Ipam       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2IpamHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2IpamHit      `json:"hits"`
}

type EC2IpamSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  EC2IpamHits `json:"hits"`
}

type EC2IpamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2IpamPaginator(filters []essdk.BoolFilter, limit *int64) (EC2IpamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_ipam", filters, limit)
	if err != nil {
		return EC2IpamPaginator{}, err
	}

	p := EC2IpamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2IpamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2IpamPaginator) NextPage(ctx context.Context) ([]EC2Ipam, error) {
	var response EC2IpamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Ipam
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2IpamFilters = map[string]string{
	"akas":             "description.Ipam.IpamArn",
	"arn":              "description.Ipam.IpamArn",
	"ipam_id":          "description.Ipam.IpamId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Ipam.IpamId",
}

func ListEC2Ipam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Ipam")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2IpamPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2IpamFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2IpamFilters = map[string]string{
	"akas":             "description.Ipam.IpamArn",
	"arn":              "description.Ipam.IpamArn",
	"ipam_id":          "description.Ipam.IpamId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Ipam.IpamId",
}

func GetEC2Ipam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Ipam")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2IpamPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2IpamFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2Ipam =============================

// ==========================  START: EC2VPCEndpointService =============================

type EC2VPCEndpointService struct {
	Description   aws.EC2VPCEndpointServiceDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type EC2VPCEndpointServiceHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  EC2VPCEndpointService `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type EC2VPCEndpointServiceHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []EC2VPCEndpointServiceHit `json:"hits"`
}

type EC2VPCEndpointServiceSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  EC2VPCEndpointServiceHits `json:"hits"`
}

type EC2VPCEndpointServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPCEndpointServicePaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPCEndpointServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpcendpointservice", filters, limit)
	if err != nil {
		return EC2VPCEndpointServicePaginator{}, err
	}

	p := EC2VPCEndpointServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPCEndpointServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPCEndpointServicePaginator) NextPage(ctx context.Context) ([]EC2VPCEndpointService, error) {
	var response EC2VPCEndpointServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPCEndpointService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPCEndpointServiceFilters = map[string]string{
	"acceptance_required":                 "description.VpcEndpointService.AcceptanceRequired",
	"akas":                                "aRN",
	"availability_zones":                  "description.VpcEndpointService.AvailabilityZones",
	"base_endpoint_dns_names":             "description.VpcEndpointService.BaseEndpointDnsNames",
	"kaytu_account_id":                    "metadata.SourceID",
	"manages_vpc_endpoints":               "description.VpcEndpointService.ManagesVpcEndpoints",
	"owner":                               "description.VpcEndpointService.Owner",
	"private_dns_name":                    "description.VpcEndpointService.PrivateDnsName",
	"private_dns_name_verification_state": "description.VpcEndpointService.PrivateDnsNameVerificationState",
	"service_id":                          "description.VpcEndpointService.ServiceId",
	"service_name":                        "description.VpcEndpointService.ServiceName",
	"service_type":                        "description.VpcEndpointService.ServiceType",
	"tags_src":                            "description.VpcEndpointService.Tags",
	"title":                               "description.VpcEndpointService.ServiceName",
	"vpc_endpoint_policy_supported":       "description.VpcEndpointService.VpcEndpointPolicySupported",
}

func ListEC2VPCEndpointService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPCEndpointService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2VPCEndpointServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2VPCEndpointServiceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2VPCEndpointServiceFilters = map[string]string{
	"acceptance_required":                 "description.VpcEndpointService.AcceptanceRequired",
	"akas":                                "aRN",
	"availability_zones":                  "description.VpcEndpointService.AvailabilityZones",
	"base_endpoint_dns_names":             "description.VpcEndpointService.BaseEndpointDnsNames",
	"kaytu_account_id":                    "metadata.SourceID",
	"manages_vpc_endpoints":               "description.VpcEndpointService.ManagesVpcEndpoints",
	"owner":                               "description.VpcEndpointService.Owner",
	"private_dns_name":                    "description.VpcEndpointService.PrivateDnsName",
	"private_dns_name_verification_state": "description.VpcEndpointService.PrivateDnsNameVerificationState",
	"service_id":                          "description.VpcEndpointService.ServiceId",
	"service_name":                        "description.VPCEndpoint.ServiceName",
	"service_type":                        "description.VpcEndpointService.ServiceType",
	"tags_src":                            "description.VpcEndpointService.Tags",
	"title":                               "description.VpcEndpointService.ServiceName",
	"vpc_endpoint_policy_supported":       "description.VpcEndpointService.VpcEndpointPolicySupported",
}

func GetEC2VPCEndpointService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPCEndpointService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2VPCEndpointServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2VPCEndpointServiceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2VPCEndpointService =============================

// ==========================  START: EC2InstanceAvailability =============================

type EC2InstanceAvailability struct {
	Description   aws.EC2InstanceAvailabilityDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type EC2InstanceAvailabilityHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  EC2InstanceAvailability `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type EC2InstanceAvailabilityHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []EC2InstanceAvailabilityHit `json:"hits"`
}

type EC2InstanceAvailabilitySearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  EC2InstanceAvailabilityHits `json:"hits"`
}

type EC2InstanceAvailabilityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InstanceAvailabilityPaginator(filters []essdk.BoolFilter, limit *int64) (EC2InstanceAvailabilityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_instanceavailability", filters, limit)
	if err != nil {
		return EC2InstanceAvailabilityPaginator{}, err
	}

	p := EC2InstanceAvailabilityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InstanceAvailabilityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InstanceAvailabilityPaginator) NextPage(ctx context.Context) ([]EC2InstanceAvailability, error) {
	var response EC2InstanceAvailabilitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2InstanceAvailability
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InstanceAvailabilityFilters = map[string]string{
	"akas":             "aRN",
	"instance_type":    "description.InstanceAvailability.InstanceType",
	"kaytu_account_id": "metadata.SourceID",
	"location":         "description.InstanceAvailability.Location",
	"location_type":    "description.InstanceAvailability.LocationType",
	"title":            "description.InstanceAvailability.InstanceType",
}

func ListEC2InstanceAvailability(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2InstanceAvailability")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2InstanceAvailabilityPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2InstanceAvailabilityFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2InstanceAvailabilityFilters = map[string]string{
	"akas":             "aRN",
	"instance_type":    "description.InstanceAvailability.InstanceType",
	"kaytu_account_id": "metadata.SourceID",
	"location":         "description.InstanceAvailability.Location",
	"location_type":    "description.InstanceAvailability.LocationType",
	"title":            "description.InstanceAvailability.InstanceType",
}

func GetEC2InstanceAvailability(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2InstanceAvailability")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2InstanceAvailabilityPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2InstanceAvailabilityFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2InstanceAvailability =============================

// ==========================  START: EC2InstanceType =============================

type EC2InstanceType struct {
	Description   aws.EC2InstanceTypeDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type EC2InstanceTypeHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EC2InstanceType `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EC2InstanceTypeHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EC2InstanceTypeHit `json:"hits"`
}

type EC2InstanceTypeSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EC2InstanceTypeHits `json:"hits"`
}

type EC2InstanceTypePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InstanceTypePaginator(filters []essdk.BoolFilter, limit *int64) (EC2InstanceTypePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_instancetype", filters, limit)
	if err != nil {
		return EC2InstanceTypePaginator{}, err
	}

	p := EC2InstanceTypePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InstanceTypePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InstanceTypePaginator) NextPage(ctx context.Context) ([]EC2InstanceType, error) {
	var response EC2InstanceTypeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2InstanceType
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InstanceTypeFilters = map[string]string{
	"akas":                            "aRN",
	"auto_recovery_supported":         "description.InstanceType.AutoRecoverySupported",
	"bare_metal":                      "description.InstanceType.BareMetal",
	"burstable_performance_supported": "description.InstanceType.BurstablePerformanceSupported",
	"current_generation":              "description.InstanceType.CurrentGeneration",
	"dedicated_hosts_supported":       "description.InstanceType.DedicatedHostsSupported",
	"ebs_info":                        "description.InstanceType.EbsInfo",
	"free_tier_eligible":              "description.InstanceType.FreeTierEligible",
	"gpu_info":                        "description.InstanceType.GpuInfo",
	"hibernation_supported":           "description.InstanceType.HibernationSupported",
	"hypervisor":                      "description.InstanceType.Hypervisor",
	"instance_storage_supported":      "description.InstanceType.InstanceStorageSupported",
	"instance_type":                   "description.InstanceType.InstanceType",
	"kaytu_account_id":                "metadata.SourceID",
	"memory_info":                     "description.InstanceType.MemoryInfo",
	"network_info":                    "description.InstanceType.NetworkInfo",
	"placement_group_info":            "description.InstanceType.PlacementGroupInfo",
	"processor_info":                  "description.InstanceType.ProcessorInfo",
	"supported_root_device_types":     "description.InstanceType.SupportedRootDeviceTypes",
	"supported_usage_classes":         "description.InstanceType.SupportedUsageClasses",
	"supported_virtualization_types":  "description.InstanceType.SupportedVirtualizationTypes",
	"title":                           "description.InstanceType.InstanceType",
	"v_cpu_info":                      "description.InstanceType.VCpuInfo",
}

func ListEC2InstanceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2InstanceType")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2InstanceTypePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2InstanceTypeFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2InstanceTypeFilters = map[string]string{
	"akas":                            "aRN",
	"auto_recovery_supported":         "description.InstanceType.AutoRecoverySupported",
	"bare_metal":                      "description.InstanceType.BareMetal",
	"burstable_performance_supported": "description.InstanceType.BurstablePerformanceSupported",
	"current_generation":              "description.InstanceType.CurrentGeneration",
	"dedicated_hosts_supported":       "description.InstanceType.DedicatedHostsSupported",
	"ebs_info":                        "description.InstanceType.EbsInfo",
	"free_tier_eligible":              "description.InstanceType.FreeTierEligible",
	"gpu_info":                        "description.InstanceType.GpuInfo",
	"hibernation_supported":           "description.InstanceType.HibernationSupported",
	"hypervisor":                      "description.InstanceType.Hypervisor",
	"instance_storage_supported":      "description.InstanceType.InstanceStorageSupported",
	"instance_type":                   "description.InstanceType.InstanceType",
	"kaytu_account_id":                "metadata.SourceID",
	"memory_info":                     "description.InstanceType.MemoryInfo",
	"network_info":                    "description.InstanceType.NetworkInfo",
	"placement_group_info":            "description.InstanceType.PlacementGroupInfo",
	"processor_info":                  "description.InstanceType.ProcessorInfo",
	"supported_root_device_types":     "description.InstanceType.SupportedRootDeviceTypes",
	"supported_usage_classes":         "description.InstanceType.SupportedUsageClasses",
	"supported_virtualization_types":  "description.InstanceType.SupportedVirtualizationTypes",
	"title":                           "description.InstanceType.InstanceType",
	"v_cpu_info":                      "description.InstanceType.VCpuInfo",
}

func GetEC2InstanceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2InstanceType")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2InstanceTypePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2InstanceTypeFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2InstanceType =============================

// ==========================  START: EC2ManagedPrefixList =============================

type EC2ManagedPrefixList struct {
	Description   aws.EC2ManagedPrefixListDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type EC2ManagedPrefixListHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  EC2ManagedPrefixList `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type EC2ManagedPrefixListHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []EC2ManagedPrefixListHit `json:"hits"`
}

type EC2ManagedPrefixListSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  EC2ManagedPrefixListHits `json:"hits"`
}

type EC2ManagedPrefixListPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2ManagedPrefixListPaginator(filters []essdk.BoolFilter, limit *int64) (EC2ManagedPrefixListPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_managedprefixlist", filters, limit)
	if err != nil {
		return EC2ManagedPrefixListPaginator{}, err
	}

	p := EC2ManagedPrefixListPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2ManagedPrefixListPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2ManagedPrefixListPaginator) NextPage(ctx context.Context) ([]EC2ManagedPrefixList, error) {
	var response EC2ManagedPrefixListSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2ManagedPrefixList
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2ManagedPrefixListFilters = map[string]string{
	"address_family":   "description.ManagedPrefixList.AddressFamily",
	"akas":             "description.ManagedPrefixList.PrefixListArn",
	"arn":              "description.ManagedPrefixList.PrefixListArn",
	"id":               "description.ManagedPrefixList.PrefixListId",
	"kaytu_account_id": "metadata.SourceID",
	"max_entries":      "description.ManagedPrefixList.MaxEntries",
	"name":             "description.ManagedPrefixList.PrefixListName",
	"owner_id":         "description.ManagedPrefixList.OwnerId",
	"state":            "description.ManagedPrefixList.State",
	"state_message":    "description.ManagedPrefixList.StateMessage",
	"tags_src":         "description.ManagedPrefixList.Tags",
	"title":            "description.ManagedPrefixList.PrefixListName",
	"version":          "description.ManagedPrefixList.Version",
}

func ListEC2ManagedPrefixList(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2ManagedPrefixList")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2ManagedPrefixListPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2ManagedPrefixListFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2ManagedPrefixListFilters = map[string]string{
	"address_family":   "description.ManagedPrefixList.AddressFamily",
	"akas":             "description.ManagedPrefixList.PrefixListArn",
	"arn":              "description.ManagedPrefixList.PrefixListArn",
	"id":               "description.ManagedPrefixList.PrefixListId",
	"kaytu_account_id": "metadata.SourceID",
	"max_entries":      "description.ManagedPrefixList.MaxEntries",
	"name":             "description.ManagedPrefixList.PrefixListName",
	"owner_id":         "description.ManagedPrefixList.OwnerId",
	"state":            "description.ManagedPrefixList.State",
	"state_message":    "description.ManagedPrefixList.StateMessage",
	"tags_src":         "description.ManagedPrefixList.Tags",
	"title":            "description.ManagedPrefixList.PrefixListName",
	"version":          "description.ManagedPrefixList.Version",
}

func GetEC2ManagedPrefixList(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2ManagedPrefixList")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2ManagedPrefixListPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2ManagedPrefixListFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2ManagedPrefixList =============================

// ==========================  START: EC2TransitGatewayRoute =============================

type EC2TransitGatewayRoute struct {
	Description   aws.EC2TransitGatewayRouteDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type EC2TransitGatewayRouteHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  EC2TransitGatewayRoute `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type EC2TransitGatewayRouteHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []EC2TransitGatewayRouteHit `json:"hits"`
}

type EC2TransitGatewayRouteSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  EC2TransitGatewayRouteHits `json:"hits"`
}

type EC2TransitGatewayRoutePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayRoutePaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayRoutePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgatewayroute", filters, limit)
	if err != nil {
		return EC2TransitGatewayRoutePaginator{}, err
	}

	p := EC2TransitGatewayRoutePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayRoutePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayRoutePaginator) NextPage(ctx context.Context) ([]EC2TransitGatewayRoute, error) {
	var response EC2TransitGatewayRouteSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGatewayRoute
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayRouteFilters = map[string]string{
	"akas":                           "aRN",
	"destination_cidr_block":         "description.TransitGatewayRoute.DestinationCidrBlock",
	"kaytu_account_id":               "metadata.SourceID",
	"prefix_list_id":                 "description.TransitGatewayRoute.PrefixListId",
	"state":                          "description.TransitGatewayRoute.State",
	"title":                          "description.TransitGatewayRoute.DestinationCidrBlock",
	"transit_gateway_attachments":    "description.TransitGatewayRoute.TransitGatewayAttachments",
	"transit_gateway_route_table_id": "description.TransitGatewayRouteTableId",
	"type":                           "description.TransitGatewayRoute.Type",
}

func ListEC2TransitGatewayRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGatewayRoute")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2TransitGatewayRoutePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2TransitGatewayRouteFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2TransitGatewayRouteFilters = map[string]string{
	"akas":                           "aRN",
	"destination_cidr_block":         "description.TransitGatewayRoute.DestinationCidrBlock",
	"kaytu_account_id":               "metadata.SourceID",
	"prefix_list_id":                 "description.TransitGatewayRoute.PrefixListId",
	"state":                          "description.TransitGatewayRoute.State",
	"title":                          "description.TransitGatewayRoute.DestinationCidrBlock",
	"transit_gateway_attachments":    "description.TransitGatewayRoute.TransitGatewayAttachments",
	"transit_gateway_route_table_id": "description.TransitGatewayRouteTableId",
	"type":                           "description.TransitGatewayRoute.Type",
}

func GetEC2TransitGatewayRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGatewayRoute")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayRoutePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2TransitGatewayRouteFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2TransitGatewayRoute =============================

// ==========================  START: EC2TransitGatewayAttachment =============================

type EC2TransitGatewayAttachment struct {
	Description   aws.EC2TransitGatewayAttachmentDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type EC2TransitGatewayAttachmentHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  EC2TransitGatewayAttachment `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type EC2TransitGatewayAttachmentHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []EC2TransitGatewayAttachmentHit `json:"hits"`
}

type EC2TransitGatewayAttachmentSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  EC2TransitGatewayAttachmentHits `json:"hits"`
}

type EC2TransitGatewayAttachmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayAttachmentPaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayAttachmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgatewayattachment", filters, limit)
	if err != nil {
		return EC2TransitGatewayAttachmentPaginator{}, err
	}

	p := EC2TransitGatewayAttachmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayAttachmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayAttachmentPaginator) NextPage(ctx context.Context) ([]EC2TransitGatewayAttachment, error) {
	var response EC2TransitGatewayAttachmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGatewayAttachment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayAttachmentFilters = map[string]string{
	"akas":              "aRN",
	"association_state": "description.TransitGatewayAttachment.Association.State",
	"association_transit_gateway_route_table_id": "description.TransitGatewayAttachment.Association.TransitGatewayRouteTableId",
	"creation_time":                 "description.TransitGatewayAttachment.CreationTime",
	"kaytu_account_id":              "metadata.SourceID",
	"resource_id":                   "description.TransitGatewayAttachment.ResourceId",
	"resource_owner_id":             "description.TransitGatewayAttachment.ResourceOwnerId",
	"resource_type":                 "description.TransitGatewayAttachment.ResourceType",
	"state":                         "description.TransitGatewayAttachment.State",
	"tags_src":                      "description.TransitGatewayAttachment.Tags",
	"transit_gateway_attachment_id": "description.TransitGatewayAttachment.TransitGatewayAttachmentId",
	"transit_gateway_id":            "description.TransitGatewayAttachment.TransitGatewayId",
	"transit_gateway_owner_id":      "description.TransitGatewayAttachment.TransitGatewayOwnerId",
}

func ListEC2TransitGatewayAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGatewayAttachment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2TransitGatewayAttachmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2TransitGatewayAttachmentFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2TransitGatewayAttachmentFilters = map[string]string{
	"akas":              "aRN",
	"association_state": "description.TransitGatewayAttachment.Association.State",
	"association_transit_gateway_route_table_id": "description.TransitGatewayAttachment.Association.TransitGatewayRouteTableId",
	"creation_time":                 "description.TransitGatewayAttachment.CreationTime",
	"kaytu_account_id":              "metadata.SourceID",
	"resource_id":                   "description.TransitGatewayAttachment.ResourceId",
	"resource_owner_id":             "description.TransitGatewayAttachment.ResourceOwnerId",
	"resource_type":                 "description.TransitGatewayAttachment.ResourceType",
	"state":                         "description.TransitGatewayAttachment.State",
	"tags_src":                      "description.TransitGatewayAttachment.Tags",
	"transit_gateway_attachment_id": "description.TransitGatewayAttachment.TransitGatewayAttachmentId",
	"transit_gateway_id":            "description.TransitGatewayAttachment.TransitGatewayId",
	"transit_gateway_owner_id":      "description.TransitGatewayAttachment.TransitGatewayOwnerId",
}

func GetEC2TransitGatewayAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGatewayAttachment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayAttachmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2TransitGatewayAttachmentFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2TransitGatewayAttachment =============================

// ==========================  START: EC2LaunchTemplate =============================

type EC2LaunchTemplate struct {
	Description   aws.EC2LaunchTemplateDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2LaunchTemplateHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2LaunchTemplate `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2LaunchTemplateHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2LaunchTemplateHit `json:"hits"`
}

type EC2LaunchTemplateSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2LaunchTemplateHits `json:"hits"`
}

type EC2LaunchTemplatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2LaunchTemplatePaginator(filters []essdk.BoolFilter, limit *int64) (EC2LaunchTemplatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_launchtemplate", filters, limit)
	if err != nil {
		return EC2LaunchTemplatePaginator{}, err
	}

	p := EC2LaunchTemplatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2LaunchTemplatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2LaunchTemplatePaginator) NextPage(ctx context.Context) ([]EC2LaunchTemplate, error) {
	var response EC2LaunchTemplateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2LaunchTemplate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2LaunchTemplateFilters = map[string]string{
	"akas":  "aRN",
	"arn":   "aRN",
	"id":    "description.LaunchTemplate.LaunchTemplateId",
	"name":  "description.LaunchTemplateName",
	"title": "description.LaunchTemplate.Name",
}

func ListEC2LaunchTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2LaunchTemplate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEC2LaunchTemplatePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEC2LaunchTemplateFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEC2LaunchTemplateFilters = map[string]string{
	"akas":  "aRN",
	"arn":   "aRN",
	"id":    "description.LaunchTemplate.LaunchTemplateId",
	"name":  "description.LaunchTemplateName",
	"title": "description.LaunchTemplate.Name",
}

func GetEC2LaunchTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2LaunchTemplate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEC2LaunchTemplatePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEC2LaunchTemplateFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EC2LaunchTemplate =============================

// ==========================  START: ElasticLoadBalancingV2SslPolicy =============================

type ElasticLoadBalancingV2SslPolicy struct {
	Description   aws.ElasticLoadBalancingV2SslPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type ElasticLoadBalancingV2SslPolicyHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2SslPolicy `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type ElasticLoadBalancingV2SslPolicyHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []ElasticLoadBalancingV2SslPolicyHit `json:"hits"`
}

type ElasticLoadBalancingV2SslPolicySearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  ElasticLoadBalancingV2SslPolicyHits `json:"hits"`
}

type ElasticLoadBalancingV2SslPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2SslPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2SslPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_sslpolicy", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2SslPolicyPaginator{}, err
	}

	p := ElasticLoadBalancingV2SslPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2SslPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2SslPolicyPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2SslPolicy, error) {
	var response ElasticLoadBalancingV2SslPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2SslPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2SslPolicyFilters = map[string]string{
	"akas":             "aRN",
	"ciphers":          "description.SslPolicy.Ciphers",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.SslPolicy.Name",
	"ssl_protocols":    "description.SslPolicy.SslProtocols",
	"title":            "description.SslPolicy.Name",
}

func ListElasticLoadBalancingV2SslPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2SslPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticLoadBalancingV2SslPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticLoadBalancingV2SslPolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticLoadBalancingV2SslPolicyFilters = map[string]string{
	"akas":             "aRN",
	"ciphers":          "description.SslPolicy.Ciphers",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.SslPolicy.Name",
	"region":           "metadata.Region",
	"ssl_protocols":    "description.SslPolicy.SslProtocols",
	"title":            "description.SslPolicy.Name",
}

func GetElasticLoadBalancingV2SslPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2SslPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2SslPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticLoadBalancingV2SslPolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2SslPolicy =============================

// ==========================  START: ElasticLoadBalancingV2TargetGroup =============================

type ElasticLoadBalancingV2TargetGroup struct {
	Description   aws.ElasticLoadBalancingV2TargetGroupDescription `json:"description"`
	Metadata      aws.Metadata                                     `json:"metadata"`
	ResourceJobID int                                              `json:"resource_job_id"`
	SourceJobID   int                                              `json:"source_job_id"`
	ResourceType  string                                           `json:"resource_type"`
	SourceType    string                                           `json:"source_type"`
	ID            string                                           `json:"id"`
	ARN           string                                           `json:"arn"`
	SourceID      string                                           `json:"source_id"`
}

type ElasticLoadBalancingV2TargetGroupHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2TargetGroup `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type ElasticLoadBalancingV2TargetGroupHits struct {
	Total essdk.SearchTotal                      `json:"total"`
	Hits  []ElasticLoadBalancingV2TargetGroupHit `json:"hits"`
}

type ElasticLoadBalancingV2TargetGroupSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  ElasticLoadBalancingV2TargetGroupHits `json:"hits"`
}

type ElasticLoadBalancingV2TargetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2TargetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2TargetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_targetgroup", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2TargetGroupPaginator{}, err
	}

	p := ElasticLoadBalancingV2TargetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2TargetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2TargetGroupPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2TargetGroup, error) {
	var response ElasticLoadBalancingV2TargetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2TargetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2TargetGroupFilters = map[string]string{
	"akas":              "description.TargetGroup.TargetGroupArn",
	"arn":               "description.TargetGroup.TargetGroupArn",
	"kaytu_account_id":  "metadata.SourceID",
	"target_group_name": "description.TargetGroup.TargetGroupName",
	"title":             "description.TargetGroup.TargetGroupName",
}

func ListElasticLoadBalancingV2TargetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2TargetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticLoadBalancingV2TargetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticLoadBalancingV2TargetGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticLoadBalancingV2TargetGroupFilters = map[string]string{
	"akas":              "description.TargetGroup.TargetGroupArn",
	"arn":               "description.TargetGroup.TargetGroupArn",
	"kaytu_account_id":  "metadata.SourceID",
	"target_group_arn":  "description.TargetGroup.TargetGroupArn",
	"target_group_name": "description.TargetGroup.TargetGroupName",
	"title":             "description.TargetGroup.TargetGroupName",
}

func GetElasticLoadBalancingV2TargetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2TargetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2TargetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticLoadBalancingV2TargetGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2TargetGroup =============================

// ==========================  START: ElasticLoadBalancingV2LoadBalancer =============================

type ElasticLoadBalancingV2LoadBalancer struct {
	Description   aws.ElasticLoadBalancingV2LoadBalancerDescription `json:"description"`
	Metadata      aws.Metadata                                      `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type ElasticLoadBalancingV2LoadBalancerHit struct {
	ID      string                             `json:"_id"`
	Score   float64                            `json:"_score"`
	Index   string                             `json:"_index"`
	Type    string                             `json:"_type"`
	Version int64                              `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2LoadBalancer `json:"_source"`
	Sort    []interface{}                      `json:"sort"`
}

type ElasticLoadBalancingV2LoadBalancerHits struct {
	Total essdk.SearchTotal                       `json:"total"`
	Hits  []ElasticLoadBalancingV2LoadBalancerHit `json:"hits"`
}

type ElasticLoadBalancingV2LoadBalancerSearchResponse struct {
	PitID string                                 `json:"pit_id"`
	Hits  ElasticLoadBalancingV2LoadBalancerHits `json:"hits"`
}

type ElasticLoadBalancingV2LoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2LoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2LoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_loadbalancer", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2LoadBalancerPaginator{}, err
	}

	p := ElasticLoadBalancingV2LoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2LoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2LoadBalancerPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2LoadBalancer, error) {
	var response ElasticLoadBalancingV2LoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2LoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2LoadBalancerFilters = map[string]string{
	"akas":                     "description.LoadBalancer.LoadBalancerArn",
	"arn":                      "description.LoadBalancer.LoadBalancerArn",
	"availability_zones":       "description.LoadBalancer.AvailabilityZones",
	"canonical_hosted_zone_id": "description.LoadBalancer.CanonicalHostedZoneId",
	"created_time":             "description.LoadBalancer.CreatedTime",
	"customer_owned_ipv4_pool": "description.LoadBalancer.CustomerOwnedIpv4Pool",
	"dns_name":                 "description.LoadBalancer.DNSName",
	"ip_address_type":          "description.LoadBalancer.IpAddressType",
	"kaytu_account_id":         "metadata.SourceID",
	"load_balancer_attributes": "description.Attributes",
	"name":                     "description.LoadBalancer.LoadBalancerName",
	"scheme":                   "description.LoadBalancer.Scheme",
	"security_groups":          "description.LoadBalancer.SecurityGroups",
	"state_code":               "description.LoadBalancer.State.Code",
	"state_reason":             "description.LoadBalancer.State.Reason",
	"tags_src":                 "description.Tags",
	"title":                    "description.LoadBalancer.LoadBalancerName",
	"type":                     "description.LoadBalancer.Type",
	"vpc_id":                   "description.LoadBalancer.VpcId",
}

func ListElasticLoadBalancingV2LoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2LoadBalancer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticLoadBalancingV2LoadBalancerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticLoadBalancingV2LoadBalancerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticLoadBalancingV2LoadBalancerFilters = map[string]string{
	"akas":                     "description.LoadBalancer.LoadBalancerArn",
	"arn":                      "description.LoadBalancer.LoadBalancerArn",
	"availability_zones":       "description.LoadBalancer.AvailabilityZones",
	"canonical_hosted_zone_id": "description.LoadBalancer.CanonicalHostedZoneId",
	"created_time":             "description.LoadBalancer.CreatedTime",
	"customer_owned_ipv4_pool": "description.LoadBalancer.CustomerOwnedIpv4Pool",
	"dns_name":                 "description.LoadBalancer.DNSName",
	"ip_address_type":          "description.LoadBalancer.IpAddressType",
	"kaytu_account_id":         "metadata.SourceID",
	"load_balancer_attributes": "description.Attributes",
	"name":                     "description.LoadBalancer.LoadBalancerName",
	"scheme":                   "description.LoadBalancer.Scheme",
	"security_groups":          "description.LoadBalancer.SecurityGroups",
	"state_code":               "description.LoadBalancer.State.Code",
	"state_reason":             "description.LoadBalancer.State.Reason",
	"tags_src":                 "description.Tags",
	"title":                    "description.LoadBalancer.LoadBalancerName",
	"type":                     "description.LoadBalancer.Type",
	"vpc_id":                   "description.LoadBalancer.VpcId",
}

func GetElasticLoadBalancingV2LoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2LoadBalancer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2LoadBalancerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticLoadBalancingV2LoadBalancerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2LoadBalancer =============================

// ==========================  START: ElasticLoadBalancingLoadBalancer =============================

type ElasticLoadBalancingLoadBalancer struct {
	Description   aws.ElasticLoadBalancingLoadBalancerDescription `json:"description"`
	Metadata      aws.Metadata                                    `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type ElasticLoadBalancingLoadBalancerHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  ElasticLoadBalancingLoadBalancer `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type ElasticLoadBalancingLoadBalancerHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []ElasticLoadBalancingLoadBalancerHit `json:"hits"`
}

type ElasticLoadBalancingLoadBalancerSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  ElasticLoadBalancingLoadBalancerHits `json:"hits"`
}

type ElasticLoadBalancingLoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingLoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingLoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancing_loadbalancer", filters, limit)
	if err != nil {
		return ElasticLoadBalancingLoadBalancerPaginator{}, err
	}

	p := ElasticLoadBalancingLoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingLoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingLoadBalancerPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingLoadBalancer, error) {
	var response ElasticLoadBalancingLoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingLoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingLoadBalancerFilters = map[string]string{
	"access_log_emit_interval":          "description.Attributes.AccessLog.EmitInterval",
	"access_log_enabled":                "description.Attributes.AccessLog.Enabled",
	"access_log_s3_bucket_name":         "description.Attributes.AccessLog.S3BucketName",
	"access_log_s3_bucket_prefix":       "description.Attributes.AccessLog.S3BucketPrefix",
	"additional_attributes":             "description.Attributes.AdditionalAttributes",
	"app_cookie_stickiness_policies":    "description.LoadBalancer.Policies.AppCookieStickinessPolicies",
	"availability_zones":                "description.LoadBalancer.AvailabilityZones",
	"backend_server_descriptions":       "description.LoadBalancer.BackendServerDescriptions",
	"canonical_hosted_zone_name":        "description.LoadBalancer.CanonicalHostedZoneName",
	"canonical_hosted_zone_name_id":     "description.LoadBalancer.CanonicalHostedZoneNameID",
	"connection_draining_enabled":       "description.Attributes.ConnectionDraining.Enabled",
	"connection_draining_timeout":       "description.Attributes.ConnectionDraining.Timeout",
	"connection_settings_idle_timeout":  "description.Attributes.ConnectionSettings.IdleTimeout",
	"created_time":                      "description.LoadBalancer.CreatedTime",
	"cross_zone_load_balancing_enabled": "description.Attributes.CrossZoneLoadBalancing.Enabled",
	"dns_name":                          "description.LoadBalancer.DNSName",
	"health_check_interval":             "description.LoadBalancer.HealthCheck.Interval",
	"health_check_target":               "description.LoadBalancer.HealthCheck.Target",
	"health_check_timeout":              "description.LoadBalancer.HealthCheck.Timeout",
	"healthy_threshold":                 "description.LoadBalancer.HealthCheck.HealthyThreshold",
	"instances":                         "description.LoadBalancer.Instances",
	"kaytu_account_id":                  "metadata.SourceID",
	"lb_cookie_stickiness_policies":     "description.LoadBalancer.Policies.LBCookieStickinessPolicies",
	"listener_descriptions":             "description.LoadBalancer.ListenerDescriptions",
	"name":                              "description.LoadBalancer.LoadBalancerName",
	"other_policies":                    "description.LoadBalancer.Policies.OtherPolicies",
	"scheme":                            "description.LoadBalancer.Scheme",
	"security_groups":                   "description.LoadBalancer.SecurityGroups",
	"source_security_group_name":        "description.LoadBalancer.SourceSecurityGroup.GroupName",
	"source_security_group_owner_alias": "description.LoadBalancer.SourceSecurityGroup.OwnerAlias",
	"subnets":                           "description.LoadBalancer.Subnets",
	"tags_src":                          "description.Tags",
	"title":                             "description.LoadBalancer.LoadBalancerName",
	"unhealthy_threshold":               "description.LoadBalancer.HealthCheck.UnhealthyThreshold",
	"vpc_id":                            "description.LoadBalancer.VPCId",
}

func ListElasticLoadBalancingLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingLoadBalancer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticLoadBalancingLoadBalancerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticLoadBalancingLoadBalancerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticLoadBalancingLoadBalancerFilters = map[string]string{
	"access_log_emit_interval":          "description.Attributes.AccessLog.EmitInterval",
	"access_log_enabled":                "description.Attributes.AccessLog.Enabled",
	"access_log_s3_bucket_name":         "description.Attributes.AccessLog.S3BucketName",
	"access_log_s3_bucket_prefix":       "description.Attributes.AccessLog.S3BucketPrefix",
	"additional_attributes":             "description.Attributes.AdditionalAttributes",
	"app_cookie_stickiness_policies":    "description.LoadBalancer.Policies.AppCookieStickinessPolicies",
	"availability_zones":                "description.LoadBalancer.AvailabilityZones",
	"backend_server_descriptions":       "description.LoadBalancer.BackendServerDescriptions",
	"canonical_hosted_zone_name":        "description.LoadBalancer.CanonicalHostedZoneName",
	"canonical_hosted_zone_name_id":     "description.LoadBalancer.CanonicalHostedZoneNameID",
	"connection_draining_enabled":       "description.Attributes.ConnectionDraining.Enabled",
	"connection_draining_timeout":       "description.Attributes.ConnectionDraining.Timeout",
	"connection_settings_idle_timeout":  "description.Attributes.ConnectionSettings.IdleTimeout",
	"created_time":                      "description.LoadBalancer.CreatedTime",
	"cross_zone_load_balancing_enabled": "description.Attributes.CrossZoneLoadBalancing.Enabled",
	"dns_name":                          "description.LoadBalancer.DNSName",
	"health_check_interval":             "description.LoadBalancer.HealthCheck.Interval",
	"health_check_target":               "description.LoadBalancer.HealthCheck.Target",
	"health_check_timeout":              "description.LoadBalancer.HealthCheck.Timeout",
	"healthy_threshold":                 "description.LoadBalancer.HealthCheck.HealthyThreshold",
	"instances":                         "description.LoadBalancer.Instances",
	"kaytu_account_id":                  "metadata.SourceID",
	"lb_cookie_stickiness_policies":     "description.LoadBalancer.Policies.LBCookieStickinessPolicies",
	"listener_descriptions":             "description.LoadBalancer.ListenerDescriptions",
	"name":                              "description.LoadBalancer.LoadBalancerName",
	"other_policies":                    "description.LoadBalancer.Policies.OtherPolicies",
	"scheme":                            "description.LoadBalancer.Scheme",
	"security_groups":                   "description.LoadBalancer.SecurityGroups",
	"source_security_group_name":        "description.LoadBalancer.SourceSecurityGroup.GroupName",
	"source_security_group_owner_alias": "description.LoadBalancer.SourceSecurityGroup.OwnerAlias",
	"subnets":                           "description.LoadBalancer.Subnets",
	"tags_src":                          "description.Tags",
	"title":                             "description.LoadBalancer.LoadBalancerName",
	"unhealthy_threshold":               "description.LoadBalancer.HealthCheck.UnhealthyThreshold",
	"vpc_id":                            "description.LoadBalancer.VPCId",
}

func GetElasticLoadBalancingLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingLoadBalancer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingLoadBalancerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticLoadBalancingLoadBalancerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingLoadBalancer =============================

// ==========================  START: ElasticLoadBalancingV2Listener =============================

type ElasticLoadBalancingV2Listener struct {
	Description   aws.ElasticLoadBalancingV2ListenerDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type ElasticLoadBalancingV2ListenerHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2Listener `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type ElasticLoadBalancingV2ListenerHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []ElasticLoadBalancingV2ListenerHit `json:"hits"`
}

type ElasticLoadBalancingV2ListenerSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  ElasticLoadBalancingV2ListenerHits `json:"hits"`
}

type ElasticLoadBalancingV2ListenerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2ListenerPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2ListenerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_listener", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2ListenerPaginator{}, err
	}

	p := ElasticLoadBalancingV2ListenerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2ListenerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2ListenerPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2Listener, error) {
	var response ElasticLoadBalancingV2ListenerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2Listener
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2ListenerFilters = map[string]string{
	"akas":              "description.Listener.ListenerArn",
	"alpn_policy":       "description.Listener.AlpnPolicy",
	"arn":               "description.Listener.ListenerArn",
	"certificates":      "description.Listener.Certificates",
	"default_actions":   "description.Listener.DefaultActions",
	"kaytu_account_id":  "metadata.SourceID",
	"load_balancer_arn": "description.Listener.LoadBalancerArn",
	"port":              "description.Listener.Port",
	"protocol":          "description.Listener.Protocol",
	"ssl_policy":        "description.Listener.SslPolicy",
}

func ListElasticLoadBalancingV2Listener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2Listener")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticLoadBalancingV2ListenerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticLoadBalancingV2ListenerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticLoadBalancingV2ListenerFilters = map[string]string{
	"akas":              "description.Listener.ListenerArn",
	"alpn_policy":       "description.Listener.AlpnPolicy",
	"arn":               "description.Listener.ListenerArn",
	"certificates":      "description.Listener.Certificates",
	"default_actions":   "description.Listener.DefaultActions",
	"kaytu_account_id":  "metadata.SourceID",
	"load_balancer_arn": "description.Listener.LoadBalancerArn",
	"port":              "description.Listener.Port",
	"protocol":          "description.Listener.Protocol",
	"ssl_policy":        "description.Listener.SslPolicy",
}

func GetElasticLoadBalancingV2Listener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2Listener")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2ListenerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticLoadBalancingV2ListenerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2Listener =============================

// ==========================  START: ElasticLoadBalancingV2Rule =============================

type ElasticLoadBalancingV2Rule struct {
	Description   aws.ElasticLoadBalancingV2RuleDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type ElasticLoadBalancingV2RuleHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2Rule `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type ElasticLoadBalancingV2RuleHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []ElasticLoadBalancingV2RuleHit `json:"hits"`
}

type ElasticLoadBalancingV2RuleSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  ElasticLoadBalancingV2RuleHits `json:"hits"`
}

type ElasticLoadBalancingV2RulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2RulePaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2RulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_listenerrule", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2RulePaginator{}, err
	}

	p := ElasticLoadBalancingV2RulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2RulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2RulePaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2Rule, error) {
	var response ElasticLoadBalancingV2RuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2Rule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2RuleFilters = map[string]string{
	"akas":             "description.Rule.RuleArn",
	"arn":              "description.Rule.RuleArn",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Rule.RuleArn",
}

func ListElasticLoadBalancingV2Rule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2Rule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewElasticLoadBalancingV2RulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listElasticLoadBalancingV2RuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getElasticLoadBalancingV2RuleFilters = map[string]string{
	"akas":             "description.Rule.RuleArn",
	"arn":              "description.Rule.RuleArn",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Rule.RuleArn",
}

func GetElasticLoadBalancingV2Rule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2Rule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2RulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getElasticLoadBalancingV2RuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2Rule =============================

// ==========================  START: FSXFileSystem =============================

type FSXFileSystem struct {
	Description   aws.FSXFileSystemDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type FSXFileSystemHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXFileSystem `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXFileSystemHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []FSXFileSystemHit `json:"hits"`
}

type FSXFileSystemSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  FSXFileSystemHits `json:"hits"`
}

type FSXFileSystemPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXFileSystemPaginator(filters []essdk.BoolFilter, limit *int64) (FSXFileSystemPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_filesystem", filters, limit)
	if err != nil {
		return FSXFileSystemPaginator{}, err
	}

	p := FSXFileSystemPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXFileSystemPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXFileSystemPaginator) NextPage(ctx context.Context) ([]FSXFileSystem, error) {
	var response FSXFileSystemSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXFileSystem
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXFileSystemFilters = map[string]string{
	"administrative_actions":   "description.FileSystem.AdministrativeActions",
	"akas":                     "description.FileSystem.ResourceARN",
	"arn":                      "description.FileSystem.ResourceARN",
	"creation_time":            "description.FileSystem.CreationTime",
	"dns_name":                 "description.FileSystem.DNSName",
	"failure_details":          "description.FileSystem.FailureDetails",
	"file_system_id":           "description.FileSystem.FileSystemId",
	"file_system_type":         "description.FileSystem.FileSystemType",
	"file_system_type_version": "description.FileSystem.FileSystemTypeVersion",
	"kaytu_account_id":         "metadata.SourceID",
	"kms_key_id":               "description.FileSystem.KmsKeyId",
	"lifecycle":                "description.FileSystem.Lifecycle",
	"lustre_configuration":     "description.FileSystem.LustreConfiguration",
	"network_interface_ids":    "description.FileSystem.NetworkInterfaceIds",
	"ontap_configuration":      "description.FileSystem.OntapConfiguration",
	"owner_id":                 "description.FileSystem.OwnerId",
	"storage_capacity":         "description.FileSystem.StorageCapacity",
	"storage_type":             "description.FileSystem.StorageType",
	"subnet_ids":               "description.FileSystem.SubnetIds",
	"tags_src":                 "description.FileSystem.Tags",
	"vpc_id":                   "description.FileSystem.VpcId",
	"windows_configuration":    "description.FileSystem.WindowsConfiguration",
}

func ListFSXFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXFileSystem")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFSXFileSystemPaginator(essdk.BuildFilter(d.KeyColumnQuals, listFSXFileSystemFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFSXFileSystemFilters = map[string]string{
	"administrative_actions":   "description.FileSystem.AdministrativeActions",
	"akas":                     "description.FileSystem.ResourceARN",
	"arn":                      "description.FileSystem.ResourceARN",
	"creation_time":            "description.FileSystem.CreationTime",
	"dns_name":                 "description.FileSystem.DNSName",
	"failure_details":          "description.FileSystem.FailureDetails",
	"file_system_id":           "description.FileSystem.FileSystemId",
	"file_system_type":         "description.FileSystem.FileSystemType",
	"file_system_type_version": "description.FileSystem.FileSystemTypeVersion",
	"kaytu_account_id":         "metadata.SourceID",
	"kms_key_id":               "description.FileSystem.KmsKeyId",
	"lifecycle":                "description.FileSystem.Lifecycle",
	"lustre_configuration":     "description.FileSystem.LustreConfiguration",
	"network_interface_ids":    "description.FileSystem.NetworkInterfaceIds",
	"ontap_configuration":      "description.FileSystem.OntapConfiguration",
	"owner_id":                 "description.FileSystem.OwnerId",
	"storage_capacity":         "description.FileSystem.StorageCapacity",
	"storage_type":             "description.FileSystem.StorageType",
	"subnet_ids":               "description.FileSystem.SubnetIds",
	"tags_src":                 "description.FileSystem.Tags",
	"vpc_id":                   "description.FileSystem.VpcId",
	"windows_configuration":    "description.FileSystem.WindowsConfiguration",
}

func GetFSXFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXFileSystem")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFSXFileSystemPaginator(essdk.BuildFilter(d.KeyColumnQuals, getFSXFileSystemFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: FSXFileSystem =============================

// ==========================  START: FSXStorageVirtualMachine =============================

type FSXStorageVirtualMachine struct {
	Description   aws.FSXStorageVirtualMachineDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type FSXStorageVirtualMachineHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  FSXStorageVirtualMachine `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type FSXStorageVirtualMachineHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []FSXStorageVirtualMachineHit `json:"hits"`
}

type FSXStorageVirtualMachineSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  FSXStorageVirtualMachineHits `json:"hits"`
}

type FSXStorageVirtualMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXStorageVirtualMachinePaginator(filters []essdk.BoolFilter, limit *int64) (FSXStorageVirtualMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_storagevirtualmachine", filters, limit)
	if err != nil {
		return FSXStorageVirtualMachinePaginator{}, err
	}

	p := FSXStorageVirtualMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXStorageVirtualMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXStorageVirtualMachinePaginator) NextPage(ctx context.Context) ([]FSXStorageVirtualMachine, error) {
	var response FSXStorageVirtualMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXStorageVirtualMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXStorageVirtualMachineFilters = map[string]string{
	"akas":                       "description.StorageVirtualMachine.ResourceARN",
	"kaytu_account_id":           "metadata.SourceID",
	"name":                       "description.StorageVirtualMachine.Name",
	"resource_arn":               "description.StorageVirtualMachine.ResourceARN",
	"storage_virtual_machine_id": "description.StorageVirtualMachine.StorageVirtualMachineId",
	"title":                      "description.StorageVirtualMachine.StorageVirtualMachineId",
}

func ListFSXStorageVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXStorageVirtualMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFSXStorageVirtualMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listFSXStorageVirtualMachineFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFSXStorageVirtualMachineFilters = map[string]string{
	"akas":                       "description.StorageVirtualMachine.ResourceARN",
	"kaytu_account_id":           "metadata.SourceID",
	"name":                       "description.StorageVirtualMachine.Name",
	"resource_arn":               "description.StorageVirtualMachine.ResourceARN",
	"storage_virtual_machine_id": "description.StorageVirtualMachine.StorageVirtualMachineId",
	"title":                      "description.StorageVirtualMachine.StorageVirtualMachineId",
}

func GetFSXStorageVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXStorageVirtualMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFSXStorageVirtualMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getFSXStorageVirtualMachineFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: FSXStorageVirtualMachine =============================

// ==========================  START: FSXTask =============================

type FSXTask struct {
	Description   aws.FSXTaskDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type FSXTaskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXTask       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXTaskHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FSXTaskHit      `json:"hits"`
}

type FSXTaskSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  FSXTaskHits `json:"hits"`
}

type FSXTaskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXTaskPaginator(filters []essdk.BoolFilter, limit *int64) (FSXTaskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_task", filters, limit)
	if err != nil {
		return FSXTaskPaginator{}, err
	}

	p := FSXTaskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXTaskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXTaskPaginator) NextPage(ctx context.Context) ([]FSXTask, error) {
	var response FSXTaskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXTask
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXTaskFilters = map[string]string{
	"akas":             "description.Task.ResourceARN",
	"kaytu_account_id": "metadata.SourceID",
	"resource_arn":     "description.Task.ResourceARN",
	"task_id":          "description.Task.TaskId",
	"title":            "description.Task.TaskId",
}

func ListFSXTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXTask")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFSXTaskPaginator(essdk.BuildFilter(d.KeyColumnQuals, listFSXTaskFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFSXTaskFilters = map[string]string{
	"akas":             "description.Task.ResourceARN",
	"kaytu_account_id": "metadata.SourceID",
	"resource_arn":     "description.Task.ResourceARN",
	"task_id":          "description.Task.TaskId",
	"title":            "description.Task.TaskId",
}

func GetFSXTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXTask")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFSXTaskPaginator(essdk.BuildFilter(d.KeyColumnQuals, getFSXTaskFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: FSXTask =============================

// ==========================  START: FSXVolume =============================

type FSXVolume struct {
	Description   aws.FSXVolumeDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type FSXVolumeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXVolume     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXVolumeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FSXVolumeHit    `json:"hits"`
}

type FSXVolumeSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  FSXVolumeHits `json:"hits"`
}

type FSXVolumePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXVolumePaginator(filters []essdk.BoolFilter, limit *int64) (FSXVolumePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_volume", filters, limit)
	if err != nil {
		return FSXVolumePaginator{}, err
	}

	p := FSXVolumePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXVolumePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXVolumePaginator) NextPage(ctx context.Context) ([]FSXVolume, error) {
	var response FSXVolumeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXVolume
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXVolumeFilters = map[string]string{
	"akas":             "description.Volume.ResourceARN",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Volume.Name",
	"resource_arn":     "description.Volume.ResourceARN",
	"title":            "description.Volume.VolumeId",
	"volume_id":        "description.Volume.VolumeId",
}

func ListFSXVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXVolume")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFSXVolumePaginator(essdk.BuildFilter(d.KeyColumnQuals, listFSXVolumeFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFSXVolumeFilters = map[string]string{
	"akas":             "description.Volume.ResourceARN",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Volume.Name",
	"resource_arn":     "description.Volume.ResourceARN",
	"title":            "description.Volume.VolumeId",
	"volume_id":        "description.Volume.VolumeId",
}

func GetFSXVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXVolume")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFSXVolumePaginator(essdk.BuildFilter(d.KeyColumnQuals, getFSXVolumeFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: FSXVolume =============================

// ==========================  START: FSXSnapshot =============================

type FSXSnapshot struct {
	Description   aws.FSXSnapshotDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type FSXSnapshotHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXSnapshot   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXSnapshotHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FSXSnapshotHit  `json:"hits"`
}

type FSXSnapshotSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  FSXSnapshotHits `json:"hits"`
}

type FSXSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (FSXSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_snapshot", filters, limit)
	if err != nil {
		return FSXSnapshotPaginator{}, err
	}

	p := FSXSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXSnapshotPaginator) NextPage(ctx context.Context) ([]FSXSnapshot, error) {
	var response FSXSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXSnapshotFilters = map[string]string{
	"akas":             "description.Snapshot.ResourceARN",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Snapshot.Name",
	"resource_arn":     "description.Snapshot.ResourceARN",
	"snapshot_id":      "description.Snapshot.SnapshotId",
	"title":            "description.Snapshot.SnapshotId",
}

func ListFSXSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFSXSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, listFSXSnapshotFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFSXSnapshotFilters = map[string]string{
	"akas":             "description.Snapshot.ResourceARN",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Snapshot.Name",
	"resource_arn":     "description.Snapshot.ResourceARN",
	"snapshot_id":      "description.Snapshot.SnapshotId",
	"title":            "description.Snapshot.SnapshotId",
}

func GetFSXSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFSXSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, getFSXSnapshotFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: FSXSnapshot =============================

// ==========================  START: ApplicationAutoScalingTarget =============================

type ApplicationAutoScalingTarget struct {
	Description   aws.ApplicationAutoScalingTargetDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type ApplicationAutoScalingTargetHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  ApplicationAutoScalingTarget `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type ApplicationAutoScalingTargetHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []ApplicationAutoScalingTargetHit `json:"hits"`
}

type ApplicationAutoScalingTargetSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  ApplicationAutoScalingTargetHits `json:"hits"`
}

type ApplicationAutoScalingTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApplicationAutoScalingTargetPaginator(filters []essdk.BoolFilter, limit *int64) (ApplicationAutoScalingTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_applicationautoscaling_target", filters, limit)
	if err != nil {
		return ApplicationAutoScalingTargetPaginator{}, err
	}

	p := ApplicationAutoScalingTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApplicationAutoScalingTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApplicationAutoScalingTargetPaginator) NextPage(ctx context.Context) ([]ApplicationAutoScalingTarget, error) {
	var response ApplicationAutoScalingTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApplicationAutoScalingTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApplicationAutoScalingTargetFilters = map[string]string{
	"creation_time":      "description.ScalableTarget.CreationTime",
	"kaytu_account_id":   "metadata.SourceID",
	"max_capacity":       "description.ScalableTarget.MaxCapacity",
	"min_capacity":       "description.ScalableTarget.MinCapacity",
	"resource_id":        "description.ScalableTarget.ResourceId",
	"role_arn":           "description.ScalableTarget.RoleARN",
	"scalable_dimension": "description.ScalableTarget.ScalableDimension",
	"service_namespace":  "description.ScalableTarget.ServiceNamespace",
	"suspended_state":    "description.ScalableTarget.SuspendedState",
	"title":              "description.ScalableTarget.ResourceId",
}

func ListApplicationAutoScalingTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApplicationAutoScalingTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApplicationAutoScalingTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApplicationAutoScalingTargetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApplicationAutoScalingTargetFilters = map[string]string{
	"creation_time":      "description.ScalableTarget.CreationTime",
	"kaytu_account_id":   "metadata.SourceID",
	"max_capacity":       "description.ScalableTarget.MaxCapacity",
	"min_capacity":       "description.ScalableTarget.MinCapacity",
	"resource_id":        "description.ScalableTarget.ResourceId",
	"role_arn":           "description.ScalableTarget.RoleARN",
	"scalable_dimension": "description.ScalableTarget.ScalableDimension",
	"service_namespace":  "description.ScalableTarget.ServiceNamespace",
	"suspended_state":    "description.ScalableTarget.SuspendedState",
	"title":              "description.ScalableTarget.ResourceId",
}

func GetApplicationAutoScalingTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApplicationAutoScalingTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApplicationAutoScalingTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApplicationAutoScalingTargetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApplicationAutoScalingTarget =============================

// ==========================  START: AutoScalingGroup =============================

type AutoScalingGroup struct {
	Description   aws.AutoScalingGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type AutoScalingGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AutoScalingGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AutoScalingGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []AutoScalingGroupHit `json:"hits"`
}

type AutoScalingGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AutoScalingGroupHits `json:"hits"`
}

type AutoScalingGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutoScalingGroupPaginator(filters []essdk.BoolFilter, limit *int64) (AutoScalingGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_autoscaling_autoscalinggroup", filters, limit)
	if err != nil {
		return AutoScalingGroupPaginator{}, err
	}

	p := AutoScalingGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutoScalingGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutoScalingGroupPaginator) NextPage(ctx context.Context) ([]AutoScalingGroup, error) {
	var response AutoScalingGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutoScalingGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutoScalingGroupFilters = map[string]string{
	"akas":                                        "autoScalingGroupARN",
	"autoscaling_group_arn":                       "description.AutoScalingGroup.AutoScalingGroupARN",
	"availability_zones":                          "description.AutoScalingGroup.AvailabilityZones",
	"created_time":                                "description.AutoScalingGroup.CreatedTime",
	"default_cooldown":                            "description.AutoScalingGroup.DefaultCooldown",
	"desired_capacity":                            "description.AutoScalingGroup.DesiredCapacity",
	"enabled_metrics":                             "description.AutoScalingGroup.EnabledMetrics",
	"health_check_grace_period":                   "description.AutoScalingGroup.HealthCheckGracePeriod",
	"health_check_type":                           "description.AutoScalingGroup.HealthCheckType",
	"instances":                                   "description.AutoScalingGroup.Instances",
	"kaytu_account_id":                            "metadata.SourceID",
	"launch_configuration_name":                   "description.AutoScalingGroup.LaunchConfigurationName",
	"launch_template_id":                          "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateId",
	"launch_template_name":                        "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateName",
	"launch_template_version":                     "description.AutoScalingGroup.LaunchTemplate.Version",
	"load_balancer_names":                         "description.AutoScalingGroup.LoadBalancerNames",
	"max_instance_lifetime":                       "description.AutoScalingGroup.MaxInstanceLifetime",
	"max_size":                                    "description.AutoScalingGroup.MaxSize",
	"min_size":                                    "description.AutoScalingGroup.MinSize",
	"mixed_instances_policy_launch_template_id":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateId",
	"mixed_instances_policy_launch_template_name": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName",
	"mixed_instances_policy_launch_template_overrides": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.Overrides",
	"mixed_instances_policy_launch_template_version":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version",
	"name":                                     "description.AutoScalingGroup.AutoScalingGroupName",
	"new_instances_protected_from_scale_in":    "description.AutoScalingGroup.NewInstancesProtectedFromScaleIn",
	"on_demand_allocation_strategy":            "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy",
	"on_demand_base_capacity":                  "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity",
	"on_demand_percentage_above_base_capacity": "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity",
	"placement_group":                          "description.AutoScalingGroup.PlacementGroup",
	"policies":                                 "description.Policies",
	"service_linked_role_arn":                  "description.AutoScalingGroup.ServiceLinkedRoleARN",
	"spot_allocation_strategy":                 "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy",
	"spot_instance_pools":                      "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools",
	"spot_max_price":                           "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice",
	"status":                                   "description.AutoScalingGroup.Status",
	"suspended_processes":                      "description.AutoScalingGroup.SuspendedProcesses",
	"tags_src":                                 "description.AutoScalingGroup.Tags",
	"target_group_arns":                        "description.AutoScalingGroup.TargetGroupARNs",
	"termination_policies":                     "description.AutoScalingGroup.TerminationPolicies",
	"title":                                    "autoScalingGroupName",
	"vpc_zone_identifier":                      "description.AutoScalingGroup.VPCZoneIdentifier",
}

func ListAutoScalingGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutoScalingGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAutoScalingGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAutoScalingGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAutoScalingGroupFilters = map[string]string{
	"akas":                                        "autoScalingGroupARN",
	"autoscaling_group_arn":                       "description.AutoScalingGroup.AutoScalingGroupARN",
	"availability_zones":                          "description.AutoScalingGroup.AvailabilityZones",
	"created_time":                                "description.AutoScalingGroup.CreatedTime",
	"default_cooldown":                            "description.AutoScalingGroup.DefaultCooldown",
	"desired_capacity":                            "description.AutoScalingGroup.DesiredCapacity",
	"enabled_metrics":                             "description.AutoScalingGroup.EnabledMetrics",
	"health_check_grace_period":                   "description.AutoScalingGroup.HealthCheckGracePeriod",
	"health_check_type":                           "description.AutoScalingGroup.HealthCheckType",
	"instances":                                   "description.AutoScalingGroup.Instances",
	"kaytu_account_id":                            "metadata.SourceID",
	"launch_configuration_name":                   "description.AutoScalingGroup.LaunchConfigurationName",
	"launch_template_id":                          "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateId",
	"launch_template_name":                        "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateName",
	"launch_template_version":                     "description.AutoScalingGroup.LaunchTemplate.Version",
	"load_balancer_names":                         "description.AutoScalingGroup.LoadBalancerNames",
	"max_instance_lifetime":                       "description.AutoScalingGroup.MaxInstanceLifetime",
	"max_size":                                    "description.AutoScalingGroup.MaxSize",
	"min_size":                                    "description.AutoScalingGroup.MinSize",
	"mixed_instances_policy_launch_template_id":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateId",
	"mixed_instances_policy_launch_template_name": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName",
	"mixed_instances_policy_launch_template_overrides": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.Overrides",
	"mixed_instances_policy_launch_template_version":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version",
	"name":                                     "description.AutoScalingGroup.AutoScalingGroupName",
	"new_instances_protected_from_scale_in":    "description.AutoScalingGroup.NewInstancesProtectedFromScaleIn",
	"on_demand_allocation_strategy":            "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy",
	"on_demand_base_capacity":                  "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity",
	"on_demand_percentage_above_base_capacity": "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity",
	"placement_group":                          "description.AutoScalingGroup.PlacementGroup",
	"policies":                                 "description.Policies",
	"service_linked_role_arn":                  "description.AutoScalingGroup.ServiceLinkedRoleARN",
	"spot_allocation_strategy":                 "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy",
	"spot_instance_pools":                      "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools",
	"spot_max_price":                           "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice",
	"status":                                   "description.AutoScalingGroup.Status",
	"suspended_processes":                      "description.AutoScalingGroup.SuspendedProcesses",
	"tags_src":                                 "description.AutoScalingGroup.Tags",
	"target_group_arns":                        "description.AutoScalingGroup.TargetGroupARNs",
	"termination_policies":                     "description.AutoScalingGroup.TerminationPolicies",
	"title":                                    "autoScalingGroupName",
	"vpc_zone_identifier":                      "description.AutoScalingGroup.VPCZoneIdentifier",
}

func GetAutoScalingGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutoScalingGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAutoScalingGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAutoScalingGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AutoScalingGroup =============================

// ==========================  START: AutoScalingLaunchConfiguration =============================

type AutoScalingLaunchConfiguration struct {
	Description   aws.AutoScalingLaunchConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type AutoScalingLaunchConfigurationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  AutoScalingLaunchConfiguration `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type AutoScalingLaunchConfigurationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []AutoScalingLaunchConfigurationHit `json:"hits"`
}

type AutoScalingLaunchConfigurationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  AutoScalingLaunchConfigurationHits `json:"hits"`
}

type AutoScalingLaunchConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutoScalingLaunchConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (AutoScalingLaunchConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_autoscaling_launchconfiguration", filters, limit)
	if err != nil {
		return AutoScalingLaunchConfigurationPaginator{}, err
	}

	p := AutoScalingLaunchConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutoScalingLaunchConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutoScalingLaunchConfigurationPaginator) NextPage(ctx context.Context) ([]AutoScalingLaunchConfiguration, error) {
	var response AutoScalingLaunchConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutoScalingLaunchConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutoScalingLaunchConfigurationFilters = map[string]string{
	"akas":                                    "description.LaunchConfiguration.LaunchConfigurationARN",
	"associate_public_ip_address":             "description.LaunchConfiguration.AssociatePublicIpAddress",
	"block_device_mappings":                   "description.LaunchConfiguration.BlockDeviceMappings",
	"classic_link_vpc_id":                     "description.LaunchConfiguration.ClassicLinkVPCId",
	"classic_link_vpc_security_groups":        "description.LaunchConfiguration.ClassicLinkVPCSecurityGroups",
	"created_time":                            "description.LaunchConfiguration.CreatedTime",
	"ebs_optimized":                           "description.LaunchConfiguration.EbsOptimized",
	"iam_instance_profile":                    "description.LaunchConfiguration.IamInstanceProfile",
	"image_id":                                "description.LaunchConfiguration.ImageId",
	"instance_monitoring_enabled":             "description.LaunchConfiguration.InstanceMonitoring.Enabled",
	"instance_type":                           "description.LaunchConfiguration.InstanceType",
	"kaytu_account_id":                        "metadata.SourceID",
	"kernel_id":                               "description.LaunchConfiguration.KernelId",
	"key_name":                                "description.LaunchConfiguration.KeyName",
	"launch_configuration_arn":                "description.LaunchConfiguration.LaunchConfigurationARN",
	"metadata_options_http_endpoint":          "description.LaunchConfiguration.MetadataOptions.HttpEndpoint",
	"metadata_options_http_tokens":            "description.LaunchConfiguration.MetadataOptions.HttpTokens",
	"metadata_options_put_response_hop_limit": "description.LaunchConfiguration.MetadataOptions.HttpPutResponseHopLimit",
	"name":              "description.LaunchConfiguration.LaunchConfigurationName",
	"placement_tenancy": "description.LaunchConfiguration.PlacementTenancy",
	"ramdisk_id":        "description.LaunchConfiguration.RamdiskId",
	"security_groups":   "description.LaunchConfiguration.SecurityGroups",
	"spot_price":        "description.LaunchConfiguration.SpotPrice",
	"title":             "description.LaunchConfiguration.LaunchConfigurationName",
	"user_data":         "description.LaunchConfiguration.UserData",
}

func ListAutoScalingLaunchConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutoScalingLaunchConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAutoScalingLaunchConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAutoScalingLaunchConfigurationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAutoScalingLaunchConfigurationFilters = map[string]string{
	"akas":                                    "description.LaunchConfiguration.LaunchConfigurationARN",
	"associate_public_ip_address":             "description.LaunchConfiguration.AssociatePublicIpAddress",
	"block_device_mappings":                   "description.LaunchConfiguration.BlockDeviceMappings",
	"classic_link_vpc_id":                     "description.LaunchConfiguration.ClassicLinkVPCId",
	"classic_link_vpc_security_groups":        "description.LaunchConfiguration.ClassicLinkVPCSecurityGroups",
	"created_time":                            "description.LaunchConfiguration.CreatedTime",
	"ebs_optimized":                           "description.LaunchConfiguration.EbsOptimized",
	"iam_instance_profile":                    "description.LaunchConfiguration.IamInstanceProfile",
	"image_id":                                "description.LaunchConfiguration.ImageId",
	"instance_monitoring_enabled":             "description.LaunchConfiguration.InstanceMonitoring.Enabled",
	"instance_type":                           "description.LaunchConfiguration.InstanceType",
	"kaytu_account_id":                        "metadata.SourceID",
	"kernel_id":                               "description.LaunchConfiguration.KernelId",
	"key_name":                                "description.LaunchConfiguration.KeyName",
	"launch_configuration_arn":                "description.LaunchConfiguration.LaunchConfigurationARN",
	"metadata_options_http_endpoint":          "description.LaunchConfiguration.MetadataOptions.HttpEndpoint",
	"metadata_options_http_tokens":            "description.LaunchConfiguration.MetadataOptions.HttpTokens",
	"metadata_options_put_response_hop_limit": "description.LaunchConfiguration.MetadataOptions.HttpPutResponseHopLimit",
	"name":              "description.LaunchConfiguration.LaunchConfigurationName",
	"placement_tenancy": "description.LaunchConfiguration.PlacementTenancy",
	"ramdisk_id":        "description.LaunchConfiguration.RamdiskId",
	"security_groups":   "description.LaunchConfiguration.SecurityGroups",
	"spot_price":        "description.LaunchConfiguration.SpotPrice",
	"title":             "description.LaunchConfiguration.LaunchConfigurationName",
	"user_data":         "description.LaunchConfiguration.UserData",
}

func GetAutoScalingLaunchConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutoScalingLaunchConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAutoScalingLaunchConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAutoScalingLaunchConfigurationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AutoScalingLaunchConfiguration =============================

// ==========================  START: CertificateManagerCertificate =============================

type CertificateManagerCertificate struct {
	Description   aws.CertificateManagerCertificateDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CertificateManagerCertificateHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CertificateManagerCertificate `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CertificateManagerCertificateHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CertificateManagerCertificateHit `json:"hits"`
}

type CertificateManagerCertificateSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CertificateManagerCertificateHits `json:"hits"`
}

type CertificateManagerCertificatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCertificateManagerCertificatePaginator(filters []essdk.BoolFilter, limit *int64) (CertificateManagerCertificatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_certificatemanager_certificate", filters, limit)
	if err != nil {
		return CertificateManagerCertificatePaginator{}, err
	}

	p := CertificateManagerCertificatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CertificateManagerCertificatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CertificateManagerCertificatePaginator) NextPage(ctx context.Context) ([]CertificateManagerCertificate, error) {
	var response CertificateManagerCertificateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CertificateManagerCertificate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCertificateManagerCertificateFilters = map[string]string{
	"akas":              "description.Certificate.CertificateArn",
	"certificate":       "description.Attributes.Certificate",
	"certificate_arn":   "description.Certificate.CertificateArn",
	"certificate_chain": "description.Attributes.CertificateChain",
	"certificate_transparency_logging_preference": "description.Certificate.Options.CertificateTransparencyLoggingPreference",
	"created_at":                "description.Certificate.CreatedAt",
	"domain_name":               "description.Certificate.DomainName",
	"domain_validation_options": "description.Certificate.DomainValidationOptions",
	"extended_key_usages":       "description.Certificate.ExtendedKeyUsages",
	"failure_reason":            "description.Certificate.FailureReason",
	"imported_at":               "description.Certificate.ImportedAt",
	"in_use_by":                 "description.Certificate.InUseBy",
	"issued_at":                 "description.Certificate.IssuedAt",
	"issuer":                    "description.Certificate.Issuer",
	"kaytu_account_id":          "metadata.SourceID",
	"key_algorithm":             "description.Certificate.KeyAlgorithm",
	"not_after":                 "description.Certificate.NotAfter",
	"not_before":                "description.Certificate.NotBefore",
	"renewal_eligibility":       "description.Certificate.RenewalEligibility",
	"revocation_reason":         "description.Certificate.RevocationReason",
	"revoked_at":                "description.Certificate.RevokedAt",
	"serial":                    "description.Certificate.Serial",
	"signature_algorithm":       "description.Certificate.SignatureAlgorithm",
	"status":                    "description.Certificate.Status",
	"subject":                   "description.Certificate.Subject",
	"subject_alternative_names": "description.Certificate.SubjectAlternativeNames",
	"tags_src":                  "description.Tags",
	"title":                     "description.Certificate.CertificateArn",
	"type":                      "description.Certificate.Type",
}

func ListCertificateManagerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCertificateManagerCertificate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCertificateManagerCertificatePaginator(essdk.BuildFilter(d.KeyColumnQuals, listCertificateManagerCertificateFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCertificateManagerCertificateFilters = map[string]string{
	"akas":              "description.Certificate.CertificateArn",
	"certificate":       "description.Attributes.Certificate",
	"certificate_arn":   "description.Certificate.CertificateArn",
	"certificate_chain": "description.Attributes.CertificateChain",
	"certificate_transparency_logging_preference": "description.Certificate.Options.CertificateTransparencyLoggingPreference",
	"created_at":                "description.Certificate.CreatedAt",
	"domain_name":               "description.Certificate.DomainName",
	"domain_validation_options": "description.Certificate.DomainValidationOptions",
	"extended_key_usages":       "description.Certificate.ExtendedKeyUsages",
	"failure_reason":            "description.Certificate.FailureReason",
	"imported_at":               "description.Certificate.ImportedAt",
	"in_use_by":                 "description.Certificate.InUseBy",
	"issued_at":                 "description.Certificate.IssuedAt",
	"issuer":                    "description.Certificate.Issuer",
	"kaytu_account_id":          "metadata.SourceID",
	"key_algorithm":             "description.Certificate.KeyAlgorithm",
	"not_after":                 "description.Certificate.NotAfter",
	"not_before":                "description.Certificate.NotBefore",
	"renewal_eligibility":       "description.Certificate.RenewalEligibility",
	"revocation_reason":         "description.Certificate.RevocationReason",
	"revoked_at":                "description.Certificate.RevokedAt",
	"serial":                    "description.Certificate.Serial",
	"signature_algorithm":       "description.Certificate.SignatureAlgorithm",
	"status":                    "description.Certificate.Status",
	"subject":                   "description.Certificate.Subject",
	"subject_alternative_names": "description.Certificate.SubjectAlternativeNames",
	"tags_src":                  "description.Tags",
	"title":                     "description.Certificate.CertificateArn",
	"type":                      "description.Certificate.Type",
}

func GetCertificateManagerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCertificateManagerCertificate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCertificateManagerCertificatePaginator(essdk.BuildFilter(d.KeyColumnQuals, getCertificateManagerCertificateFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CertificateManagerCertificate =============================

// ==========================  START: CloudTrailTrail =============================

type CloudTrailTrail struct {
	Description   aws.CloudTrailTrailDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CloudTrailTrailHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CloudTrailTrail `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CloudTrailTrailHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CloudTrailTrailHit `json:"hits"`
}

type CloudTrailTrailSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CloudTrailTrailHits `json:"hits"`
}

type CloudTrailTrailPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailTrailPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailTrailPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_trail", filters, limit)
	if err != nil {
		return CloudTrailTrailPaginator{}, err
	}

	p := CloudTrailTrailPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailTrailPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailTrailPaginator) NextPage(ctx context.Context) ([]CloudTrailTrail, error) {
	var response CloudTrailTrailSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailTrail
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailTrailFilters = map[string]string{
	"advanced_event_selectors":              "description.AdvancedEventSelectors",
	"akas":                                  "description.Trail.TrailARN",
	"arn":                                   "description.Trail.TrailARN",
	"cloudwatch_logs_role_arn":              "description.Trail.CloudWatchLogsRoleArn",
	"event_selectors":                       "description.EventSelectors",
	"has_custom_event_selectors":            "description.Trail.HasCustomEventSelectors",
	"has_insight_selectors":                 "description.Trail.HasInsightSelectors",
	"home_region":                           "description.Trail.HomeRegion",
	"include_global_service_events":         "description.Trail.IncludeGlobalServiceEvents",
	"insight_selectors":                     "description.Trail.HasInsightSelectors",
	"is_logging":                            "description.TrailStatus.IsLogging",
	"is_multi_region_trail":                 "description.Trail.IsMultiRegionTrail",
	"is_organization_trail":                 "description.Trail.IsOrganizationTrail",
	"kaytu_account_id":                      "metadata.SourceID",
	"kms_key_id":                            "description.Trail.KmsKeyId",
	"latest_cloudwatch_logs_delivery_error": "description.TrailStatus.LatestCloudWatchLogsDeliveryError",
	"latest_cloudwatch_logs_delivery_time":  "description.TrailStatus.LatestCloudWatchLogsDeliveryTime",
	"latest_delivery_error":                 "description.TrailStatus.LatestDeliveryError",
	"latest_delivery_time":                  "description.TrailStatus.LatestDeliveryTime",
	"latest_digest_delivery_error":          "description.TrailStatus.LatestDigestDeliveryError",
	"latest_digest_delivery_time":           "description.TrailStatus.LatestDigestDeliveryTime",
	"latest_notification_error":             "description.TrailStatus.LatestNotificationError",
	"latest_notification_time":              "description.TrailStatus.LatestNotificationTime",
	"log_file_validation_enabled":           "description.Trail.LogFileValidationEnabled",
	"log_group_arn":                         "description.Trail.CloudWatchLogsLogGroupArn",
	"name":                                  "description.Trail.Name",
	"s3_bucket_name":                        "description.Trail.S3BucketName",
	"s3_key_prefix":                         "description.Trail.S3KeyPrefix",
	"sns_topic_arn":                         "description.Trail.SnsTopicARN",
	"start_logging_time":                    "description.TrailStatus.StartLoggingTime",
	"stop_logging_time":                     "description.TrailStatus.StopLoggingTime",
	"tags_src":                              "description.Tags",
	"title":                                 "description.Trail.Name",
}

func ListCloudTrailTrail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailTrail")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudTrailTrailPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudTrailTrailFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudTrailTrailFilters = map[string]string{
	"advanced_event_selectors":              "description.AdvancedEventSelectors",
	"akas":                                  "description.Trail.TrailARN",
	"arn":                                   "description.Trail.TrailARN",
	"cloudwatch_logs_role_arn":              "description.Trail.CloudWatchLogsRoleArn",
	"event_selectors":                       "description.EventSelectors",
	"has_custom_event_selectors":            "description.Trail.HasCustomEventSelectors",
	"has_insight_selectors":                 "description.Trail.HasInsightSelectors",
	"home_region":                           "description.Trail.HomeRegion",
	"include_global_service_events":         "description.Trail.IncludeGlobalServiceEvents",
	"insight_selectors":                     "description.Trail.HasInsightSelectors",
	"is_logging":                            "description.TrailStatus.IsLogging",
	"is_multi_region_trail":                 "description.Trail.IsMultiRegionTrail",
	"is_organization_trail":                 "description.Trail.IsOrganizationTrail",
	"kaytu_account_id":                      "metadata.SourceID",
	"kms_key_id":                            "description.Trail.KmsKeyId",
	"latest_cloudwatch_logs_delivery_error": "description.TrailStatus.LatestCloudWatchLogsDeliveryError",
	"latest_cloudwatch_logs_delivery_time":  "description.TrailStatus.LatestCloudWatchLogsDeliveryTime",
	"latest_delivery_error":                 "description.TrailStatus.LatestDeliveryError",
	"latest_delivery_time":                  "description.TrailStatus.LatestDeliveryTime",
	"latest_digest_delivery_error":          "description.TrailStatus.LatestDigestDeliveryError",
	"latest_digest_delivery_time":           "description.TrailStatus.LatestDigestDeliveryTime",
	"latest_notification_error":             "description.TrailStatus.LatestNotificationError",
	"latest_notification_time":              "description.TrailStatus.LatestNotificationTime",
	"log_file_validation_enabled":           "description.Trail.LogFileValidationEnabled",
	"log_group_arn":                         "description.Trail.CloudWatchLogsLogGroupArn",
	"name":                                  "description.Trail.Name",
	"s3_bucket_name":                        "description.Trail.S3BucketName",
	"s3_key_prefix":                         "description.Trail.S3KeyPrefix",
	"sns_topic_arn":                         "description.Trail.SnsTopicARN",
	"start_logging_time":                    "description.TrailStatus.StartLoggingTime",
	"stop_logging_time":                     "description.TrailStatus.StopLoggingTime",
	"tags_src":                              "description.Tags",
	"title":                                 "description.Trail.Name",
}

func GetCloudTrailTrail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailTrail")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudTrailTrailPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudTrailTrailFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudTrailTrail =============================

// ==========================  START: CloudTrailChannel =============================

type CloudTrailChannel struct {
	Description   aws.CloudTrailChannelDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type CloudTrailChannelHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  CloudTrailChannel `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type CloudTrailChannelHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []CloudTrailChannelHit `json:"hits"`
}

type CloudTrailChannelSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  CloudTrailChannelHits `json:"hits"`
}

type CloudTrailChannelPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailChannelPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailChannelPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_channel", filters, limit)
	if err != nil {
		return CloudTrailChannelPaginator{}, err
	}

	p := CloudTrailChannelPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailChannelPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailChannelPaginator) NextPage(ctx context.Context) ([]CloudTrailChannel, error) {
	var response CloudTrailChannelSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailChannel
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailChannelFilters = map[string]string{
	"advanced_event_selectors": "description.Channel.SourceConfig.AdvancedEventSelectors",
	"akas":                     "description.Channel.ChannelArn",
	"apply_to_all_regions":     "description.Channel.SourceConfig.ApplyToAllRegions",
	"arn":                      "description.Channel.ChannelArn",
	"destinations":             "description.Channel.Destinations",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.Channel.Name",
	"source":                   "description.Channel.Source",
	"source_config":            "description.Channel.SourceConfig",
	"title":                    "description.Channel.Name",
}

func ListCloudTrailChannel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailChannel")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudTrailChannelPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudTrailChannelFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudTrailChannelFilters = map[string]string{
	"advanced_event_selectors": "description.Channel.SourceConfig.AdvancedEventSelectors",
	"akas":                     "description.Channel.ChannelArn",
	"apply_to_all_regions":     "description.Channel.SourceConfig.ApplyToAllRegions",
	"arn":                      "description.Channel.ChannelArn",
	"destinations":             "description.Channel.Destinations",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.Channel.Name",
	"source":                   "description.Channel.Source",
	"source_config":            "description.Channel.SourceConfig",
	"title":                    "description.Channel.Name",
}

func GetCloudTrailChannel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailChannel")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudTrailChannelPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudTrailChannelFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudTrailChannel =============================

// ==========================  START: CloudTrailEventDataStore =============================

type CloudTrailEventDataStore struct {
	Description   aws.CloudTrailEventDataStoreDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type CloudTrailEventDataStoreHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  CloudTrailEventDataStore `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type CloudTrailEventDataStoreHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []CloudTrailEventDataStoreHit `json:"hits"`
}

type CloudTrailEventDataStoreSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  CloudTrailEventDataStoreHits `json:"hits"`
}

type CloudTrailEventDataStorePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailEventDataStorePaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailEventDataStorePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_eventdatastore", filters, limit)
	if err != nil {
		return CloudTrailEventDataStorePaginator{}, err
	}

	p := CloudTrailEventDataStorePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailEventDataStorePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailEventDataStorePaginator) NextPage(ctx context.Context) ([]CloudTrailEventDataStore, error) {
	var response CloudTrailEventDataStoreSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailEventDataStore
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailEventDataStoreFilters = map[string]string{
	"advanced_event_selectors":       "description.EventDataStore.AdvancedEventSelectors",
	"akas":                           "description.EventDataStore.EventDataStoreArn",
	"arn":                            "description.EventDataStore.EventDataStoreArn",
	"created_timestamp":              "description.EventDataStore.CreatedTimestamp",
	"kaytu_account_id":               "metadata.SourceID",
	"multi_region_enabled":           "description.EventDataStore.MultiRegionEnabled",
	"name":                           "description.EventDataStore.Name",
	"organization_enabled":           "description.EventDataStore.OrganizationEnabled",
	"retention_period":               "description.EventDataStore.RetentionPeriod",
	"status":                         "description.EventDataStore.Status",
	"termination_protection_enabled": "description.EventDataStore.TerminationProtectionEnabled",
	"title":                          "description.EventDataStore.Name",
	"updated_timestamp":              "description.EventDataStore.UpdatedTimestamp",
}

func ListCloudTrailEventDataStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailEventDataStore")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudTrailEventDataStorePaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudTrailEventDataStoreFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudTrailEventDataStoreFilters = map[string]string{
	"advanced_event_selectors":       "description.EventDataStore.AdvancedEventSelectors",
	"akas":                           "description.EventDataStore.EventDataStoreArn",
	"arn":                            "description.EventDataStore.EventDataStoreArn",
	"created_timestamp":              "description.EventDataStore.CreatedTimestamp",
	"kaytu_account_id":               "metadata.SourceID",
	"multi_region_enabled":           "description.EventDataStore.MultiRegionEnabled",
	"name":                           "description.EventDataStore.Name",
	"organization_enabled":           "description.EventDataStore.OrganizationEnabled",
	"retention_period":               "description.EventDataStore.RetentionPeriod",
	"status":                         "description.EventDataStore.Status",
	"termination_protection_enabled": "description.EventDataStore.TerminationProtectionEnabled",
	"title":                          "description.EventDataStore.Name",
	"updated_timestamp":              "description.EventDataStore.UpdatedTimestamp",
}

func GetCloudTrailEventDataStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailEventDataStore")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudTrailEventDataStorePaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudTrailEventDataStoreFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudTrailEventDataStore =============================

// ==========================  START: CloudTrailImport =============================

type CloudTrailImport struct {
	Description   aws.CloudTrailImportDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type CloudTrailImportHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CloudTrailImport `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CloudTrailImportHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CloudTrailImportHit `json:"hits"`
}

type CloudTrailImportSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CloudTrailImportHits `json:"hits"`
}

type CloudTrailImportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailImportPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailImportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_import", filters, limit)
	if err != nil {
		return CloudTrailImportPaginator{}, err
	}

	p := CloudTrailImportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailImportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailImportPaginator) NextPage(ctx context.Context) ([]CloudTrailImport, error) {
	var response CloudTrailImportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailImport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailImportFilters = map[string]string{
	"created_timestamp": "description.Import.CreatedTimestamp",
	"destinations":      "description.Import.Destinations",
	"end_event_time":    "description.Import.EndEventTime",
	"import_id":         "description.Import.ImportId",
	"import_source":     "description.Import.ImportSource",
	"import_statistics": "description.Import.ImportStatistics",
	"import_status":     "description.Import.ImportStatus",
	"kaytu_account_id":  "metadata.SourceID",
	"start_event_time":  "description.Import.StartEventTime",
	"title":             "description.Import.ImportId",
	"updated_timestamp": "description.Import.UpdatedTimestamp",
}

func ListCloudTrailImport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailImport")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudTrailImportPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudTrailImportFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudTrailImportFilters = map[string]string{
	"created_timestamp": "description.Import.CreatedTimestamp",
	"destinations":      "description.Import.Destinations",
	"end_event_time":    "description.Import.EndEventTime",
	"import_id":         "description.Import.ImportId",
	"import_source":     "description.Import.ImportSource",
	"import_statistics": "description.Import.ImportStatistics",
	"import_status":     "description.Import.ImportStatus",
	"kaytu_account_id":  "metadata.SourceID",
	"start_event_time":  "description.Import.StartEventTime",
	"title":             "description.Import.ImportId",
	"updated_timestamp": "description.Import.UpdatedTimestamp",
}

func GetCloudTrailImport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailImport")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudTrailImportPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudTrailImportFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudTrailImport =============================

// ==========================  START: CloudTrailQuery =============================

type CloudTrailQuery struct {
	Description   aws.CloudTrailQueryDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CloudTrailQueryHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CloudTrailQuery `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CloudTrailQueryHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CloudTrailQueryHit `json:"hits"`
}

type CloudTrailQuerySearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CloudTrailQueryHits `json:"hits"`
}

type CloudTrailQueryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailQueryPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailQueryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_query", filters, limit)
	if err != nil {
		return CloudTrailQueryPaginator{}, err
	}

	p := CloudTrailQueryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailQueryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailQueryPaginator) NextPage(ctx context.Context) ([]CloudTrailQuery, error) {
	var response CloudTrailQuerySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailQuery
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailQueryFilters = map[string]string{
	"bytes_scanned":            "description.Query.QueryStatistics.BytesScanned",
	"creation_time":            "description.Query.QueryStatistics.CreationTime",
	"delivery_s3_uri":          "description.Query.DeliveryS3Uri",
	"delivery_status":          "description.Query.DeliveryStatus",
	"error_message":            "description.Query.ErrorMessage",
	"event_data_store_arn":     "description.EventDataStoreARN",
	"events_matched":           "description.Query.QueryStatistics.EventsMatched",
	"events_scanned":           "description.Query.QueryStatistics.EventsScanned",
	"execution_time_in_millis": "description.Query.QueryStatistics.ExecutionTimeInMillis",
	"kaytu_account_id":         "metadata.SourceID",
	"query_id":                 "description.Query.QueryId",
	"query_status":             "description.Query.QueryStatus",
	"query_string":             "description.Query.QueryString",
	"title":                    "description.Query.QueryId",
}

func ListCloudTrailQuery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailQuery")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudTrailQueryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudTrailQueryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudTrailQueryFilters = map[string]string{
	"bytes_scanned":            "description.Query.QueryStatistics.BytesScanned",
	"creation_time":            "description.Query.QueryStatistics.CreationTime",
	"delivery_s3_uri":          "description.Query.DeliveryS3Uri",
	"delivery_status":          "description.Query.DeliveryStatus",
	"error_message":            "description.Query.ErrorMessage",
	"event_data_store_arn":     "description.EventDataStoreARN",
	"events_matched":           "description.Query.QueryStatistics.EventsMatched",
	"events_scanned":           "description.Query.QueryStatistics.EventsScanned",
	"execution_time_in_millis": "description.Query.QueryStatistics.ExecutionTimeInMillis",
	"kaytu_account_id":         "metadata.SourceID",
	"query_id":                 "description.Query.QueryId",
	"query_status":             "description.Query.QueryStatus",
	"query_string":             "description.Query.QueryString",
	"title":                    "description.Query.QueryId",
}

func GetCloudTrailQuery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailQuery")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudTrailQueryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudTrailQueryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudTrailQuery =============================

// ==========================  START: CloudTrailTrailEvent =============================

type CloudTrailTrailEvent struct {
	Description   aws.CloudTrailTrailEventDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type CloudTrailTrailEventHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  CloudTrailTrailEvent `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type CloudTrailTrailEventHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []CloudTrailTrailEventHit `json:"hits"`
}

type CloudTrailTrailEventSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  CloudTrailTrailEventHits `json:"hits"`
}

type CloudTrailTrailEventPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailTrailEventPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailTrailEventPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_trailevent", filters, limit)
	if err != nil {
		return CloudTrailTrailEventPaginator{}, err
	}

	p := CloudTrailTrailEventPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailTrailEventPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailTrailEventPaginator) NextPage(ctx context.Context) ([]CloudTrailTrailEvent, error) {
	var response CloudTrailTrailEventSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailTrailEvent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailTrailEventFilters = map[string]string{
	"access_key_id":    "userIdentity.AccessKeyId",
	"cloudtrail_event": "message",
	"kaytu_account_id": "metadata.SourceID",
	"log_group_name":   "description.LogGroupName",
	"log_stream_name":  "description.TrailEvent.LogStreamName",
	"timestamp":        "description.TrailEvent.Timestamp",
	"timestamp_ms":     "description.TrailEvent.Timestamp",
	"user_identifier":  "userIdentity.Arn",
	"user_type":        "userIdentity.Type",
	"username":         "userIdentity.Username",
}

func ListCloudTrailTrailEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailTrailEvent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudTrailTrailEventPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudTrailTrailEventFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudTrailTrailEventFilters = map[string]string{
	"access_key_id":    "userIdentity.AccessKeyId",
	"cloudtrail_event": "message",
	"kaytu_account_id": "metadata.SourceID",
	"log_group_name":   "description.LogGroupName",
	"log_stream_name":  "description.TrailEvent.LogStreamName",
	"timestamp":        "description.TrailEvent.Timestamp",
	"timestamp_ms":     "description.TrailEvent.Timestamp",
	"user_identifier":  "userIdentity.Arn",
	"user_type":        "userIdentity.Type",
	"username":         "userIdentity.Username",
}

func GetCloudTrailTrailEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailTrailEvent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudTrailTrailEventPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudTrailTrailEventFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudTrailTrailEvent =============================

// ==========================  START: IAMAccount =============================

type IAMAccount struct {
	Description   aws.IAMAccountDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type IAMAccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMAccount    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMAccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMAccountHit   `json:"hits"`
}

type IAMAccountSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  IAMAccountHits `json:"hits"`
}

type IAMAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccountPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_account", filters, limit)
	if err != nil {
		return IAMAccountPaginator{}, err
	}

	p := IAMAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccountPaginator) NextPage(ctx context.Context) ([]IAMAccount, error) {
	var response IAMAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccountFilters = map[string]string{
	"account_aliases":                     "description.Aliases",
	"kaytu_account_id":                    "metadata.SourceID",
	"organization_arn":                    "description.Organization.Arn",
	"organization_available_policy_types": "description.Organization.AvailablePolicyTypes",
	"organization_feature_set":            "description.Organization.FeatureSet",
	"organization_id":                     "description.Organization.Id",
	"organization_master_account_arn":     "description.Organization.MasterAccountArn",
	"organization_master_account_email":   "description.Organization.MasterAccountEmail",
	"organization_master_account_id":      "description.Organization.MasterAccountId",
}

func ListIAMAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMAccountFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMAccountFilters = map[string]string{
	"account_aliases":                     "description.Aliases",
	"kaytu_account_id":                    "metadata.SourceID",
	"organization_arn":                    "description.Organization.Arn",
	"organization_available_policy_types": "description.Organization.AvailablePolicyTypes",
	"organization_feature_set":            "description.Organization.FeatureSet",
	"organization_id":                     "description.Organization.Id",
	"organization_master_account_arn":     "description.Organization.MasterAccountArn",
	"organization_master_account_email":   "description.Organization.MasterAccountEmail",
	"organization_master_account_id":      "description.Organization.MasterAccountId",
}

func GetIAMAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMAccountFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMAccount =============================

// ==========================  START: IAMAccountSummary =============================

type IAMAccountSummary struct {
	Description   aws.IAMAccountSummaryDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type IAMAccountSummaryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  IAMAccountSummary `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type IAMAccountSummaryHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []IAMAccountSummaryHit `json:"hits"`
}

type IAMAccountSummarySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  IAMAccountSummaryHits `json:"hits"`
}

type IAMAccountSummaryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccountSummaryPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccountSummaryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_accountsummary", filters, limit)
	if err != nil {
		return IAMAccountSummaryPaginator{}, err
	}

	p := IAMAccountSummaryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccountSummaryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccountSummaryPaginator) NextPage(ctx context.Context) ([]IAMAccountSummary, error) {
	var response IAMAccountSummarySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccountSummary
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccountSummaryFilters = map[string]string{
	"access_keys_per_user_quota":           "description.AccountSummary.AccessKeysPerUserQuota",
	"account_access_keys_present":          "description.AccountSummary.AccountAccessKeysPresent",
	"account_mfa_enabled":                  "description.AccountSummary.AccountMFAEnabled",
	"account_signing_certificates_present": "description.AccountSummary.AccountSigningCertificatesPresent",
	"assume_role_policy_size_quota":        "description.AccountSummary.AssumeRolePolicySizeQuota",
	"attached_policies_per_group_quota":    "description.AccountSummary.AttachedPoliciesPerGroupQuota",
	"attached_policies_per_role_quota":     "description.AccountSummary.AttachedPoliciesPerRoleQuota",
	"attached_policies_per_user_quota":     "description.AccountSummary.AttachedPoliciesPerUserQuota",
	"global_endpoint_token_version":        "description.AccountSummary.GlobalEndpointTokenVersion",
	"group_policy_size_quota":              "description.AccountSummary.GroupPolicySizeQuota",
	"groups":                               "description.AccountSummary.Groups",
	"groups_per_user_quota":                "description.AccountSummary.GroupsPerUserQuota",
	"groups_quota":                         "description.AccountSummary.GroupsQuota",
	"instance_profiles":                    "description.AccountSummary.InstanceProfiles",
	"instance_profiles_quota":              "description.AccountSummary.InstanceProfilesQuota",
	"kaytu_account_id":                     "metadata.SourceID",
	"mfa_devices":                          "description.AccountSummary.MFADevices",
	"mfa_devices_in_use":                   "description.AccountSummary.MFADevicesInUse",
	"policies":                             "description.AccountSummary.Policies",
	"policies_quota":                       "description.AccountSummary.PoliciesQuota",
	"policy_size_quota":                    "description.AccountSummary.PolicySizeQuota",
	"policy_versions_in_use":               "description.AccountSummary.PolicyVersionsInUse",
	"policy_versions_in_use_quota":         "description.AccountSummary.PolicyVersionsInUseQuota",
	"providers":                            "description.AccountSummary.Providers",
	"role_policy_size_quota":               "description.AccountSummary.RolePolicySizeQuota",
	"roles":                                "description.AccountSummary.Roles",
	"roles_quota":                          "description.AccountSummary.RolesQuota",
	"server_certificates":                  "description.AccountSummary.ServerCertificates",
	"server_certificates_quota":            "description.AccountSummary.ServerCertificatesQuota",
	"signing_certificates_per_user_quota":  "description.AccountSummary.SigningCertificatesPerUserQuota",
	"user_policy_size_quota":               "description.AccountSummary.UserPolicySizeQuota",
	"users":                                "description.AccountSummary.Users",
	"users_quota":                          "description.AccountSummary.UsersQuota",
	"versions_per_policy_quota":            "description.AccountSummary.VersionsPerPolicyQuota",
}

func ListIAMAccountSummary(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccountSummary")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMAccountSummaryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMAccountSummaryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMAccountSummaryFilters = map[string]string{
	"access_keys_per_user_quota":           "description.AccountSummary.AccessKeysPerUserQuota",
	"account_access_keys_present":          "description.AccountSummary.AccountAccessKeysPresent",
	"account_mfa_enabled":                  "description.AccountSummary.AccountMFAEnabled",
	"account_signing_certificates_present": "description.AccountSummary.AccountSigningCertificatesPresent",
	"assume_role_policy_size_quota":        "description.AccountSummary.AssumeRolePolicySizeQuota",
	"attached_policies_per_group_quota":    "description.AccountSummary.AttachedPoliciesPerGroupQuota",
	"attached_policies_per_role_quota":     "description.AccountSummary.AttachedPoliciesPerRoleQuota",
	"attached_policies_per_user_quota":     "description.AccountSummary.AttachedPoliciesPerUserQuota",
	"global_endpoint_token_version":        "description.AccountSummary.GlobalEndpointTokenVersion",
	"group_policy_size_quota":              "description.AccountSummary.GroupPolicySizeQuota",
	"groups":                               "description.AccountSummary.Groups",
	"groups_per_user_quota":                "description.AccountSummary.GroupsPerUserQuota",
	"groups_quota":                         "description.AccountSummary.GroupsQuota",
	"instance_profiles":                    "description.AccountSummary.InstanceProfiles",
	"instance_profiles_quota":              "description.AccountSummary.InstanceProfilesQuota",
	"kaytu_account_id":                     "metadata.SourceID",
	"mfa_devices":                          "description.AccountSummary.MFADevices",
	"mfa_devices_in_use":                   "description.AccountSummary.MFADevicesInUse",
	"policies":                             "description.AccountSummary.Policies",
	"policies_quota":                       "description.AccountSummary.PoliciesQuota",
	"policy_size_quota":                    "description.AccountSummary.PolicySizeQuota",
	"policy_versions_in_use":               "description.AccountSummary.PolicyVersionsInUse",
	"policy_versions_in_use_quota":         "description.AccountSummary.PolicyVersionsInUseQuota",
	"providers":                            "description.AccountSummary.Providers",
	"role_policy_size_quota":               "description.AccountSummary.RolePolicySizeQuota",
	"roles":                                "description.AccountSummary.Roles",
	"roles_quota":                          "description.AccountSummary.RolesQuota",
	"server_certificates":                  "description.AccountSummary.ServerCertificates",
	"server_certificates_quota":            "description.AccountSummary.ServerCertificatesQuota",
	"signing_certificates_per_user_quota":  "description.AccountSummary.SigningCertificatesPerUserQuota",
	"user_policy_size_quota":               "description.AccountSummary.UserPolicySizeQuota",
	"users":                                "description.AccountSummary.Users",
	"users_quota":                          "description.AccountSummary.UsersQuota",
	"versions_per_policy_quota":            "description.AccountSummary.VersionsPerPolicyQuota",
}

func GetIAMAccountSummary(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccountSummary")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMAccountSummaryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMAccountSummaryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMAccountSummary =============================

// ==========================  START: IAMAccessKey =============================

type IAMAccessKey struct {
	Description   aws.IAMAccessKeyDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type IAMAccessKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMAccessKey  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMAccessKeyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMAccessKeyHit `json:"hits"`
}

type IAMAccessKeySearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  IAMAccessKeyHits `json:"hits"`
}

type IAMAccessKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccessKeyPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccessKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_accesskey", filters, limit)
	if err != nil {
		return IAMAccessKeyPaginator{}, err
	}

	p := IAMAccessKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccessKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccessKeyPaginator) NextPage(ctx context.Context) ([]IAMAccessKey, error) {
	var response IAMAccessKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccessKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccessKeyFilters = map[string]string{
	"access_key_id":    "description.AccessKey.AccessKeyId",
	"create_date":      "description.AccessKey.CreateDate",
	"kaytu_account_id": "metadata.SourceID",
	"status":           "description.AccessKey.Status",
	"title":            "description.AccessKey.AccessKeyId",
	"user_name":        "description.AccessKey.UserName",
}

func ListIAMAccessKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccessKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMAccessKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMAccessKeyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMAccessKeyFilters = map[string]string{
	"access_key_id":    "description.AccessKey.AccessKeyId",
	"create_date":      "description.AccessKey.CreateDate",
	"kaytu_account_id": "metadata.SourceID",
	"status":           "description.AccessKey.Status",
	"title":            "description.AccessKey.AccessKeyId",
	"user_name":        "description.AccessKey.UserName",
}

func GetIAMAccessKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccessKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMAccessKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMAccessKeyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMAccessKey =============================

// ==========================  START: IAMAccountPasswordPolicy =============================

type IAMAccountPasswordPolicy struct {
	Description   aws.IAMAccountPasswordPolicyDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type IAMAccountPasswordPolicyHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  IAMAccountPasswordPolicy `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type IAMAccountPasswordPolicyHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []IAMAccountPasswordPolicyHit `json:"hits"`
}

type IAMAccountPasswordPolicySearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  IAMAccountPasswordPolicyHits `json:"hits"`
}

type IAMAccountPasswordPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccountPasswordPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccountPasswordPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_accountpasswordpolicy", filters, limit)
	if err != nil {
		return IAMAccountPasswordPolicyPaginator{}, err
	}

	p := IAMAccountPasswordPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccountPasswordPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccountPasswordPolicyPaginator) NextPage(ctx context.Context) ([]IAMAccountPasswordPolicy, error) {
	var response IAMAccountPasswordPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccountPasswordPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccountPasswordPolicyFilters = map[string]string{
	"allow_users_to_change_password": "description.PasswordPolicy.AllowUsersToChangePassword",
	"expire_passwords":               "description.PasswordPolicy.ExpirePasswords",
	"hard_expiry":                    "description.PasswordPolicy.HardExpiry",
	"kaytu_account_id":               "metadata.SourceID",
	"max_password_age":               "description.PasswordPolicy.MaxPasswordAge",
	"minimum_password_length":        "description.PasswordPolicy.MinimumPasswordLength",
	"password_reuse_prevention":      "description.PasswordPolicy.PasswordReusePrevention",
	"require_lowercase_characters":   "description.PasswordPolicy.RequireLowercaseCharacters",
	"require_numbers":                "description.PasswordPolicy.RequireNumbers",
	"require_symbols":                "description.PasswordPolicy.RequireSymbols",
	"require_uppercase_characters":   "description.PasswordPolicy.RequireUppercaseCharacters",
}

func ListIAMAccountPasswordPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccountPasswordPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMAccountPasswordPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMAccountPasswordPolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMAccountPasswordPolicyFilters = map[string]string{
	"allow_users_to_change_password": "description.PasswordPolicy.AllowUsersToChangePassword",
	"expire_passwords":               "description.PasswordPolicy.ExpirePasswords",
	"hard_expiry":                    "description.PasswordPolicy.HardExpiry",
	"kaytu_account_id":               "metadata.SourceID",
	"max_password_age":               "description.PasswordPolicy.MaxPasswordAge",
	"minimum_password_length":        "description.PasswordPolicy.MinimumPasswordLength",
	"password_reuse_prevention":      "description.PasswordPolicy.PasswordReusePrevention",
	"require_lowercase_characters":   "description.PasswordPolicy.RequireLowercaseCharacters",
	"require_numbers":                "description.PasswordPolicy.RequireNumbers",
	"require_symbols":                "description.PasswordPolicy.RequireSymbols",
	"require_uppercase_characters":   "description.PasswordPolicy.RequireUppercaseCharacters",
}

func GetIAMAccountPasswordPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccountPasswordPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMAccountPasswordPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMAccountPasswordPolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMAccountPasswordPolicy =============================

// ==========================  START: IAMUser =============================

type IAMUser struct {
	Description   aws.IAMUserDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type IAMUserHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMUser       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMUserHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMUserHit      `json:"hits"`
}

type IAMUserSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  IAMUserHits `json:"hits"`
}

type IAMUserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMUserPaginator(filters []essdk.BoolFilter, limit *int64) (IAMUserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_user", filters, limit)
	if err != nil {
		return IAMUserPaginator{}, err
	}

	p := IAMUserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMUserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMUserPaginator) NextPage(ctx context.Context) ([]IAMUser, error) {
	var response IAMUserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMUser
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMUserFilters = map[string]string{
	"akas":                      "description.User.Arn",
	"arn":                       "description.User.Arn",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.User.CreateDate",
	"groups":                    "description.Groups",
	"inline_policies":           "description.InlinePolicies",
	"inline_policies_std":       "description.InlinePolicies",
	"kaytu_account_id":          "metadata.SourceID",
	"mfa_devices":               "description.MFADevices",
	"name":                      "description.User.UserName",
	"password_last_used":        "description.User.PasswordLastUsed",
	"path":                      "description.User.Path",
	"permissions_boundary_arn":  "description.User.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.User.PermissionsBoundary.PermissionsBoundaryType",
	"tags_src":                  "description.User.Tags",
	"title":                     "description.User.UserName",
	"user_id":                   "description.User.UserId",
}

func ListIAMUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMUser")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMUserPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMUserFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMUserFilters = map[string]string{
	"akas":                      "description.User.Arn",
	"arn":                       "description.User.Arn",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.User.CreateDate",
	"groups":                    "description.Groups",
	"inline_policies":           "description.InlinePolicies",
	"inline_policies_std":       "description.InlinePolicies",
	"kaytu_account_id":          "metadata.SourceID",
	"mfa_devices":               "description.MFADevices",
	"name":                      "description.User.UserName",
	"password_last_used":        "description.User.PasswordLastUsed",
	"path":                      "description.User.Path",
	"permissions_boundary_arn":  "description.User.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.User.PermissionsBoundary.PermissionsBoundaryType",
	"tags_src":                  "description.User.Tags",
	"title":                     "description.User.UserName",
	"user_id":                   "description.User.UserId",
}

func GetIAMUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMUser")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMUserPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMUserFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMUser =============================

// ==========================  START: IAMGroup =============================

type IAMGroup struct {
	Description   aws.IAMGroupDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type IAMGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMGroup      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMGroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMGroupHit     `json:"hits"`
}

type IAMGroupSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  IAMGroupHits `json:"hits"`
}

type IAMGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMGroupPaginator(filters []essdk.BoolFilter, limit *int64) (IAMGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_group", filters, limit)
	if err != nil {
		return IAMGroupPaginator{}, err
	}

	p := IAMGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMGroupPaginator) NextPage(ctx context.Context) ([]IAMGroup, error) {
	var response IAMGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMGroupFilters = map[string]string{
	"akas":                 "description.Group.Arn",
	"arn":                  "description.Group.Arn",
	"attached_policy_arns": "description.AttachedPolicyArns",
	"create_date":          "description.Group.CreateDate",
	"group_id":             "description.Group.GroupId",
	"inline_policies":      "description.InlinePolicies",
	"inline_policies_std":  "description.InlinePolicies",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.Group.GroupName",
	"path":                 "description.Group.Path",
	"title":                "description.Group.GroupName",
	"users":                "description.Users",
}

func ListIAMGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMGroupFilters = map[string]string{
	"akas":                 "description.Group.Arn",
	"arn":                  "description.Group.Arn",
	"attached_policy_arns": "description.AttachedPolicyArns",
	"create_date":          "description.Group.CreateDate",
	"group_id":             "description.Group.GroupId",
	"inline_policies":      "description.InlinePolicies",
	"inline_policies_std":  "description.InlinePolicies",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.Group.GroupName",
	"path":                 "description.Group.Path",
	"title":                "description.Group.GroupName",
	"users":                "description.Users",
}

func GetIAMGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMGroup =============================

// ==========================  START: IAMRole =============================

type IAMRole struct {
	Description   aws.IAMRoleDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type IAMRoleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMRole       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMRoleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMRoleHit      `json:"hits"`
}

type IAMRoleSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  IAMRoleHits `json:"hits"`
}

type IAMRolePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMRolePaginator(filters []essdk.BoolFilter, limit *int64) (IAMRolePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_role", filters, limit)
	if err != nil {
		return IAMRolePaginator{}, err
	}

	p := IAMRolePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMRolePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMRolePaginator) NextPage(ctx context.Context) ([]IAMRole, error) {
	var response IAMRoleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMRole
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMRoleFilters = map[string]string{
	"akas":                      "description.Role.Arn",
	"arn":                       "description.Role.Arn",
	"assume_role_policy":        "description.Role.AssumeRolePolicyDocument",
	"assume_role_policy_std":    "description.Role.AssumeRolePolicyDocument",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.Role.CreateDate",
	"description":               "description.Role.Description",
	"inline_policies":           "description.InlinePolicies",
	"inline_policies_std":       "description.InlinePolicies",
	"instance_profile_arns":     "description.InstanceProfileArns",
	"kaytu_account_id":          "metadata.SourceID",
	"max_session_duration":      "description.Role.MaxSessionDuration",
	"name":                      "description.Role.RoleName",
	"path":                      "description.Role.Path",
	"permissions_boundary_arn":  "description.Role.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.Role.PermissionsBoundary.PermissionsBoundaryType",
	"role_id":                   "description.Role.RoleId",
	"role_last_used_date":       "description.Role.RoleLastUsed.LastUsedDate",
	"role_last_used_region":     "description.Role.RoleLastUsed.Region",
	"tags_src":                  "description.Role.Tags",
	"title":                     "description.Role.RoleName",
}

func ListIAMRole(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMRole")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMRolePaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMRoleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMRoleFilters = map[string]string{
	"akas":                      "description.Role.Arn",
	"arn":                       "description.Role.Arn",
	"assume_role_policy":        "description.Role.AssumeRolePolicyDocument",
	"assume_role_policy_std":    "description.Role.AssumeRolePolicyDocument",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.Role.CreateDate",
	"description":               "description.Role.Description",
	"inline_policies":           "description.InlinePolicies",
	"inline_policies_std":       "description.InlinePolicies",
	"instance_profile_arns":     "description.InstanceProfileArns",
	"kaytu_account_id":          "metadata.SourceID",
	"max_session_duration":      "description.Role.MaxSessionDuration",
	"name":                      "description.Role.RoleName",
	"path":                      "description.Role.Path",
	"permissions_boundary_arn":  "description.Role.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.Role.PermissionsBoundary.PermissionsBoundaryType",
	"role_id":                   "description.Role.RoleId",
	"role_last_used_date":       "description.Role.RoleLastUsed.LastUsedDate",
	"role_last_used_region":     "description.Role.RoleLastUsed.Region",
	"tags_src":                  "description.Role.Tags",
	"title":                     "description.Role.RoleName",
}

func GetIAMRole(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMRole")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMRolePaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMRoleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMRole =============================

// ==========================  START: IAMServerCertificate =============================

type IAMServerCertificate struct {
	Description   aws.IAMServerCertificateDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type IAMServerCertificateHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  IAMServerCertificate `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type IAMServerCertificateHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []IAMServerCertificateHit `json:"hits"`
}

type IAMServerCertificateSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  IAMServerCertificateHits `json:"hits"`
}

type IAMServerCertificatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMServerCertificatePaginator(filters []essdk.BoolFilter, limit *int64) (IAMServerCertificatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_servercertificate", filters, limit)
	if err != nil {
		return IAMServerCertificatePaginator{}, err
	}

	p := IAMServerCertificatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMServerCertificatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMServerCertificatePaginator) NextPage(ctx context.Context) ([]IAMServerCertificate, error) {
	var response IAMServerCertificateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMServerCertificate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMServerCertificateFilters = map[string]string{
	"akas":                  "description.ServerCertificate.ServerCertificateMetadata.Arn",
	"arn":                   "description.ServerCertificate.ServerCertificateMetadata.Arn",
	"certificate_body":      "description.ServerCertificate.CertificateBody",
	"certificate_chain":     "description.ServerCertificate.CertificateChain",
	"expiration":            "description.ServerCertificate.ServerCertificateMetadata.Expiration",
	"kaytu_account_id":      "metadata.SourceID",
	"name":                  "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"path":                  "description.ServerCertificate.ServerCertificateMetadata.Path",
	"server_certificate_id": "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateId",
	"tags":                  "description.ServerCertificate.Tags",
	"tags_src":              "description.ServerCertificate.Tags",
	"title":                 "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"upload_date":           "description.ServerCertificate.ServerCertificateMetadata.UploadDate",
}

func ListIAMServerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMServerCertificate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMServerCertificatePaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMServerCertificateFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMServerCertificateFilters = map[string]string{
	"akas":                  "description.ServerCertificate.ServerCertificateMetadata.Arn",
	"arn":                   "description.ServerCertificate.ServerCertificateMetadata.Arn",
	"certificate_body":      "description.ServerCertificate.CertificateBody",
	"certificate_chain":     "description.ServerCertificate.CertificateChain",
	"expiration":            "description.ServerCertificate.ServerCertificateMetadata.Expiration",
	"kaytu_account_id":      "metadata.SourceID",
	"name":                  "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"path":                  "description.ServerCertificate.ServerCertificateMetadata.Path",
	"server_certificate_id": "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateId",
	"tags":                  "description.ServerCertificate.Tags",
	"tags_src":              "description.ServerCertificate.Tags",
	"title":                 "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"upload_date":           "description.ServerCertificate.ServerCertificateMetadata.UploadDate",
}

func GetIAMServerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMServerCertificate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMServerCertificatePaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMServerCertificateFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMServerCertificate =============================

// ==========================  START: IAMPolicy =============================

type IAMPolicy struct {
	Description   aws.IAMPolicyDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type IAMPolicyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMPolicy     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMPolicyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMPolicyHit    `json:"hits"`
}

type IAMPolicySearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  IAMPolicyHits `json:"hits"`
}

type IAMPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (IAMPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_policy", filters, limit)
	if err != nil {
		return IAMPolicyPaginator{}, err
	}

	p := IAMPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMPolicyPaginator) NextPage(ctx context.Context) ([]IAMPolicy, error) {
	var response IAMPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMPolicyFilters = map[string]string{
	"akas":                             "arn",
	"arn":                              "description.Policy.Arn",
	"attachment_count":                 "description.Policy.AttachmentCount",
	"create_date":                      "description.Policy.CreateDate",
	"default_version_id":               "description.Policy.DefaultVersionId",
	"is_attachable":                    "description.Policy.IsAttachable",
	"is_attached":                      "description.Policy.AttachmentCount",
	"kaytu_account_id":                 "metadata.SourceID",
	"name":                             "description.Policy.PolicyName",
	"path":                             "description.Policy.Path",
	"permissions_boundary_usage_count": "description.Policy.PermissionsBoundaryUsageCount",
	"policy":                           "description.PolicyVersion.Document",
	"policy_id":                        "description.Policy.PolicyId",
	"policy_std":                       "description.PolicyVersion.Document",
	"tags_src":                         "description.Policy.Tags",
	"title":                            "description.Policy.IsAttachable",
	"update_date":                      "description.Policy.UpdateDate",
}

func ListIAMPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMPolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMPolicyFilters = map[string]string{
	"akas":                             "arn",
	"arn":                              "description.Policy.Arn",
	"attachment_count":                 "description.Policy.AttachmentCount",
	"create_date":                      "description.Policy.CreateDate",
	"default_version_id":               "description.Policy.DefaultVersionId",
	"is_attachable":                    "description.Policy.IsAttachable",
	"is_attached":                      "description.Policy.AttachmentCount",
	"kaytu_account_id":                 "metadata.SourceID",
	"name":                             "description.Policy.PolicyName",
	"path":                             "description.Policy.Path",
	"permissions_boundary_usage_count": "description.Policy.PermissionsBoundaryUsageCount",
	"policy":                           "description.PolicyVersion.Document",
	"policy_id":                        "description.Policy.PolicyId",
	"policy_std":                       "description.PolicyVersion.Document",
	"tags_src":                         "description.Policy.Tags",
	"title":                            "description.Policy.IsAttachable",
	"update_date":                      "description.Policy.UpdateDate",
}

func GetIAMPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMPolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMPolicy =============================

// ==========================  START: IAMCredentialReport =============================

type IAMCredentialReport struct {
	Description   aws.IAMCredentialReportDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type IAMCredentialReportHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  IAMCredentialReport `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type IAMCredentialReportHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []IAMCredentialReportHit `json:"hits"`
}

type IAMCredentialReportSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  IAMCredentialReportHits `json:"hits"`
}

type IAMCredentialReportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMCredentialReportPaginator(filters []essdk.BoolFilter, limit *int64) (IAMCredentialReportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_credentialreport", filters, limit)
	if err != nil {
		return IAMCredentialReportPaginator{}, err
	}

	p := IAMCredentialReportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMCredentialReportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMCredentialReportPaginator) NextPage(ctx context.Context) ([]IAMCredentialReport, error) {
	var response IAMCredentialReportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMCredentialReport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMCredentialReportFilters = map[string]string{
	"access_key_1_active":            "description.CredentialReport.AccessKey1Active",
	"access_key_1_last_rotated":      "description.CredentialReport.AccessKey1LastRotated",
	"access_key_1_last_used_date":    "description.CredentialReport.AccessKey1LastUsedDate",
	"access_key_1_last_used_region":  "description.CredentialReport.AccessKey1LastUsedRegion",
	"access_key_1_last_used_service": "description.CredentialReport.AccessKey1LastUsedService",
	"access_key_2_active":            "description.CredentialReport.AccessKey2Active",
	"access_key_2_last_rotated":      "description.CredentialReport.AccessKey2LastRotated",
	"access_key_2_last_used_date":    "description.CredentialReport.AccessKey2LastUsedDate",
	"access_key_2_last_used_region":  "description.CredentialReport.AccessKey2LastUsedRegion",
	"access_key_2_last_used_service": "description.CredentialReport.AccessKey2LastUsedService",
	"cert_1_active":                  "description.CredentialReport.Cert1Active",
	"cert_1_last_rotated":            "description.CredentialReport.Cert1LastRotated",
	"cert_2_active":                  "description.CredentialReport.Cert2Active",
	"cert_2_last_rotated":            "description.CredentialReport.Cert2LastRotated",
	"generated_time":                 "description.CredentialReport.GeneratedTime",
	"kaytu_account_id":               "metadata.SourceID",
	"mfa_active":                     "description.CredentialReport.MFAActive",
	"password_enabled":               "description.CredentialReport.PasswordEnabled",
	"password_last_changed":          "description.CredentialReport.PasswordLastChanged",
	"password_last_used":             "description.CredentialReport.PasswordLastUsed",
	"password_next_rotation":         "description.CredentialReport.PasswordNextRotation",
	"password_status":                "description.CredentialReport.PasswordLastUsed",
	"user_arn":                       "description.CredentialReport.UserArn",
	"user_creation_time":             "description.CredentialReport.UserCreationTime",
	"user_name":                      "description.CredentialReport.UserName",
}

func ListIAMCredentialReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMCredentialReport")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMCredentialReportPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMCredentialReportFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMCredentialReportFilters = map[string]string{
	"access_key_1_active":            "description.CredentialReport.AccessKey1Active",
	"access_key_1_last_rotated":      "description.CredentialReport.AccessKey1LastRotated",
	"access_key_1_last_used_date":    "description.CredentialReport.AccessKey1LastUsedDate",
	"access_key_1_last_used_region":  "description.CredentialReport.AccessKey1LastUsedRegion",
	"access_key_1_last_used_service": "description.CredentialReport.AccessKey1LastUsedService",
	"access_key_2_active":            "description.CredentialReport.AccessKey2Active",
	"access_key_2_last_rotated":      "description.CredentialReport.AccessKey2LastRotated",
	"access_key_2_last_used_date":    "description.CredentialReport.AccessKey2LastUsedDate",
	"access_key_2_last_used_region":  "description.CredentialReport.AccessKey2LastUsedRegion",
	"access_key_2_last_used_service": "description.CredentialReport.AccessKey2LastUsedService",
	"cert_1_active":                  "description.CredentialReport.Cert1Active",
	"cert_1_last_rotated":            "description.CredentialReport.Cert1LastRotated",
	"cert_2_active":                  "description.CredentialReport.Cert2Active",
	"cert_2_last_rotated":            "description.CredentialReport.Cert2LastRotated",
	"generated_time":                 "description.CredentialReport.GeneratedTime",
	"kaytu_account_id":               "metadata.SourceID",
	"mfa_active":                     "description.CredentialReport.MFAActive",
	"password_enabled":               "description.CredentialReport.PasswordEnabled",
	"password_last_changed":          "description.CredentialReport.PasswordLastChanged",
	"password_last_used":             "description.CredentialReport.PasswordLastUsed",
	"password_next_rotation":         "description.CredentialReport.PasswordNextRotation",
	"password_status":                "description.CredentialReport.PasswordLastUsed",
	"user_arn":                       "description.CredentialReport.UserArn",
	"user_creation_time":             "description.CredentialReport.UserCreationTime",
	"user_name":                      "description.CredentialReport.UserName",
}

func GetIAMCredentialReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMCredentialReport")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMCredentialReportPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMCredentialReportFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMCredentialReport =============================

// ==========================  START: IAMVirtualMFADevice =============================

type IAMVirtualMFADevice struct {
	Description   aws.IAMVirtualMFADeviceDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type IAMVirtualMFADeviceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  IAMVirtualMFADevice `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type IAMVirtualMFADeviceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []IAMVirtualMFADeviceHit `json:"hits"`
}

type IAMVirtualMFADeviceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  IAMVirtualMFADeviceHits `json:"hits"`
}

type IAMVirtualMFADevicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMVirtualMFADevicePaginator(filters []essdk.BoolFilter, limit *int64) (IAMVirtualMFADevicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_virtualmfadevice", filters, limit)
	if err != nil {
		return IAMVirtualMFADevicePaginator{}, err
	}

	p := IAMVirtualMFADevicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMVirtualMFADevicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMVirtualMFADevicePaginator) NextPage(ctx context.Context) ([]IAMVirtualMFADevice, error) {
	var response IAMVirtualMFADeviceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMVirtualMFADevice
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMVirtualMFADeviceFilters = map[string]string{
	"akas":             "description.VirtualMFADevice.SerialNumber",
	"enable_date":      "description.VirtualMFADevice.EnableDate",
	"kaytu_account_id": "metadata.SourceID",
	"serial_number":    "description.VirtualMFADevice.SerialNumber",
	"tags_src":         "description.Tags",
	"title":            "description.VirtualMFADevice.SerialNumber",
	"user":             "description.VirtualMFADevice.User",
	"user_id":          "description.VirtualMFADevice.User.UserId",
	"user_name":        "description.VirtualMFADevice.User.UserName",
}

func ListIAMVirtualMFADevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMVirtualMFADevice")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMVirtualMFADevicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMVirtualMFADeviceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMVirtualMFADeviceFilters = map[string]string{
	"akas":             "description.VirtualMFADevice.SerialNumber",
	"enable_date":      "description.VirtualMFADevice.EnableDate",
	"kaytu_account_id": "metadata.SourceID",
	"serial_number":    "description.VirtualMFADevice.SerialNumber",
	"tags_src":         "description.Tags",
	"title":            "description.VirtualMFADevice.SerialNumber",
	"user":             "description.VirtualMFADevice.User",
	"user_id":          "description.VirtualMFADevice.User.UserId",
	"user_name":        "description.VirtualMFADevice.User.UserName",
}

func GetIAMVirtualMFADevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMVirtualMFADevice")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMVirtualMFADevicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMVirtualMFADeviceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMVirtualMFADevice =============================

// ==========================  START: IAMPolicyAttachment =============================

type IAMPolicyAttachment struct {
	Description   aws.IAMPolicyAttachmentDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type IAMPolicyAttachmentHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  IAMPolicyAttachment `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type IAMPolicyAttachmentHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []IAMPolicyAttachmentHit `json:"hits"`
}

type IAMPolicyAttachmentSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  IAMPolicyAttachmentHits `json:"hits"`
}

type IAMPolicyAttachmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMPolicyAttachmentPaginator(filters []essdk.BoolFilter, limit *int64) (IAMPolicyAttachmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_policyattachment", filters, limit)
	if err != nil {
		return IAMPolicyAttachmentPaginator{}, err
	}

	p := IAMPolicyAttachmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMPolicyAttachmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMPolicyAttachmentPaginator) NextPage(ctx context.Context) ([]IAMPolicyAttachment, error) {
	var response IAMPolicyAttachmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMPolicyAttachment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMPolicyAttachmentFilters = map[string]string{
	"is_attached":      "description.PolicyAttachmentCount",
	"kaytu_account_id": "metadata.SourceID",
	"policy_arn":       "description.PolicyArn",
	"policy_groups":    "description.PolicyGroups",
	"policy_roles":     "description.PolicyRoles",
	"policy_users":     "description.PolicyUsers",
}

func ListIAMPolicyAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMPolicyAttachment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMPolicyAttachmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMPolicyAttachmentFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMPolicyAttachmentFilters = map[string]string{
	"is_attached":      "description.IsAttached",
	"kaytu_account_id": "metadata.SourceID",
	"policy_arn":       "description.PolicyArn",
	"policy_groups":    "description.PolicyGroups",
	"policy_roles":     "description.PolicyRoles",
	"policy_users":     "description.PolicyUsers",
}

func GetIAMPolicyAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMPolicyAttachment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMPolicyAttachmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMPolicyAttachmentFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMPolicyAttachment =============================

// ==========================  START: IAMSamlProvider =============================

type IAMSamlProvider struct {
	Description   aws.IAMSamlProviderDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type IAMSamlProviderHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  IAMSamlProvider `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type IAMSamlProviderHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []IAMSamlProviderHit `json:"hits"`
}

type IAMSamlProviderSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  IAMSamlProviderHits `json:"hits"`
}

type IAMSamlProviderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMSamlProviderPaginator(filters []essdk.BoolFilter, limit *int64) (IAMSamlProviderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_samlprovider", filters, limit)
	if err != nil {
		return IAMSamlProviderPaginator{}, err
	}

	p := IAMSamlProviderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMSamlProviderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMSamlProviderPaginator) NextPage(ctx context.Context) ([]IAMSamlProvider, error) {
	var response IAMSamlProviderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMSamlProvider
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMSamlProviderFilters = map[string]string{
	"akas":                   "aRN",
	"arn":                    "aRN",
	"create_date":            "description.SamlProvider.CreateDate",
	"kaytu_account_id":       "metadata.SourceID",
	"saml_metadata_document": "description.SamlProvider.SAMLMetadataDocument",
	"tags_src":               "description.SamlProvider.Tags",
	"valid_until":            "description.SamlProvider.ValidUntil",
}

func ListIAMSamlProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMSamlProvider")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMSamlProviderPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMSamlProviderFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMSamlProviderFilters = map[string]string{
	"akas":                   "aRN",
	"arn":                    "ARN",
	"create_date":            "description.SamlProvider.CreateDate",
	"kaytu_account_id":       "metadata.SourceID",
	"saml_metadata_document": "description.SamlProvider.SAMLMetadataDocument",
	"tags_src":               "description.SamlProvider.Tags",
	"valid_until":            "description.SamlProvider.ValidUntil",
}

func GetIAMSamlProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMSamlProvider")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMSamlProviderPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMSamlProviderFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMSamlProvider =============================

// ==========================  START: IAMServiceSpecificCredential =============================

type IAMServiceSpecificCredential struct {
	Description   aws.IAMServiceSpecificCredentialDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type IAMServiceSpecificCredentialHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  IAMServiceSpecificCredential `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type IAMServiceSpecificCredentialHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []IAMServiceSpecificCredentialHit `json:"hits"`
}

type IAMServiceSpecificCredentialSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  IAMServiceSpecificCredentialHits `json:"hits"`
}

type IAMServiceSpecificCredentialPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMServiceSpecificCredentialPaginator(filters []essdk.BoolFilter, limit *int64) (IAMServiceSpecificCredentialPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_servicespecificcredential", filters, limit)
	if err != nil {
		return IAMServiceSpecificCredentialPaginator{}, err
	}

	p := IAMServiceSpecificCredentialPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMServiceSpecificCredentialPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMServiceSpecificCredentialPaginator) NextPage(ctx context.Context) ([]IAMServiceSpecificCredential, error) {
	var response IAMServiceSpecificCredentialSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMServiceSpecificCredential
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMServiceSpecificCredentialFilters = map[string]string{
	"create_date":                    "description.ServiceSpecificCredential.CreateDate",
	"kaytu_account_id":               "metadata.SourceID",
	"service_name":                   "description.ServiceSpecificCredential.ServiceName",
	"service_specific_credential_id": "description.ServiceSpecificCredential.ServiceSpecificCredentialId",
	"service_user_name":              "description.ServiceSpecificCredential.ServiceUserName",
	"status":                         "description.ServiceSpecificCredential.Status",
	"title":                          "description.ServiceSpecificCredential.ServiceName",
	"user_name":                      "description.ServiceSpecificCredential.UserName",
}

func ListIAMServiceSpecificCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMServiceSpecificCredential")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIAMServiceSpecificCredentialPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIAMServiceSpecificCredentialFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIAMServiceSpecificCredentialFilters = map[string]string{
	"create_date":                    "description.ServiceSpecificCredential.CreateDate",
	"kaytu_account_id":               "metadata.SourceID",
	"service_name":                   "description.ServiceSpecificCredential.ServiceName",
	"service_specific_credential_id": "description.ServiceSpecificCredential.ServiceSpecificCredentialId",
	"service_user_name":              "description.ServiceSpecificCredential.ServiceUserName",
	"status":                         "description.ServiceSpecificCredential.Status",
	"title":                          "description.ServiceSpecificCredential.ServiceName",
	"user_name":                      "description.ServiceSpecificCredential.UserName",
}

func GetIAMServiceSpecificCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMServiceSpecificCredential")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIAMServiceSpecificCredentialPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIAMServiceSpecificCredentialFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IAMServiceSpecificCredential =============================

// ==========================  START: RDSDBCluster =============================

type RDSDBCluster struct {
	Description   aws.RDSDBClusterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type RDSDBClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RDSDBClusterHit `json:"hits"`
}

type RDSDBClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  RDSDBClusterHits `json:"hits"`
}

type RDSDBClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBClusterPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbcluster", filters, limit)
	if err != nil {
		return RDSDBClusterPaginator{}, err
	}

	p := RDSDBClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBClusterPaginator) NextPage(ctx context.Context) ([]RDSDBCluster, error) {
	var response RDSDBClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBClusterFilters = map[string]string{
	"activity_stream_kinesis_stream_name": "description.DBCluster.ActivityStreamKinesisStreamName",
	"activity_stream_kms_key_id":          "description.DBCluster.ActivityStreamKmsKeyId",
	"activity_stream_mode":                "description.DBCluster.ActivityStreamMode",
	"activity_stream_status":              "description.DBCluster.ActivityStreamStatus",
	"akas":                                "description.DBCluster.DBClusterArn",
	"allocated_storage":                   "description.DBCluster.AllocatedStorage",
	"arn":                                 "dBClusterArn",
	"associated_roles":                    "description.DBCluster.AssociatedRoles",
	"availability_zones":                  "description.DBCluster.AvailabilityZones",
	"backtrack_consumed_change_records":   "description.DBCluster.BacktrackConsumedChangeRecords",
	"backtrack_window":                    "description.DBCluster.BacktrackWindow",
	"backup_retention_period":             "description.DBCluster.BackupRetentionPeriod",
	"capacity":                            "description.DBCluster.Capacity",
	"character_set_name":                  "description.DBCluster.CharacterSetName",
	"clone_group_id":                      "description.DBCluster.CloneGroupId",
	"copy_tags_to_snapshot":               "description.DBCluster.CopyTagsToSnapshot",
	"create_time":                         "description.DBCluster.ClusterCreateTime",
	"cross_account_clone":                 "description.DBCluster.CrossAccountClone",
	"custom_endpoints":                    "description.DBCluster.CustomEndpoints",
	"database_name":                       "description.DBCluster.DatabaseName",
	"db_cluster_identifier":               "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":          "description.DBCluster.DBClusterParameterGroup",
	"db_subnet_group":                     "description.DBCluster.DBSubnetGroup",
	"deletion_protection":                 "description.DBCluster.DeletionProtection",
	"domain_memberships":                  "description.DBCluster.DomainMemberships",
	"earliest_backtrack_time":             "description.DBCluster.EarliestBacktrackTime",
	"earliest_restorable_time":            "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.DBCluster.Endpoint",
	"engine":                              "description.DBCluster.Engine",
	"engine_mode":                         "description.DBCluster.EngineMode",
	"engine_version":                      "description.DBCluster.EngineVersion",
	"global_write_forwarding_requested":   "description.DBCluster.GlobalWriteForwardingRequested",
	"global_write_forwarding_status":      "description.DBCluster.GlobalWriteForwardingStatus",
	"hosted_zone_id":                      "description.DBCluster.HostedZoneId",
	"http_endpoint_enabled":               "description.DBCluster.HttpEndpointEnabled",
	"iam_database_authentication_enabled": "description.DBCluster.IAMDatabaseAuthenticationEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.DBCluster.KmsKeyId",
	"latest_restorable_time":              "description.DBCluster.LatestRestorableTime",
	"master_user_name":                    "description.DBCluster.MasterUsername",
	"members":                             "description.DBCluster.DBClusterMembers",
	"multi_az":                            "description.DBCluster.MultiAZ",
	"option_group_memberships":            "description.DBCluster.DBClusterOptionGroupMemberships",
	"percent_progress":                    "description.DBCluster.PercentProgress",
	"port":                                "description.DBCluster.Port",
	"preferred_backup_window":             "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.DBCluster.ReaderEndpoint",
	"resource_id":                         "description.DBCluster.DbClusterResourceId",
	"status":                              "description.DBCluster.Status",
	"storage_encrypted":                   "description.DBCluster.StorageEncrypted",
	"tags_src":                            "description.DBCluster.TagList",
	"title":                               "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.DBCluster.VpcSecurityGroups",
}

func ListRDSDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBClusterFilters = map[string]string{
	"activity_stream_kinesis_stream_name": "description.DBCluster.ActivityStreamKinesisStreamName",
	"activity_stream_kms_key_id":          "description.DBCluster.ActivityStreamKmsKeyId",
	"activity_stream_mode":                "description.DBCluster.ActivityStreamMode",
	"activity_stream_status":              "description.DBCluster.ActivityStreamStatus",
	"akas":                                "description.DBCluster.DBClusterArn",
	"allocated_storage":                   "description.DBCluster.AllocatedStorage",
	"arn":                                 "dBClusterArn",
	"associated_roles":                    "description.DBCluster.AssociatedRoles",
	"availability_zones":                  "description.DBCluster.AvailabilityZones",
	"backtrack_consumed_change_records":   "description.DBCluster.BacktrackConsumedChangeRecords",
	"backtrack_window":                    "description.DBCluster.BacktrackWindow",
	"backup_retention_period":             "description.DBCluster.BackupRetentionPeriod",
	"capacity":                            "description.DBCluster.Capacity",
	"character_set_name":                  "description.DBCluster.CharacterSetName",
	"clone_group_id":                      "description.DBCluster.CloneGroupId",
	"copy_tags_to_snapshot":               "description.DBCluster.CopyTagsToSnapshot",
	"create_time":                         "description.DBCluster.ClusterCreateTime",
	"cross_account_clone":                 "description.DBCluster.CrossAccountClone",
	"custom_endpoints":                    "description.DBCluster.CustomEndpoints",
	"database_name":                       "description.DBCluster.DatabaseName",
	"db_cluster_identifier":               "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":          "description.DBCluster.DBClusterParameterGroup",
	"db_subnet_group":                     "description.DBCluster.DBSubnetGroup",
	"deletion_protection":                 "description.DBCluster.DeletionProtection",
	"domain_memberships":                  "description.DBCluster.DomainMemberships",
	"earliest_backtrack_time":             "description.DBCluster.EarliestBacktrackTime",
	"earliest_restorable_time":            "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.DBCluster.Endpoint",
	"engine":                              "description.DBCluster.Engine",
	"engine_mode":                         "description.DBCluster.EngineMode",
	"engine_version":                      "description.DBCluster.EngineVersion",
	"global_write_forwarding_requested":   "description.DBCluster.GlobalWriteForwardingRequested",
	"global_write_forwarding_status":      "description.DBCluster.GlobalWriteForwardingStatus",
	"hosted_zone_id":                      "description.DBCluster.HostedZoneId",
	"http_endpoint_enabled":               "description.DBCluster.HttpEndpointEnabled",
	"iam_database_authentication_enabled": "description.DBCluster.IAMDatabaseAuthenticationEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.DBCluster.KmsKeyId",
	"latest_restorable_time":              "description.DBCluster.LatestRestorableTime",
	"master_user_name":                    "description.DBCluster.MasterUsername",
	"members":                             "description.DBCluster.DBClusterMembers",
	"multi_az":                            "description.DBCluster.MultiAZ",
	"option_group_memberships":            "description.DBCluster.DBClusterOptionGroupMemberships",
	"percent_progress":                    "description.DBCluster.PercentProgress",
	"port":                                "description.DBCluster.Port",
	"preferred_backup_window":             "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.DBCluster.ReaderEndpoint",
	"resource_id":                         "description.DBCluster.DbClusterResourceId",
	"status":                              "description.DBCluster.Status",
	"storage_encrypted":                   "description.DBCluster.StorageEncrypted",
	"tags_src":                            "description.DBCluster.TagList",
	"title":                               "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.DBCluster.VpcSecurityGroups",
}

func GetRDSDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBCluster =============================

// ==========================  START: RDSDBClusterParameterGroup =============================

type RDSDBClusterParameterGroup struct {
	Description   aws.RDSDBClusterParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type RDSDBClusterParameterGroupHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  RDSDBClusterParameterGroup `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type RDSDBClusterParameterGroupHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []RDSDBClusterParameterGroupHit `json:"hits"`
}

type RDSDBClusterParameterGroupSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  RDSDBClusterParameterGroupHits `json:"hits"`
}

type RDSDBClusterParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBClusterParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBClusterParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbclusterparametergroup", filters, limit)
	if err != nil {
		return RDSDBClusterParameterGroupPaginator{}, err
	}

	p := RDSDBClusterParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBClusterParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBClusterParameterGroupPaginator) NextPage(ctx context.Context) ([]RDSDBClusterParameterGroup, error) {
	var response RDSDBClusterParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBClusterParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBClusterParameterGroupFilters = map[string]string{
	"akas":                      "description.DBClusterParameterGroup.DBClusterParameterGroupArn",
	"arn":                       "description.DBClusterParameterGroup.DBClusterParameterGroupArn",
	"db_parameter_group_family": "description.DBClusterParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBClusterParameterGroup.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.DBClusterParameterGroup.DBClusterParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBClusterParameterGroup.DBClusterParameterGroupName",
}

func ListRDSDBClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBClusterParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBClusterParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBClusterParameterGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBClusterParameterGroupFilters = map[string]string{
	"akas":                      "description.DBClusterParameterGroup.DBClusterParameterGroupArn",
	"arn":                       "description.DBClusterParameterGroup.DBClusterParameterGroupArn",
	"db_parameter_group_family": "description.DBClusterParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBClusterParameterGroup.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.DBClusterParameterGroup.DBClusterParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBClusterParameterGroup.DBClusterParameterGroupName",
}

func GetRDSDBClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBClusterParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBClusterParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBClusterParameterGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBClusterParameterGroup =============================

// ==========================  START: RDSOptionGroup =============================

type RDSOptionGroup struct {
	Description   aws.RDSOptionGroupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type RDSOptionGroupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RDSOptionGroup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RDSOptionGroupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RDSOptionGroupHit `json:"hits"`
}

type RDSOptionGroupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RDSOptionGroupHits `json:"hits"`
}

type RDSOptionGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSOptionGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSOptionGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_optiongroup", filters, limit)
	if err != nil {
		return RDSOptionGroupPaginator{}, err
	}

	p := RDSOptionGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSOptionGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSOptionGroupPaginator) NextPage(ctx context.Context) ([]RDSOptionGroup, error) {
	var response RDSOptionGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSOptionGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSOptionGroupFilters = map[string]string{
	"akas": "description.OptionGroup.OptionGroupArn",
	"allows_vpc_and_non_vpc_instance_memberships": "description.OptionGroup.AllowsVpcAndNonVpcInstanceMemberships",
	"arn":                  "description.OptionGroup.OptionGroupArn",
	"description":          "description.OptionGroup.OptionGroupDescription",
	"engine_name":          "description.OptionGroup.EngineName",
	"kaytu_account_id":     "metadata.SourceID",
	"major_engine_version": "description.OptionGroup.MajorEngineVersion",
	"name":                 "description.OptionGroup.OptionGroupName",
	"options":              "description.OptionGroup.Options",
	"tags_src":             "description.Tags.TagList",
	"title":                "description.OptionGroup.OptionGroupName",
	"vpc_id":               "description.OptionGroup.VpcId",
}

func ListRDSOptionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSOptionGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSOptionGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSOptionGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSOptionGroupFilters = map[string]string{
	"akas": "description.OptionGroup.OptionGroupArn",
	"allows_vpc_and_non_vpc_instance_memberships": "description.OptionGroup.AllowsVpcAndNonVpcInstanceMemberships",
	"arn":                  "description.OptionGroup.OptionGroupArn",
	"description":          "description.OptionGroup.OptionGroupDescription",
	"engine_name":          "description.OptionGroup.EngineName",
	"kaytu_account_id":     "metadata.SourceID",
	"major_engine_version": "description.OptionGroup.MajorEngineVersion",
	"name":                 "description.OptionGroup.OptionGroupName",
	"options":              "description.OptionGroup.Options",
	"tags_src":             "description.Tags.TagList",
	"title":                "description.OptionGroup.OptionGroupName",
	"vpc_id":               "description.OptionGroup.VpcId",
}

func GetRDSOptionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSOptionGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSOptionGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSOptionGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSOptionGroup =============================

// ==========================  START: RDSDBParameterGroup =============================

type RDSDBParameterGroup struct {
	Description   aws.RDSDBParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type RDSDBParameterGroupHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RDSDBParameterGroup `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RDSDBParameterGroupHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RDSDBParameterGroupHit `json:"hits"`
}

type RDSDBParameterGroupSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RDSDBParameterGroupHits `json:"hits"`
}

type RDSDBParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbparametergroup", filters, limit)
	if err != nil {
		return RDSDBParameterGroupPaginator{}, err
	}

	p := RDSDBParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBParameterGroupPaginator) NextPage(ctx context.Context) ([]RDSDBParameterGroup, error) {
	var response RDSDBParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBParameterGroupFilters = map[string]string{
	"akas":                      "description.DBParameterGroup.DBParameterGroupArn",
	"arn":                       "dBParameterGroupArn",
	"db_parameter_group_family": "description.DBParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBParameterGroup.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.DBParameterGroup.DBParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBParameterGroup.DBParameterGroupName",
}

func ListRDSDBParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBParameterGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBParameterGroupFilters = map[string]string{
	"akas":                      "description.DBParameterGroup.DBParameterGroupArn",
	"arn":                       "dBParameterGroupArn",
	"db_parameter_group_family": "description.DBParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBParameterGroup.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.DBParameterGroup.DBParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBParameterGroup.DBParameterGroupName",
}

func GetRDSDBParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBParameterGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBParameterGroup =============================

// ==========================  START: RDSDBProxy =============================

type RDSDBProxy struct {
	Description   aws.RDSDBProxyDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type RDSDBProxyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBProxy    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBProxyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RDSDBProxyHit   `json:"hits"`
}

type RDSDBProxySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RDSDBProxyHits `json:"hits"`
}

type RDSDBProxyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBProxyPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBProxyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbproxy", filters, limit)
	if err != nil {
		return RDSDBProxyPaginator{}, err
	}

	p := RDSDBProxyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBProxyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBProxyPaginator) NextPage(ctx context.Context) ([]RDSDBProxy, error) {
	var response RDSDBProxySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBProxy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBProxyFilters = map[string]string{
	"akas":                   "description.DBProxy.DBProxyArn",
	"auth":                   "description.DBProxy.Auth",
	"created_date":           "description.DBProxy.CreatedDate",
	"db_proxy_arn":           "description.DBProxy.DBProxyArn",
	"db_proxy_name":          "description.DBProxy.DBProxyName",
	"debug_logging":          "description.DBProxy.DebugLogging",
	"endpoint":               "description.DBProxy.Endpoint",
	"engine_family":          "description.DBProxy.EngineFamily",
	"idle_client_timeout":    "description.DBProxy.IdleClientTimeout",
	"kaytu_account_id":       "metadata.SourceID",
	"require_tls":            "description.DBProxy.RequireTLS",
	"role_arn":               "description.DBProxy.RoleArn",
	"status":                 "description.DBProxy.Status",
	"tags":                   "description.Tags",
	"title":                  "description.DBProxy.DBProxyName",
	"updated_date":           "description.DBProxy.UpdatedDate",
	"vpc_id":                 "description.DBProxy.VpcId",
	"vpc_security_group_ids": "description.DBProxy.VpcSecurityGroupIds",
	"vpc_subnet_ids":         "description.DBProxy.VpcSubnetIds",
}

func ListRDSDBProxy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBProxy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBProxyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBProxyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBProxyFilters = map[string]string{
	"akas":                   "description.DBProxy.DBProxyArn",
	"auth":                   "description.DBProxy.Auth",
	"created_date":           "description.DBProxy.CreatedDate",
	"db_proxy_arn":           "description.DBProxy.DBProxyArn",
	"db_proxy_name":          "description.DBProxy.DBProxyName",
	"debug_logging":          "description.DBProxy.DebugLogging",
	"endpoint":               "description.DBProxy.Endpoint",
	"engine_family":          "description.DBProxy.EngineFamily",
	"idle_client_timeout":    "description.DBProxy.IdleClientTimeout",
	"kaytu_account_id":       "metadata.SourceID",
	"require_tls":            "description.DBProxy.RequireTLS",
	"role_arn":               "description.DBProxy.RoleArn",
	"status":                 "description.DBProxy.Status",
	"tags":                   "description.Tags",
	"title":                  "description.DBProxy.DBProxyName",
	"updated_date":           "description.DBProxy.UpdatedDate",
	"vpc_id":                 "description.DBProxy.VpcId",
	"vpc_security_group_ids": "description.DBProxy.VpcSecurityGroupIds",
	"vpc_subnet_ids":         "description.DBProxy.VpcSubnetIds",
}

func GetRDSDBProxy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBProxy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBProxyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBProxyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBProxy =============================

// ==========================  START: RDSDBSubnetGroup =============================

type RDSDBSubnetGroup struct {
	Description   aws.RDSDBSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RDSDBSubnetGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  RDSDBSubnetGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type RDSDBSubnetGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []RDSDBSubnetGroupHit `json:"hits"`
}

type RDSDBSubnetGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  RDSDBSubnetGroupHits `json:"hits"`
}

type RDSDBSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbsubnetgroup", filters, limit)
	if err != nil {
		return RDSDBSubnetGroupPaginator{}, err
	}

	p := RDSDBSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBSubnetGroupPaginator) NextPage(ctx context.Context) ([]RDSDBSubnetGroup, error) {
	var response RDSDBSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBSubnetGroupFilters = map[string]string{
	"akas":             "description.DBSubnetGroup.DBSubnetGroupArn",
	"arn":              "description.DBSubnetGroup.DBSubnetGroupArn",
	"description":      "description.DBSubnetGroup.DBSubnetGroupDescription",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.DBSubnetGroup.DBSubnetGroupName",
	"status":           "description.DBSubnetGroup.SubnetGroupStatus",
	"subnets":          "description.DBSubnetGroup.Subnets",
	"tags_src":         "description.Tags.TagList",
	"title":            "description.DBSubnetGroup.DBSubnetGroupName",
	"vpc_id":           "description.DBSubnetGroup.VpcId",
}

func ListRDSDBSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBSubnetGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBSubnetGroupFilters = map[string]string{
	"akas":             "description.DBSubnetGroup.DBSubnetGroupArn",
	"arn":              "description.DBSubnetGroup.DBSubnetGroupArn",
	"description":      "description.DBSubnetGroup.DBSubnetGroupDescription",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.DBSubnetGroup.DBSubnetGroupName",
	"status":           "description.DBSubnetGroup.SubnetGroupStatus",
	"subnets":          "description.DBSubnetGroup.Subnets",
	"tags_src":         "description.Tags.TagList",
	"title":            "description.DBSubnetGroup.DBSubnetGroupName",
	"vpc_id":           "description.DBSubnetGroup.VpcId",
}

func GetRDSDBSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBSubnetGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBSubnetGroup =============================

// ==========================  START: RDSDBClusterSnapshot =============================

type RDSDBClusterSnapshot struct {
	Description   aws.RDSDBClusterSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type RDSDBClusterSnapshotHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  RDSDBClusterSnapshot `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type RDSDBClusterSnapshotHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []RDSDBClusterSnapshotHit `json:"hits"`
}

type RDSDBClusterSnapshotSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  RDSDBClusterSnapshotHits `json:"hits"`
}

type RDSDBClusterSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBClusterSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBClusterSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbclustersnapshot", filters, limit)
	if err != nil {
		return RDSDBClusterSnapshotPaginator{}, err
	}

	p := RDSDBClusterSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBClusterSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBClusterSnapshotPaginator) NextPage(ctx context.Context) ([]RDSDBClusterSnapshot, error) {
	var response RDSDBClusterSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBClusterSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBClusterSnapshotFilters = map[string]string{
	"akas":                                "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"allocated_storage":                   "description.DBClusterSnapshot.AllocatedStorage",
	"arn":                                 "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"availability_zones":                  "description.DBClusterSnapshot.AvailabilityZones",
	"cluster_create_time":                 "description.DBClusterSnapshot.ClusterCreateTime",
	"create_time":                         "description.DBClusterSnapshot.ClusterCreateTime",
	"db_cluster_identifier":               "description.DBClusterSnapshot.DBClusterIdentifier",
	"db_cluster_snapshot_attributes":      "description.Attributes.DBClusterSnapshotAttributes",
	"db_cluster_snapshot_identifier":      "description.DBClusterSnapshot.DBClusterSnapshotIdentifier",
	"engine":                              "description.DBClusterSnapshot.Engine",
	"engine_version":                      "description.DBClusterSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBClusterSnapshot.IAMDatabaseAuthenticationEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.DBClusterSnapshot.KmsKeyId",
	"license_model":                       "description.DBClusterSnapshot.LicenseModel",
	"master_user_name":                    "description.DBClusterSnapshot.MasterUsername",
	"percent_progress":                    "description.DBClusterSnapshot.PercentProgress",
	"port":                                "description.DBClusterSnapshot.Port",
	"source_db_cluster_snapshot_arn":      "description.DBClusterSnapshot.SourceDBClusterSnapshotArn",
	"status":                              "description.DBClusterSnapshot.Status",
	"storage_encrypted":                   "description.DBClusterSnapshot.StorageEncrypted",
	"tags_src":                            "description.DBClusterSnapshot.TagList",
	"title":                               "description.DBClusterSnapshot.DBClusterSnapshotIdentifier",
	"type":                                "description.DBClusterSnapshot.SnapshotType",
	"vpc_id":                              "description.DBClusterSnapshot.VpcId",
}

func ListRDSDBClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBClusterSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBClusterSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBClusterSnapshotFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBClusterSnapshotFilters = map[string]string{
	"akas":                                "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"allocated_storage":                   "description.DBClusterSnapshot.AllocatedStorage",
	"arn":                                 "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"availability_zones":                  "description.DBClusterSnapshot.AvailabilityZones",
	"cluster_create_time":                 "description.DBClusterSnapshot.ClusterCreateTime",
	"create_time":                         "description.DBClusterSnapshot.ClusterCreateTime",
	"db_cluster_identifier":               "description.DBClusterSnapshot.DBClusterIdentifier",
	"db_cluster_snapshot_attributes":      "description.Attributes.DBClusterSnapshotAttributes",
	"db_cluster_snapshot_identifier":      "description.DBClusterSnapshot.DBClusterIdentifier",
	"engine":                              "description.DBClusterSnapshot.Engine",
	"engine_version":                      "description.DBClusterSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBClusterSnapshot.IAMDatabaseAuthenticationEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.DBClusterSnapshot.KmsKeyId",
	"license_model":                       "description.DBClusterSnapshot.LicenseModel",
	"master_user_name":                    "description.DBClusterSnapshot.MasterUsername",
	"percent_progress":                    "description.DBClusterSnapshot.PercentProgress",
	"port":                                "description.DBClusterSnapshot.Port",
	"source_db_cluster_snapshot_arn":      "description.DBClusterSnapshot.SourceDBClusterSnapshotArn",
	"status":                              "description.DBClusterSnapshot.Status",
	"storage_encrypted":                   "description.DBClusterSnapshot.StorageEncrypted",
	"tags_src":                            "description.DBClusterSnapshot.TagList",
	"title":                               "description.DBClusterSnapshot.DBClusterSnapshotIdentifier",
	"type":                                "description.DBClusterSnapshot.SnapshotType",
	"vpc_id":                              "description.DBClusterSnapshot.VpcId",
}

func GetRDSDBClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBClusterSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBClusterSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBClusterSnapshotFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBClusterSnapshot =============================

// ==========================  START: RDSDBEventSubscription =============================

type RDSDBEventSubscription struct {
	Description   aws.RDSDBEventSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type RDSDBEventSubscriptionHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  RDSDBEventSubscription `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type RDSDBEventSubscriptionHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []RDSDBEventSubscriptionHit `json:"hits"`
}

type RDSDBEventSubscriptionSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  RDSDBEventSubscriptionHits `json:"hits"`
}

type RDSDBEventSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBEventSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBEventSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbeventsubscription", filters, limit)
	if err != nil {
		return RDSDBEventSubscriptionPaginator{}, err
	}

	p := RDSDBEventSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBEventSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBEventSubscriptionPaginator) NextPage(ctx context.Context) ([]RDSDBEventSubscription, error) {
	var response RDSDBEventSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBEventSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBEventSubscriptionFilters = map[string]string{
	"akas":                  "description.EventSubscription.EventSubscriptionArn",
	"arn":                   "description.EventSubscription.EventSubscriptionArn",
	"cust_subscription_id":  "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":       "description.EventSubscription.CustomerAwsId",
	"enabled":               "description.EventSubscription.Enabled",
	"event_categories_list": "description.EventSubscription.EventCategoriesList",
	"kaytu_account_id":      "metadata.SourceID",
	"sns_topic_arn":         "description.EventSubscription.SnsTopicArn",
	"source_ids_list":       "description.EventSubscription.SourceIdsList",
	"source_type":           "description.EventSubscription.SourceType",
	"status":                "description.EventSubscription.Status",
	"title":                 "description.EventSubscription.CustSubscriptionId",
}

func ListRDSDBEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBEventSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBEventSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBEventSubscriptionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBEventSubscriptionFilters = map[string]string{
	"akas":                  "description.EventSubscription.EventSubscriptionArn",
	"arn":                   "description.EventSubscription.EventSubscriptionArn",
	"cust_subscription_id":  "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":       "description.EventSubscription.CustomerAwsId",
	"enabled":               "description.EventSubscription.Enabled",
	"event_categories_list": "description.EventSubscription.EventCategoriesList",
	"kaytu_account_id":      "metadata.SourceID",
	"sns_topic_arn":         "description.EventSubscription.SnsTopicArn",
	"source_ids_list":       "description.EventSubscription.SourceIdsList",
	"source_type":           "description.EventSubscription.SourceType",
	"status":                "description.EventSubscription.Status",
	"title":                 "description.EventSubscription.CustSubscriptionId",
}

func GetRDSDBEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBEventSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBEventSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBEventSubscriptionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBEventSubscription =============================

// ==========================  START: RDSDBInstance =============================

type RDSDBInstance struct {
	Description   aws.RDSDBInstanceDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type RDSDBInstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBInstance `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBInstanceHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []RDSDBInstanceHit `json:"hits"`
}

type RDSDBInstanceSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  RDSDBInstanceHits `json:"hits"`
}

type RDSDBInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBInstancePaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbinstance", filters, limit)
	if err != nil {
		return RDSDBInstancePaginator{}, err
	}

	p := RDSDBInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBInstancePaginator) NextPage(ctx context.Context) ([]RDSDBInstance, error) {
	var response RDSDBInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBInstanceFilters = map[string]string{
	"akas":                                       "description.DBInstance.DBInstanceArn",
	"allocated_storage":                          "description.DBInstance.AllocatedStorage",
	"arn":                                        "description.DBInstance.DBInstanceArn",
	"associated_roles":                           "description.DBInstance.AssociatedRoles",
	"auto_minor_version_upgrade":                 "description.DBInstance.AutoMinorVersionUpgrade",
	"availability_zone":                          "description.DBInstance.AvailabilityZone",
	"backup_retention_period":                    "description.DBInstance.BackupRetentionPeriod",
	"ca_certificate_identifier":                  "description.DBInstance.CACertificateIdentifier",
	"character_set_name":                         "description.DBInstance.CharacterSetName",
	"class":                                      "description.DBInstance.DBInstanceClass",
	"copy_tags_to_snapshot":                      "description.DBInstance.CopyTagsToSnapshot",
	"create_time":                                "description.DBInstance.InstanceCreateTime",
	"customer_owned_ip_enabled":                  "description.DBInstance.CustomerOwnedIpEnabled",
	"db_cluster_identifier":                      "description.DBInstance.DBClusterIdentifier",
	"db_instance_identifier":                     "description.DBInstance.DBInstanceIdentifier",
	"db_name":                                    "description.DBInstance.DBName",
	"db_parameter_groups":                        "description.DBInstance.DBParameterGroups",
	"db_security_groups":                         "description.DBInstance.DBSecurityGroups",
	"db_subnet_group_arn":                        "description.DBInstance.DBSubnetGroup.DBSubnetGroupArn",
	"db_subnet_group_description":                "description.DBInstance.DBSubnetGroup.DBSubnetGroupDescription",
	"db_subnet_group_name":                       "description.DBInstance.DBSubnetGroup.DBSubnetGroupName",
	"db_subnet_group_status":                     "description.DBInstance.DBSubnetGroup.SubnetGroupStatus",
	"deletion_protection":                        "description.DBInstance.DeletionProtection",
	"domain_memberships":                         "description.DBInstance.DomainMemberships",
	"enabled_cloudwatch_logs_exports":            "description.DBInstance.EnabledCloudwatchLogsExports",
	"endpoint_address":                           "description.DBInstance.Endpoint.Address",
	"endpoint_hosted_zone_id":                    "description.DBInstance.Endpoint.HostedZoneId",
	"endpoint_port":                              "description.DBInstance.Endpoint.Port",
	"engine":                                     "description.DBInstance.Engine",
	"engine_version":                             "description.DBInstance.EngineVersion",
	"enhanced_monitoring_resource_arn":           "description.DBInstance.EnhancedMonitoringResourceArn",
	"iam_database_authentication_enabled":        "description.DBInstance.IAMDatabaseAuthenticationEnabled",
	"iops":                                       "description.DBInstance.Iops",
	"kaytu_account_id":                           "metadata.SourceID",
	"kms_key_id":                                 "description.DBInstance.KmsKeyId",
	"latest_restorable_time":                     "description.DBInstance.LatestRestorableTime",
	"license_model":                              "description.DBInstance.LicenseModel",
	"master_user_name":                           "description.DBInstance.MasterUsername",
	"max_allocated_storage":                      "description.DBInstance.MaxAllocatedStorage",
	"monitoring_interval":                        "description.DBInstance.MonitoringInterval",
	"monitoring_role_arn":                        "description.DBInstance.MonitoringRoleArn",
	"multi_az":                                   "description.DBInstance.MultiAZ",
	"nchar_character_set_name":                   "description.DBInstance.NcharCharacterSetName",
	"option_group_memberships":                   "description.DBInstance.OptionGroupMemberships",
	"performance_insights_enabled":               "description.DBInstance.PerformanceInsightsEnabled",
	"performance_insights_kms_key_id":            "description.DBInstance.PerformanceInsightsKMSKeyId",
	"performance_insights_retention_period":      "description.DBInstance.PerformanceInsightsRetentionPeriod",
	"port":                                       "description.DBInstance.DbInstancePort",
	"preferred_backup_window":                    "description.DBInstance.PreferredBackupWindow",
	"preferred_maintenance_window":               "description.DBInstance.PreferredMaintenanceWindow",
	"processor_features":                         "description.DBInstance.ProcessorFeatures",
	"promotion_tier":                             "description.DBInstance.PromotionTier",
	"publicly_accessible":                        "description.DBInstance.PubliclyAccessible",
	"read_replica_db_cluster_identifiers":        "description.DBInstance.ReadReplicaDBClusterIdentifiers",
	"read_replica_db_instance_identifiers":       "description.DBInstance.ReadReplicaDBInstanceIdentifiers",
	"read_replica_source_db_instance_identifier": "description.DBInstance.ReadReplicaSourceDBInstanceIdentifier",
	"replica_mode":                               "description.DBInstance.ReplicaMode",
	"resource_id":                                "description.DBInstance.DbiResourceId",
	"secondary_availability_zone":                "description.DBInstance.SecondaryAvailabilityZone",
	"status":                                     "description.DBInstance.DBInstanceStatus",
	"status_infos":                               "description.DBInstance.StatusInfos",
	"storage_encrypted":                          "description.DBInstance.StorageEncrypted",
	"storage_type":                               "description.DBInstance.StorageType",
	"subnets":                                    "description.DBInstance.DBSubnetGroup.Subnets",
	"tags_src":                                   "description.DBInstance.TagList",
	"tde_credential_arn":                         "description.DBInstance.TdeCredentialArn",
	"timezone":                                   "description.DBInstance.Timezone",
	"title":                                      "description.DBInstance.DBInstanceIdentifier",
	"vpc_id":                                     "description.DBInstance.DBSubnetGroup.VpcId",
	"vpc_security_groups":                        "description.DBInstance.VpcSecurityGroups",
}

func ListRDSDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBInstanceFilters = map[string]string{
	"akas":                                       "description.DBInstance.DBInstanceArn",
	"allocated_storage":                          "description.DBInstance.AllocatedStorage",
	"arn":                                        "description.DBInstance.DBInstanceArn",
	"associated_roles":                           "description.DBInstance.AssociatedRoles",
	"auto_minor_version_upgrade":                 "description.DBInstance.AutoMinorVersionUpgrade",
	"availability_zone":                          "description.DBInstance.AvailabilityZone",
	"backup_retention_period":                    "description.DBInstance.BackupRetentionPeriod",
	"ca_certificate_identifier":                  "description.DBInstance.CACertificateIdentifier",
	"character_set_name":                         "description.DBInstance.CharacterSetName",
	"class":                                      "description.DBInstance.DBInstanceClass",
	"copy_tags_to_snapshot":                      "description.DBInstance.CopyTagsToSnapshot",
	"create_time":                                "description.DBInstance.InstanceCreateTime",
	"customer_owned_ip_enabled":                  "description.DBInstance.CustomerOwnedIpEnabled",
	"db_cluster_identifier":                      "description.DBInstance.DBClusterIdentifier",
	"db_instance_identifier":                     "description.DBInstance.DBInstanceIdentifier",
	"db_name":                                    "description.DBInstance.DBName",
	"db_parameter_groups":                        "description.DBInstance.DBParameterGroups",
	"db_security_groups":                         "description.DBInstance.DBSecurityGroups",
	"db_subnet_group_arn":                        "description.DBInstance.DBSubnetGroup.DBSubnetGroupArn",
	"db_subnet_group_description":                "description.DBInstance.DBSubnetGroup.DBSubnetGroupDescription",
	"db_subnet_group_name":                       "description.DBInstance.DBSubnetGroup.DBSubnetGroupName",
	"db_subnet_group_status":                     "description.DBInstance.DBSubnetGroup.SubnetGroupStatus",
	"deletion_protection":                        "description.DBInstance.DeletionProtection",
	"domain_memberships":                         "description.DBInstance.DomainMemberships",
	"enabled_cloudwatch_logs_exports":            "description.DBInstance.EnabledCloudwatchLogsExports",
	"endpoint_address":                           "description.DBInstance.Endpoint.Address",
	"endpoint_hosted_zone_id":                    "description.DBInstance.Endpoint.HostedZoneId",
	"endpoint_port":                              "description.DBInstance.Endpoint.Port",
	"engine":                                     "description.DBInstance.Engine",
	"engine_version":                             "description.DBInstance.EngineVersion",
	"enhanced_monitoring_resource_arn":           "description.DBInstance.EnhancedMonitoringResourceArn",
	"iam_database_authentication_enabled":        "description.DBInstance.IAMDatabaseAuthenticationEnabled",
	"iops":                                       "description.DBInstance.Iops",
	"kaytu_account_id":                           "metadata.SourceID",
	"kms_key_id":                                 "description.DBInstance.KmsKeyId",
	"latest_restorable_time":                     "description.DBInstance.LatestRestorableTime",
	"license_model":                              "description.DBInstance.LicenseModel",
	"master_user_name":                           "description.DBInstance.MasterUsername",
	"max_allocated_storage":                      "description.DBInstance.MaxAllocatedStorage",
	"monitoring_interval":                        "description.DBInstance.MonitoringInterval",
	"monitoring_role_arn":                        "description.DBInstance.MonitoringRoleArn",
	"multi_az":                                   "description.DBInstance.MultiAZ",
	"nchar_character_set_name":                   "description.DBInstance.NcharCharacterSetName",
	"option_group_memberships":                   "description.DBInstance.OptionGroupMemberships",
	"performance_insights_enabled":               "description.DBInstance.PerformanceInsightsEnabled",
	"performance_insights_kms_key_id":            "description.DBInstance.PerformanceInsightsKMSKeyId",
	"performance_insights_retention_period":      "description.DBInstance.PerformanceInsightsRetentionPeriod",
	"port":                                       "description.DBInstance.DbInstancePort",
	"preferred_backup_window":                    "description.DBInstance.PreferredBackupWindow",
	"preferred_maintenance_window":               "description.DBInstance.PreferredMaintenanceWindow",
	"processor_features":                         "description.DBInstance.ProcessorFeatures",
	"promotion_tier":                             "description.DBInstance.PromotionTier",
	"publicly_accessible":                        "description.DBInstance.PubliclyAccessible",
	"read_replica_db_cluster_identifiers":        "description.DBInstance.ReadReplicaDBClusterIdentifiers",
	"read_replica_db_instance_identifiers":       "description.DBInstance.ReadReplicaDBInstanceIdentifiers",
	"read_replica_source_db_instance_identifier": "description.DBInstance.ReadReplicaSourceDBInstanceIdentifier",
	"replica_mode":                               "description.DBInstance.ReplicaMode",
	"resource_id":                                "description.DBInstance.DbiResourceId",
	"secondary_availability_zone":                "description.DBInstance.SecondaryAvailabilityZone",
	"status":                                     "description.DBInstance.DBInstanceStatus",
	"status_infos":                               "description.DBInstance.StatusInfos",
	"storage_encrypted":                          "description.DBInstance.StorageEncrypted",
	"storage_type":                               "description.DBInstance.StorageType",
	"subnets":                                    "description.DBInstance.DBSubnetGroup.Subnets",
	"tags_src":                                   "description.DBInstance.TagList",
	"tde_credential_arn":                         "description.DBInstance.TdeCredentialArn",
	"timezone":                                   "description.DBInstance.Timezone",
	"title":                                      "description.DBInstance.DBInstanceIdentifier",
	"vpc_id":                                     "description.DBInstance.DBSubnetGroup.VpcId",
	"vpc_security_groups":                        "description.DBInstance.VpcSecurityGroups",
}

func GetRDSDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBInstance =============================

// ==========================  START: RDSDBSnapshot =============================

type RDSDBSnapshot struct {
	Description   aws.RDSDBSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type RDSDBSnapshotHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBSnapshot `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBSnapshotHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []RDSDBSnapshotHit `json:"hits"`
}

type RDSDBSnapshotSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  RDSDBSnapshotHits `json:"hits"`
}

type RDSDBSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbsnapshot", filters, limit)
	if err != nil {
		return RDSDBSnapshotPaginator{}, err
	}

	p := RDSDBSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBSnapshotPaginator) NextPage(ctx context.Context) ([]RDSDBSnapshot, error) {
	var response RDSDBSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBSnapshotFilters = map[string]string{
	"akas":                                "description.DBSnapshot.DBSnapshotArn",
	"allocated_storage":                   "description.DBSnapshot.AllocatedStorage",
	"arn":                                 "description.DBSnapshot.DBSnapshotArn",
	"availability_zone":                   "description.DBSnapshot.AvailabilityZone",
	"create_time":                         "description.DBSnapshot.SnapshotCreateTime",
	"db_instance_identifier":              "description.DBSnapshot.DBInstanceIdentifier",
	"db_snapshot_attributes":              "description.DBSnapshotAttributes",
	"db_snapshot_identifier":              "description.DBSnapshot.DBSnapshotIdentifier",
	"dbi_resource_id":                     "description.DBSnapshot.DbiResourceId",
	"encrypted":                           "description.DBSnapshot.Encrypted",
	"engine":                              "description.DBSnapshot.Engine",
	"engine_version":                      "description.DBSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBSnapshot.IAMDatabaseAuthenticationEnabled",
	"instance_create_time":                "description.DBSnapshot.InstanceCreateTime",
	"iops":                                "description.DBSnapshot.Iops",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.DBSnapshot.KmsKeyId",
	"license_model":                       "description.DBSnapshot.LicenseModel",
	"master_user_name":                    "description.DBSnapshot.MasterUsername",
	"option_group_name":                   "description.DBSnapshot.OptionGroupName",
	"percent_progress":                    "description.DBSnapshot.PercentProgress",
	"port":                                "description.DBSnapshot.Port",
	"processor_features":                  "description.DBSnapshot.ProcessorFeatures",
	"source_db_snapshot_identifier":       "description.DBSnapshot.SourceDBSnapshotIdentifier",
	"source_region":                       "description.DBSnapshot.SourceRegion",
	"status":                              "description.DBSnapshot.Status",
	"storage_type":                        "description.DBSnapshot.StorageType",
	"tags_src":                            "description.DBSnapshot.TagList",
	"tde_credential_arn":                  "description.DBSnapshot.TdeCredentialArn",
	"timezone":                            "description.DBSnapshot.Timezone",
	"title":                               "description.DBSnapshot.DBSnapshotIdentifier",
	"type":                                "description.DBSnapshot.SnapshotType",
	"vpc_id":                              "description.DBSnapshot.VpcId",
}

func ListRDSDBSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSDBSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSDBSnapshotFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSDBSnapshotFilters = map[string]string{
	"akas":                                "description.DBSnapshot.DBSnapshotArn",
	"allocated_storage":                   "description.DBSnapshot.AllocatedStorage",
	"arn":                                 "description.DBSnapshot.DBSnapshotArn",
	"availability_zone":                   "description.DBSnapshot.AvailabilityZone",
	"create_time":                         "description.DBSnapshot.SnapshotCreateTime",
	"db_instance_identifier":              "description.DBSnapshot.DBInstanceIdentifier",
	"db_snapshot_attributes":              "description.DBSnapshotAttributes",
	"db_snapshot_identifier":              "description.DBSnapshot.DBInstanceIdentifier",
	"dbi_resource_id":                     "description.DBSnapshot.DbiResourceId",
	"encrypted":                           "description.DBSnapshot.Encrypted",
	"engine":                              "description.DBSnapshot.Engine",
	"engine_version":                      "description.DBSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBSnapshot.IAMDatabaseAuthenticationEnabled",
	"instance_create_time":                "description.DBSnapshot.InstanceCreateTime",
	"iops":                                "description.DBSnapshot.Iops",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.DBSnapshot.KmsKeyId",
	"license_model":                       "description.DBSnapshot.LicenseModel",
	"master_user_name":                    "description.DBSnapshot.MasterUsername",
	"option_group_name":                   "description.DBSnapshot.OptionGroupName",
	"percent_progress":                    "description.DBSnapshot.PercentProgress",
	"port":                                "description.DBSnapshot.Port",
	"processor_features":                  "description.DBSnapshot.ProcessorFeatures",
	"source_db_snapshot_identifier":       "description.DBSnapshot.SourceDBSnapshotIdentifier",
	"source_region":                       "description.DBSnapshot.SourceRegion",
	"status":                              "description.DBSnapshot.Status",
	"storage_type":                        "description.DBSnapshot.StorageType",
	"tags_src":                            "description.DBSnapshot.TagList",
	"tde_credential_arn":                  "description.DBSnapshot.TdeCredentialArn",
	"timezone":                            "description.DBSnapshot.Timezone",
	"title":                               "description.DBSnapshot.DBSnapshotIdentifier",
	"type":                                "description.DBSnapshot.SnapshotType",
	"vpc_id":                              "description.DBSnapshot.VpcId",
}

func GetRDSDBSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSDBSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSDBSnapshotFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSDBSnapshot =============================

// ==========================  START: RDSGlobalCluster =============================

type RDSGlobalCluster struct {
	Description   aws.RDSGlobalClusterDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RDSGlobalClusterHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  RDSGlobalCluster `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type RDSGlobalClusterHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []RDSGlobalClusterHit `json:"hits"`
}

type RDSGlobalClusterSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  RDSGlobalClusterHits `json:"hits"`
}

type RDSGlobalClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSGlobalClusterPaginator(filters []essdk.BoolFilter, limit *int64) (RDSGlobalClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_globalcluster", filters, limit)
	if err != nil {
		return RDSGlobalClusterPaginator{}, err
	}

	p := RDSGlobalClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSGlobalClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSGlobalClusterPaginator) NextPage(ctx context.Context) ([]RDSGlobalCluster, error) {
	var response RDSGlobalClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSGlobalCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSGlobalClusterFilters = map[string]string{
	"akas":                      "description.GlobalCluster.GlobalClusterArn",
	"global_cluster_arn":        "description.GlobalCluster.GlobalClusterArn",
	"global_cluster_identifier": "description.GlobalCluster.GlobalClusterIdentifier",
	"kaytu_account_id":          "metadata.SourceID",
	"title":                     "description.GlobalCluster.GlobalClusterIdentifier",
}

func ListRDSGlobalCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSGlobalCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSGlobalClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSGlobalClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSGlobalClusterFilters = map[string]string{
	"akas":                      "description.GlobalCluster.GlobalClusterArn",
	"global_cluster_arn":        "description.GlobalCluster.GlobalClusterArn",
	"global_cluster_identifier": "description.DBGlobalCluster.GlobalClusterIdentifier",
	"kaytu_account_id":          "metadata.SourceID",
	"title":                     "description.GlobalCluster.GlobalClusterIdentifier",
}

func GetRDSGlobalCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSGlobalCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSGlobalClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSGlobalClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSGlobalCluster =============================

// ==========================  START: RDSReservedDBInstance =============================

type RDSReservedDBInstance struct {
	Description   aws.RDSReservedDBInstanceDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type RDSReservedDBInstanceHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  RDSReservedDBInstance `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type RDSReservedDBInstanceHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []RDSReservedDBInstanceHit `json:"hits"`
}

type RDSReservedDBInstanceSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  RDSReservedDBInstanceHits `json:"hits"`
}

type RDSReservedDBInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSReservedDBInstancePaginator(filters []essdk.BoolFilter, limit *int64) (RDSReservedDBInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_reserveddbinstance", filters, limit)
	if err != nil {
		return RDSReservedDBInstancePaginator{}, err
	}

	p := RDSReservedDBInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSReservedDBInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSReservedDBInstancePaginator) NextPage(ctx context.Context) ([]RDSReservedDBInstance, error) {
	var response RDSReservedDBInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSReservedDBInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSReservedDBInstanceFilters = map[string]string{
	"akas":                              "description.ReservedDBInstance.ReservedDBInstanceArn",
	"arn":                               "description.ReservedDBInstance.ReservedDBInstanceArn",
	"class":                             "description.ReservedDBInstance.DBInstanceClass",
	"currency_code":                     "description.ReservedDBInstance.CurrencyCode",
	"db_instance_count":                 "description.ReservedDBInstance.DBInstanceCount",
	"duration":                          "description.ReservedDBInstance.Duration",
	"fixed_price":                       "description.ReservedDBInstance.FixedPrice",
	"kaytu_account_id":                  "metadata.SourceID",
	"lease_id":                          "description.ReservedDBInstance.LeaseId",
	"multi_az":                          "description.ReservedDBInstance.MultiAZ",
	"offering_type":                     "description.ReservedDBInstance.OfferingType",
	"product_description":               "description.ReservedDBInstance.ProductDescription",
	"recurring_charges":                 "description.ReservedDBInstance.RecurringCharges",
	"reserved_db_instance_id":           "description.ReservedDBInstance.ReservedDBInstanceId",
	"reserved_db_instances_offering_id": "description.ReservedDBInstance.ReservedDBInstancesOfferingId",
	"start_time":                        "description.ReservedDBInstance.StartTime",
	"state":                             "description.ReservedDBInstance.State",
	"title":                             "description.ReservedDBInstance.ReservedDBInstanceId",
	"usage_price":                       "description.ReservedDBInstance.UsagePrice",
}

func ListRDSReservedDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSReservedDBInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRDSReservedDBInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRDSReservedDBInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRDSReservedDBInstanceFilters = map[string]string{
	"akas":                              "description.ReservedDBInstance.ReservedDBInstanceArn",
	"arn":                               "description.ReservedDBInstance.ReservedDBInstanceArn",
	"class":                             "description.ReservedDBInstance.DBInstanceClass",
	"currency_code":                     "description.ReservedDBInstance.CurrencyCode",
	"db_instance_count":                 "description.ReservedDBInstance.DBInstanceCount",
	"duration":                          "description.ReservedDBInstance.Duration",
	"fixed_price":                       "description.ReservedDBInstance.FixedPrice",
	"kaytu_account_id":                  "metadata.SourceID",
	"lease_id":                          "description.ReservedDBInstance.LeaseId",
	"multi_az":                          "description.ReservedDBInstance.MultiAZ",
	"offering_type":                     "description.ReservedDBInstance.OfferingType",
	"product_description":               "description.ReservedDBInstance.ProductDescription",
	"recurring_charges":                 "description.ReservedDBInstance.RecurringCharges",
	"reserved_db_instance_id":           "description.ReservedDBInstance.ReservedDBInstanceId",
	"reserved_db_instances_offering_id": "description.ReservedDBInstance.ReservedDBInstancesOfferingId",
	"start_time":                        "description.ReservedDBInstance.StartTime",
	"state":                             "description.ReservedDBInstance.State",
	"title":                             "description.ReservedDBInstance.ReservedDBInstanceId",
	"usage_price":                       "description.ReservedDBInstance.UsagePrice",
}

func GetRDSReservedDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSReservedDBInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRDSReservedDBInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRDSReservedDBInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RDSReservedDBInstance =============================

// ==========================  START: RedshiftCluster =============================

type RedshiftCluster struct {
	Description   aws.RedshiftClusterDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type RedshiftClusterHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  RedshiftCluster `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type RedshiftClusterHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []RedshiftClusterHit `json:"hits"`
}

type RedshiftClusterSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  RedshiftClusterHits `json:"hits"`
}

type RedshiftClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftClusterPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_cluster", filters, limit)
	if err != nil {
		return RedshiftClusterPaginator{}, err
	}

	p := RedshiftClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftClusterPaginator) NextPage(ctx context.Context) ([]RedshiftCluster, error) {
	var response RedshiftClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftClusterFilters = map[string]string{
	"allow_version_upgrade":                       "description.Cluster.AllowVersionUpgrade",
	"automated_snapshot_retention_period":         "description.Cluster.AutomatedSnapshotRetentionPeriod",
	"availability_zone":                           "description.Cluster.AvailabilityZone",
	"availability_zone_relocation_status":         "description.Cluster.AvailabilityZoneRelocationStatus",
	"cluster_availability_status":                 "description.Cluster.ClusterAvailabilityStatus",
	"cluster_create_time":                         "description.Cluster.ClusterCreateTime",
	"cluster_identifier":                          "description.Cluster.ClusterIdentifier",
	"cluster_namespace_arn":                       "description.Cluster.ClusterNamespaceArn",
	"cluster_nodes":                               "description.Cluster.ClusterNodes",
	"cluster_parameter_groups":                    "description.Cluster.ClusterParameterGroups",
	"cluster_public_key":                          "description.Cluster.ClusterPublicKey",
	"cluster_revision_number":                     "description.Cluster.ClusterRevisionNumber",
	"cluster_security_groups":                     "description.Cluster.ClusterSecurityGroups",
	"cluster_snapshot_copy_status":                "description.Cluster.ClusterSnapshotCopyStatus",
	"cluster_status":                              "description.Cluster.ClusterStatus",
	"cluster_subnet_group_name":                   "description.Cluster.ClusterSubnetGroupName",
	"cluster_version":                             "description.Cluster.ClusterVersion",
	"data_transfer_progress":                      "description.Cluster.DataTransferProgress",
	"db_name":                                     "description.Cluster.DBName",
	"deferred_maintenance_windows":                "description.Cluster.DeferredMaintenanceWindows",
	"elastic_ip_status":                           "description.Cluster.ElasticIpStatus",
	"elastic_resize_number_of_node_options":       "description.Cluster.ElasticResizeNumberOfNodeOptions",
	"encrypted":                                   "description.Cluster.Encrypted",
	"endpoint":                                    "description.Cluster.Endpoint",
	"enhanced_vpc_routing":                        "description.Cluster.EnhancedVpcRouting",
	"expected_next_snapshot_schedule_time":        "description.Cluster.ExpectedNextSnapshotScheduleTime",
	"expected_next_snapshot_schedule_time_status": "description.Cluster.ExpectedNextSnapshotScheduleTimeStatus",
	"hsm_status":                                  "description.Cluster.HsmStatus",
	"iam_roles":                                   "description.Cluster.IamRoles",
	"kaytu_account_id":                            "metadata.SourceID",
	"kms_key_id":                                  "description.Cluster.KmsKeyId",
	"logging_status":                              "description.LoggingStatus",
	"maintenance_track_name":                      "description.Cluster.MaintenanceTrackName",
	"manual_snapshot_retention_period":            "description.Cluster.ManualSnapshotRetentionPeriod",
	"master_username":                             "description.Cluster.MasterUsername",
	"modify_status":                               "description.Cluster.ModifyStatus",
	"next_maintenance_window_start_time":          "description.Cluster.NextMaintenanceWindowStartTime",
	"node_type":                                   "description.Cluster.NodeType",
	"number_of_nodes":                             "description.Cluster.NumberOfNodes",
	"pending_actions":                             "description.Cluster.PendingActions",
	"pending_modified_values":                     "description.Cluster.PendingModifiedValues",
	"preferred_maintenance_window":                "description.Cluster.PreferredMaintenanceWindow",
	"publicly_accessible":                         "description.Cluster.PubliclyAccessible",
	"resize_info":                                 "description.Cluster.ResizeInfo",
	"restore_status":                              "description.Cluster.RestoreStatus",
	"scheduled_actions":                           "description.ScheduledActions",
	"snapshot_schedule_identifier":                "description.Cluster.SnapshotScheduleIdentifier",
	"snapshot_schedule_state":                     "description.Cluster.SnapshotScheduleState",
	"tags_src":                                    "description.Cluster.Tags",
	"title":                                       "description.Cluster.ClusterIdentifier",
	"vpc_id":                                      "description.Cluster.VpcId",
	"vpc_security_groups":                         "description.Cluster.VpcSecurityGroups",
}

func ListRedshiftCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftClusterFilters = map[string]string{
	"allow_version_upgrade":                       "description.Cluster.AllowVersionUpgrade",
	"automated_snapshot_retention_period":         "description.Cluster.AutomatedSnapshotRetentionPeriod",
	"availability_zone":                           "description.Cluster.AvailabilityZone",
	"availability_zone_relocation_status":         "description.Cluster.AvailabilityZoneRelocationStatus",
	"cluster_availability_status":                 "description.Cluster.ClusterAvailabilityStatus",
	"cluster_create_time":                         "description.Cluster.ClusterCreateTime",
	"cluster_identifier":                          "description.Cluster",
	"cluster_namespace_arn":                       "description.Cluster.ClusterNamespaceArn",
	"cluster_nodes":                               "description.Cluster.ClusterNodes",
	"cluster_parameter_groups":                    "description.Cluster.ClusterParameterGroups",
	"cluster_public_key":                          "description.Cluster.ClusterPublicKey",
	"cluster_revision_number":                     "description.Cluster.ClusterRevisionNumber",
	"cluster_security_groups":                     "description.Cluster.ClusterSecurityGroups",
	"cluster_snapshot_copy_status":                "description.Cluster.ClusterSnapshotCopyStatus",
	"cluster_status":                              "description.Cluster.ClusterStatus",
	"cluster_subnet_group_name":                   "description.Cluster.ClusterSubnetGroupName",
	"cluster_version":                             "description.Cluster.ClusterVersion",
	"data_transfer_progress":                      "description.Cluster.DataTransferProgress",
	"db_name":                                     "description.Cluster.DBName",
	"deferred_maintenance_windows":                "description.Cluster.DeferredMaintenanceWindows",
	"elastic_ip_status":                           "description.Cluster.ElasticIpStatus",
	"elastic_resize_number_of_node_options":       "description.Cluster.ElasticResizeNumberOfNodeOptions",
	"encrypted":                                   "description.Cluster.Encrypted",
	"endpoint":                                    "description.Cluster.Endpoint",
	"enhanced_vpc_routing":                        "description.Cluster.EnhancedVpcRouting",
	"expected_next_snapshot_schedule_time":        "description.Cluster.ExpectedNextSnapshotScheduleTime",
	"expected_next_snapshot_schedule_time_status": "description.Cluster.ExpectedNextSnapshotScheduleTimeStatus",
	"hsm_status":                                  "description.Cluster.HsmStatus",
	"iam_roles":                                   "description.Cluster.IamRoles",
	"kaytu_account_id":                            "metadata.SourceID",
	"kms_key_id":                                  "description.Cluster.KmsKeyId",
	"logging_status":                              "description.LoggingStatus",
	"maintenance_track_name":                      "description.Cluster.MaintenanceTrackName",
	"manual_snapshot_retention_period":            "description.Cluster.ManualSnapshotRetentionPeriod",
	"master_username":                             "description.Cluster.MasterUsername",
	"modify_status":                               "description.Cluster.ModifyStatus",
	"next_maintenance_window_start_time":          "description.Cluster.NextMaintenanceWindowStartTime",
	"node_type":                                   "description.Cluster.NodeType",
	"number_of_nodes":                             "description.Cluster.NumberOfNodes",
	"pending_actions":                             "description.Cluster.PendingActions",
	"pending_modified_values":                     "description.Cluster.PendingModifiedValues",
	"preferred_maintenance_window":                "description.Cluster.PreferredMaintenanceWindow",
	"publicly_accessible":                         "description.Cluster.PubliclyAccessible",
	"resize_info":                                 "description.Cluster.ResizeInfo",
	"restore_status":                              "description.Cluster.RestoreStatus",
	"scheduled_actions":                           "description.ScheduledActions",
	"snapshot_schedule_identifier":                "description.Cluster.SnapshotScheduleIdentifier",
	"snapshot_schedule_state":                     "description.Cluster.SnapshotScheduleState",
	"tags_src":                                    "description.Cluster.Tags",
	"title":                                       "description.Cluster.ClusterIdentifier",
	"vpc_id":                                      "description.Cluster.VpcId",
	"vpc_security_groups":                         "description.Cluster.VpcSecurityGroups",
}

func GetRedshiftCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftCluster =============================

// ==========================  START: RedshiftEventSubscription =============================

type RedshiftEventSubscription struct {
	Description   aws.RedshiftEventSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type RedshiftEventSubscriptionHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  RedshiftEventSubscription `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type RedshiftEventSubscriptionHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []RedshiftEventSubscriptionHit `json:"hits"`
}

type RedshiftEventSubscriptionSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  RedshiftEventSubscriptionHits `json:"hits"`
}

type RedshiftEventSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftEventSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftEventSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_eventsubscription", filters, limit)
	if err != nil {
		return RedshiftEventSubscriptionPaginator{}, err
	}

	p := RedshiftEventSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftEventSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftEventSubscriptionPaginator) NextPage(ctx context.Context) ([]RedshiftEventSubscription, error) {
	var response RedshiftEventSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftEventSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftEventSubscriptionFilters = map[string]string{
	"cust_subscription_id":       "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":            "description.EventSubscription.CustomerAwsId",
	"enabled":                    "description.EventSubscription.Enabled",
	"event_categories_list":      "description.EventSubscription.EventCategoriesList",
	"kaytu_account_id":           "metadata.SourceID",
	"severity":                   "description.EventSubscription.Severity",
	"sns_topic_arn":              "description.EventSubscription.SnsTopicArn",
	"source_ids_list":            "description.EventSubscription.SourceIdsList",
	"source_type":                "description.EventSubscription.SourceType",
	"status":                     "description.EventSubscription.Status",
	"subscription_creation_time": "description.EventSubscription.SubscriptionCreationTime",
	"tags":                       "description.EventSubscription.Tags",
	"tags_src":                   "description.EventSubscription.Tags",
	"title":                      "description.EventSubscription.CustSubscriptionId",
}

func ListRedshiftEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftEventSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftEventSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftEventSubscriptionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftEventSubscriptionFilters = map[string]string{
	"cust_subscription_id":       "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":            "description.EventSubscription.CustomerAwsId",
	"enabled":                    "description.EventSubscription.Enabled",
	"event_categories_list":      "description.EventSubscription.EventCategoriesList",
	"kaytu_account_id":           "metadata.SourceID",
	"severity":                   "description.EventSubscription.Severity",
	"sns_topic_arn":              "description.EventSubscription.SnsTopicArn",
	"source_ids_list":            "description.EventSubscription.SourceIdsList",
	"source_type":                "description.EventSubscription.SourceType",
	"status":                     "description.EventSubscription.Status",
	"subscription_creation_time": "description.EventSubscription.SubscriptionCreationTime",
	"tags":                       "description.EventSubscription.Tags",
	"tags_src":                   "description.EventSubscription.Tags",
	"title":                      "description.EventSubscription.CustSubscriptionId",
}

func GetRedshiftEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftEventSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftEventSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftEventSubscriptionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftEventSubscription =============================

// ==========================  START: RedshiftServerlessWorkgroup =============================

type RedshiftServerlessWorkgroup struct {
	Description   aws.RedshiftServerlessWorkgroupDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type RedshiftServerlessWorkgroupHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  RedshiftServerlessWorkgroup `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type RedshiftServerlessWorkgroupHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []RedshiftServerlessWorkgroupHit `json:"hits"`
}

type RedshiftServerlessWorkgroupSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  RedshiftServerlessWorkgroupHits `json:"hits"`
}

type RedshiftServerlessWorkgroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftServerlessWorkgroupPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftServerlessWorkgroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshiftserverless_workgroup", filters, limit)
	if err != nil {
		return RedshiftServerlessWorkgroupPaginator{}, err
	}

	p := RedshiftServerlessWorkgroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftServerlessWorkgroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftServerlessWorkgroupPaginator) NextPage(ctx context.Context) ([]RedshiftServerlessWorkgroup, error) {
	var response RedshiftServerlessWorkgroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftServerlessWorkgroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftServerlessWorkgroupFilters = map[string]string{
	"akas":                 "description.Workgroup.WorkgroupArn",
	"base_capacity":        "description.Workgroup.BaseCapacity",
	"config_parameters":    "description.Workgroup.ConfigParameters",
	"creation_date":        "description.Workgroup.CreationDate",
	"endpoint":             "description.Workgroup.Endpoint",
	"enhanced_vpc_routing": "description.Workgroup.EnhancedVpcRouting",
	"kaytu_account_id":     "metadata.SourceID",
	"namespace_name":       "description.Workgroup.NamespaceName",
	"publicly_accessible":  "description.Workgroup.PubliclyAccessible",
	"security_group_ids":   "description.Workgroup.SecurityGroupIds",
	"status":               "description.Workgroup.Status",
	"subnet_ids":           "description.Workgroup.SubnetIds",
	"tags_src":             "description.Tags",
	"title":                "description.Workgroup.WorkgroupName",
	"workgroup_arn":        "description.Workgroup.WorkgroupArn",
	"workgroup_id":         "description.Workgroup.WorkgroupId",
	"workgroup_name":       "description.Workgroup.WorkgroupName",
}

func ListRedshiftServerlessWorkgroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftServerlessWorkgroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftServerlessWorkgroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftServerlessWorkgroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftServerlessWorkgroupFilters = map[string]string{
	"akas":                 "description.Workgroup.WorkgroupArn",
	"base_capacity":        "description.Workgroup.BaseCapacity",
	"config_parameters":    "description.Workgroup.ConfigParameters",
	"creation_date":        "description.Workgroup.CreationDate",
	"endpoint":             "description.Workgroup.Endpoint",
	"enhanced_vpc_routing": "description.Workgroup.EnhancedVpcRouting",
	"kaytu_account_id":     "metadata.SourceID",
	"namespace_name":       "description.Workgroup.NamespaceName",
	"publicly_accessible":  "description.Workgroup.PubliclyAccessible",
	"security_group_ids":   "description.Workgroup.SecurityGroupIds",
	"status":               "description.Workgroup.Status",
	"subnet_ids":           "description.Workgroup.SubnetIds",
	"tags_src":             "description.Tags",
	"title":                "description.Workgroup.WorkgroupName",
	"workgroup_arn":        "description.Workgroup.WorkgroupArn",
	"workgroup_id":         "description.Workgroup.WorkgroupId",
	"workgroup_name":       "description.Workgroup.WorkgroupName",
}

func GetRedshiftServerlessWorkgroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftServerlessWorkgroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftServerlessWorkgroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftServerlessWorkgroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftServerlessWorkgroup =============================

// ==========================  START: RedshiftClusterParameterGroup =============================

type RedshiftClusterParameterGroup struct {
	Description   aws.RedshiftClusterParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type RedshiftClusterParameterGroupHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  RedshiftClusterParameterGroup `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type RedshiftClusterParameterGroupHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []RedshiftClusterParameterGroupHit `json:"hits"`
}

type RedshiftClusterParameterGroupSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  RedshiftClusterParameterGroupHits `json:"hits"`
}

type RedshiftClusterParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftClusterParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftClusterParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_clusterparametergroup", filters, limit)
	if err != nil {
		return RedshiftClusterParameterGroupPaginator{}, err
	}

	p := RedshiftClusterParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftClusterParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftClusterParameterGroupPaginator) NextPage(ctx context.Context) ([]RedshiftClusterParameterGroup, error) {
	var response RedshiftClusterParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftClusterParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftClusterParameterGroupFilters = map[string]string{
	"description":      "description.ClusterParameterGroup.Description",
	"family":           "description.ClusterParameterGroup.ParameterGroupFamily",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ClusterParameterGroup.ParameterGroupName",
	"parameters":       "description.Parameters",
	"tags":             "description.ClusterParameterGroup.Tags",
	"tags_src":         "description.ClusterParameterGroup.Tags",
	"title":            "description.ClusterParameterGroup.ParameterGroupName",
}

func ListRedshiftClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftClusterParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftClusterParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftClusterParameterGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftClusterParameterGroupFilters = map[string]string{
	"description":      "description.ClusterParameterGroup.Description",
	"family":           "description.ClusterParameterGroup.ParameterGroupFamily",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ClusterParameterGroup.ParameterGroupName",
	"parameters":       "description.Parameters",
	"tags":             "description.ClusterParameterGroup.Tags",
	"tags_src":         "description.ClusterParameterGroup.Tags",
	"title":            "description.ClusterParameterGroup.ParameterGroupName",
}

func GetRedshiftClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftClusterParameterGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftClusterParameterGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftClusterParameterGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftClusterParameterGroup =============================

// ==========================  START: RedshiftSnapshot =============================

type RedshiftSnapshot struct {
	Description   aws.RedshiftSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RedshiftSnapshotHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  RedshiftSnapshot `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type RedshiftSnapshotHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []RedshiftSnapshotHit `json:"hits"`
}

type RedshiftSnapshotSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  RedshiftSnapshotHits `json:"hits"`
}

type RedshiftSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_snapshot", filters, limit)
	if err != nil {
		return RedshiftSnapshotPaginator{}, err
	}

	p := RedshiftSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftSnapshotPaginator) NextPage(ctx context.Context) ([]RedshiftSnapshot, error) {
	var response RedshiftSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftSnapshotFilters = map[string]string{
	"accounts_with_restore_access":                 "description.Snapshot.AccountsWithRestoreAccess",
	"actual_incremental_backup_size_in_mega_bytes": "description.Snapshot.ActualIncrementalBackupSizeInMegaBytes",
	"availability_zone":                            "description.Snapshot.AvailabilityZone",
	"backup_progress_in_mega-bytes":                "description.Snapshot.BackupProgressInMegaBytes",
	"cluster_create_time":                          "description.Snapshot.ClusterCreateTime",
	"cluster_identifier":                           "description.Snapshot.ClusterIdentifier",
	"cluster_version":                              "description.Snapshot.ClusterVersion",
	"current_backup_rate_in_mega_bytes_per_second": "description.Snapshot.CurrentBackupRateInMegaBytesPerSecond",
	"db_name":                          "description.Snapshot.DBName",
	"elapsed_time_in_seconds":          "description.Snapshot.ElapsedTimeInSeconds",
	"encrypted":                        "description.Snapshot.Encrypted",
	"encrypted_with_hsm":               "description.Snapshot.EncryptedWithHSM",
	"engine_full_version":              "description.Snapshot.EngineFullVersion",
	"enhanced_vpc_routing":             "description.Snapshot.EnhancedVpcRouting",
	"estimated_seconds_to_completion":  "description.Snapshot.EstimatedSecondsToCompletion",
	"kaytu_account_id":                 "metadata.SourceID",
	"kms_key_id":                       "description.Snapshot.KmsKeyId",
	"maintenance_track_name":           "description.Snapshot.MaintenanceTrackName",
	"manual_snapshot_remaining_days":   "description.Snapshot.ManualSnapshotRemainingDays",
	"manual_snapshot_retention_period": "description.Snapshot.ManualSnapshotRetentionPeriod",
	"master_username":                  "description.Snapshot.MasterUsername",
	"node_type":                        "description.Snapshot.NodeType",
	"number_of_nodes":                  "description.Snapshot.NumberOfNodes",
	"owner_account":                    "description.Snapshot.OwnerAccount",
	"port":                             "description.Snapshot.Port",
	"restorable_node_types":            "description.Snapshot.RestorableNodeTypes",
	"snapshot_create_time":             "description.Snapshot.SnapshotCreateTime",
	"snapshot_identifier":              "description.Snapshot.SnapshotIdentifier",
	"snapshot_retention_start_time":    "description.Snapshot.SnapshotRetentionStartTime",
	"snapshot_type":                    "description.Snapshot.SnapshotType",
	"source_region":                    "description.Snapshot.SourceRegion",
	"status":                           "description.Snapshot.Status",
	"tags_src":                         "description.Snapshot.Tags",
	"title":                            "description.Snapshot.SnapshotIdentifier",
	"total_backup_size_in_mega_bytes":  "description.Snapshot.TotalBackupSizeInMegaBytes",
	"vpc_id":                           "description.Snapshot.VpcId",
}

func ListRedshiftSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftSnapshotFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftSnapshotFilters = map[string]string{
	"accounts_with_restore_access":                 "description.Snapshot.AccountsWithRestoreAccess",
	"actual_incremental_backup_size_in_mega_bytes": "description.Snapshot.ActualIncrementalBackupSizeInMegaBytes",
	"availability_zone":                            "description.Snapshot.AvailabilityZone",
	"backup_progress_in_mega-bytes":                "description.Snapshot.BackupProgressInMegaBytes",
	"cluster_create_time":                          "description.Snapshot.ClusterCreateTime",
	"cluster_identifier":                           "description.Snapshot.ClusterIdentifier",
	"cluster_version":                              "description.Snapshot.ClusterVersion",
	"current_backup_rate_in_mega_bytes_per_second": "description.Snapshot.CurrentBackupRateInMegaBytesPerSecond",
	"db_name":                          "description.Snapshot.DBName",
	"elapsed_time_in_seconds":          "description.Snapshot.ElapsedTimeInSeconds",
	"encrypted":                        "description.Snapshot.Encrypted",
	"encrypted_with_hsm":               "description.Snapshot.EncryptedWithHSM",
	"engine_full_version":              "description.Snapshot.EngineFullVersion",
	"enhanced_vpc_routing":             "description.Snapshot.EnhancedVpcRouting",
	"estimated_seconds_to_completion":  "description.Snapshot.EstimatedSecondsToCompletion",
	"kaytu_account_id":                 "metadata.SourceID",
	"kms_key_id":                       "description.Snapshot.KmsKeyId",
	"maintenance_track_name":           "description.Snapshot.MaintenanceTrackName",
	"manual_snapshot_remaining_days":   "description.Snapshot.ManualSnapshotRemainingDays",
	"manual_snapshot_retention_period": "description.Snapshot.ManualSnapshotRetentionPeriod",
	"master_username":                  "description.Snapshot.MasterUsername",
	"node_type":                        "description.Snapshot.NodeType",
	"number_of_nodes":                  "description.Snapshot.NumberOfNodes",
	"owner_account":                    "description.Snapshot.OwnerAccount",
	"port":                             "description.Snapshot.Port",
	"restorable_node_types":            "description.Snapshot.RestorableNodeTypes",
	"snapshot_create_time":             "description.Snapshot.SnapshotCreateTime",
	"snapshot_identifier":              "description.Snapshot.SnapshotIdentifier",
	"snapshot_retention_start_time":    "description.Snapshot.SnapshotRetentionStartTime",
	"snapshot_type":                    "description.Snapshot.SnapshotType",
	"source_region":                    "description.Snapshot.SourceRegion",
	"status":                           "description.Snapshot.Status",
	"tags_src":                         "description.Snapshot.Tags",
	"title":                            "description.Snapshot.SnapshotIdentifier",
	"total_backup_size_in_mega_bytes":  "description.Snapshot.TotalBackupSizeInMegaBytes",
	"vpc_id":                           "description.Snapshot.VpcId",
}

func GetRedshiftSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftSnapshotFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftSnapshot =============================

// ==========================  START: RedshiftServerlessNamespace =============================

type RedshiftServerlessNamespace struct {
	Description   aws.RedshiftServerlessNamespaceDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type RedshiftServerlessNamespaceHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  RedshiftServerlessNamespace `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type RedshiftServerlessNamespaceHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []RedshiftServerlessNamespaceHit `json:"hits"`
}

type RedshiftServerlessNamespaceSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  RedshiftServerlessNamespaceHits `json:"hits"`
}

type RedshiftServerlessNamespacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftServerlessNamespacePaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftServerlessNamespacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshiftserverless_namespace", filters, limit)
	if err != nil {
		return RedshiftServerlessNamespacePaginator{}, err
	}

	p := RedshiftServerlessNamespacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftServerlessNamespacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftServerlessNamespacePaginator) NextPage(ctx context.Context) ([]RedshiftServerlessNamespace, error) {
	var response RedshiftServerlessNamespaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftServerlessNamespace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftServerlessNamespaceFilters = map[string]string{
	"akas":             "description.Namespace.NamespaceArn",
	"kaytu_account_id": "metadata.SourceID",
	"namespace_arn":    "description.Namespace.NamespaceArn",
	"namespace_id":     "description.Namespace.NamespaceId",
	"namespace_name":   "description.Namespace.NamespaceName",
	"title":            "description.Namespace.NamespaceName",
}

func ListRedshiftServerlessNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftServerlessNamespace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftServerlessNamespacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftServerlessNamespaceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftServerlessNamespaceFilters = map[string]string{
	"akas":             "description.Namespace.NamespaceArn",
	"kaytu_account_id": "metadata.SourceID",
	"namespace_arn":    "description.Namespace.NamespaceArn",
	"namespace_id":     "description.Namespace.NamespaceId",
	"namespace_name":   "description.Namespace.NamespaceName",
	"title":            "description.Namespace.NamespaceName",
}

func GetRedshiftServerlessNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftServerlessNamespace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftServerlessNamespacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftServerlessNamespaceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftServerlessNamespace =============================

// ==========================  START: RedshiftServerlessSnapshot =============================

type RedshiftServerlessSnapshot struct {
	Description   aws.RedshiftServerlessSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type RedshiftServerlessSnapshotHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  RedshiftServerlessSnapshot `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type RedshiftServerlessSnapshotHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []RedshiftServerlessSnapshotHit `json:"hits"`
}

type RedshiftServerlessSnapshotSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  RedshiftServerlessSnapshotHits `json:"hits"`
}

type RedshiftServerlessSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftServerlessSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftServerlessSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshiftserverless_snapshot", filters, limit)
	if err != nil {
		return RedshiftServerlessSnapshotPaginator{}, err
	}

	p := RedshiftServerlessSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftServerlessSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftServerlessSnapshotPaginator) NextPage(ctx context.Context) ([]RedshiftServerlessSnapshot, error) {
	var response RedshiftServerlessSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftServerlessSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftServerlessSnapshotFilters = map[string]string{
	"akas":             "description.Snapshot.SnapshotArn",
	"kaytu_account_id": "metadata.SourceID",
	"snapshot_arn":     "description.Snapshot.SnapshotArn",
	"snapshot_name":    "description.Snapshot.SnapshotName",
	"title":            "description.Snapshot.SnapshotName",
}

func ListRedshiftServerlessSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftServerlessSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftServerlessSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftServerlessSnapshotFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftServerlessSnapshotFilters = map[string]string{
	"akas":             "description.Snapshot.SnapshotArn",
	"kaytu_account_id": "metadata.SourceID",
	"snapshot_arn":     "description.Snapshot.SnapshotArn",
	"snapshot_name":    "description.Snapshot.SnapshotName",
	"title":            "description.Snapshot.SnapshotName",
}

func GetRedshiftServerlessSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftServerlessSnapshot")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftServerlessSnapshotPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftServerlessSnapshotFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftServerlessSnapshot =============================

// ==========================  START: RedshiftSubnetGroup =============================

type RedshiftSubnetGroup struct {
	Description   aws.RedshiftSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type RedshiftSubnetGroupHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RedshiftSubnetGroup `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RedshiftSubnetGroupHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RedshiftSubnetGroupHit `json:"hits"`
}

type RedshiftSubnetGroupSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RedshiftSubnetGroupHits `json:"hits"`
}

type RedshiftSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_subnetgroup", filters, limit)
	if err != nil {
		return RedshiftSubnetGroupPaginator{}, err
	}

	p := RedshiftSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftSubnetGroupPaginator) NextPage(ctx context.Context) ([]RedshiftSubnetGroup, error) {
	var response RedshiftSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftSubnetGroupFilters = map[string]string{
	"akas":                      "aRN",
	"cluster_subnet_group_name": "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"description":               "description.ClusterSubnetGroup.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"subnet_group_status":       "description.ClusterSubnetGroup.SubnetGroupStatus",
	"subnets":                   "description.ClusterSubnetGroup.Subnets",
	"tags_src":                  "description.ClusterSubnetGroup.Tags",
	"title":                     "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"vpc_id":                    "description.ClusterSubnetGroup.VpcId",
}

func ListRedshiftSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedshiftSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedshiftSubnetGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedshiftSubnetGroupFilters = map[string]string{
	"akas":                      "aRN",
	"cluster_subnet_group_name": "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"description":               "description.ClusterSubnetGroup.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"subnet_group_status":       "description.ClusterSubnetGroup.SubnetGroupStatus",
	"subnets":                   "description.ClusterSubnetGroup.Subnets",
	"tags_src":                  "description.ClusterSubnetGroup.Tags",
	"title":                     "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"vpc_id":                    "description.ClusterSubnetGroup.VpcId",
}

func GetRedshiftSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftSubnetGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedshiftSubnetGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedshiftSubnetGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedshiftSubnetGroup =============================

// ==========================  START: SNSTopic =============================

type SNSTopic struct {
	Description   aws.SNSTopicDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type SNSTopicHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SNSTopic      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SNSTopicHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SNSTopicHit     `json:"hits"`
}

type SNSTopicSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  SNSTopicHits `json:"hits"`
}

type SNSTopicPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSNSTopicPaginator(filters []essdk.BoolFilter, limit *int64) (SNSTopicPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sns_topic", filters, limit)
	if err != nil {
		return SNSTopicPaginator{}, err
	}

	p := SNSTopicPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SNSTopicPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SNSTopicPaginator) NextPage(ctx context.Context) ([]SNSTopic, error) {
	var response SNSTopicSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SNSTopic
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSNSTopicFilters = map[string]string{
	"akas":                      "description.Attributes.TopicArn",
	"delivery_policy":           "description.Attributes.DeliveryPolicy",
	"display_name":              "description.Attributes.DisplayName",
	"effective_delivery_policy": "description.Attributes.EffectiveDeliveryPolicy",
	"kaytu_account_id":          "metadata.SourceID",
	"kms_master_key_id":         "description.Attributes.KmsMasterKeyId",
	"owner":                     "description.Attributes.Owner",
	"policy":                    "description.Attributes.Policy",
	"policy_std":                "description.Attributes.Policy",
	"subscriptions_confirmed":   "description.Attributes.SubscriptionsConfirmed",
	"subscriptions_deleted":     "description.Attributes.SubscriptionsDeleted",
	"subscriptions_pending":     "description.Attributes.SubscriptionsPending",
	"tags_src":                  "description.Tags",
	"title":                     "description.Attributes.TopicArn",
	"topic_arn":                 "description.Attributes.TopicArn",
}

func ListSNSTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSNSTopic")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSNSTopicPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSNSTopicFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSNSTopicFilters = map[string]string{
	"akas":                      "description.Attributes.TopicArn",
	"delivery_policy":           "description.Attributes.DeliveryPolicy",
	"display_name":              "description.Attributes.DisplayName",
	"effective_delivery_policy": "description.Attributes.EffectiveDeliveryPolicy",
	"kaytu_account_id":          "metadata.SourceID",
	"kms_master_key_id":         "description.Attributes.KmsMasterKeyId",
	"owner":                     "description.Attributes.Owner",
	"policy":                    "description.Attributes.Policy",
	"policy_std":                "description.Attributes.Policy",
	"subscriptions_confirmed":   "description.Attributes.SubscriptionsConfirmed",
	"subscriptions_deleted":     "description.Attributes.SubscriptionsDeleted",
	"subscriptions_pending":     "description.Attributes.SubscriptionsPending",
	"tags_src":                  "description.Tags",
	"title":                     "description.Attributes.TopicArn",
	"topic_arn":                 "description.Attributes.TopicArn",
}

func GetSNSTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSNSTopic")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSNSTopicPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSNSTopicFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SNSTopic =============================

// ==========================  START: SNSSubscription =============================

type SNSSubscription struct {
	Description   aws.SNSSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type SNSSubscriptionHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  SNSSubscription `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type SNSSubscriptionHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []SNSSubscriptionHit `json:"hits"`
}

type SNSSubscriptionSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  SNSSubscriptionHits `json:"hits"`
}

type SNSSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSNSSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (SNSSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sns_subscription", filters, limit)
	if err != nil {
		return SNSSubscriptionPaginator{}, err
	}

	p := SNSSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SNSSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SNSSubscriptionPaginator) NextPage(ctx context.Context) ([]SNSSubscription, error) {
	var response SNSSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SNSSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSNSSubscriptionFilters = map[string]string{
	"akas":                           "description.Subscription.SubscriptionArn",
	"confirmation_was_authenticated": "description.Attributes.ConfirmationWasAuthenticated",
	"delivery_policy":                "description.Attributes.DeliveryPolicy",
	"effective_delivery_policy":      "description.Attributes.EffectiveDeliveryPolicy",
	"endpoint":                       "description.Subscription.Endpoint",
	"filter_policy":                  "description.Attributes.FilterPolicy",
	"kaytu_account_id":               "metadata.SourceID",
	"owner":                          "description.Subscription.Owner",
	"pending_confirmation":           "description.Attributes.PendingConfirmation",
	"protocol":                       "description.Subscription.Protocol",
	"raw_message_delivery":           "description.Attributes.RawMessageDelivery",
	"redrive_policy":                 "description.Attributes.RedrivePolicy",
	"subscription_arn":               "description.Subscription.SubscriptionArn",
	"title":                          "description.Subscription.SubscriptionArn",
	"topic_arn":                      "description.Subscription.TopicArn",
}

func ListSNSSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSNSSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSNSSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSNSSubscriptionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSNSSubscriptionFilters = map[string]string{
	"akas":                           "description.Subscription.SubscriptionArn",
	"confirmation_was_authenticated": "description.Attributes.ConfirmationWasAuthenticated",
	"delivery_policy":                "description.Attributes.DeliveryPolicy",
	"effective_delivery_policy":      "description.Attributes.EffectiveDeliveryPolicy",
	"endpoint":                       "description.Subscription.Endpoint",
	"filter_policy":                  "description.Attributes.FilterPolicy",
	"kaytu_account_id":               "metadata.SourceID",
	"owner":                          "description.Subscription.Owner",
	"pending_confirmation":           "description.Attributes.PendingConfirmation",
	"protocol":                       "description.Subscription.Protocol",
	"raw_message_delivery":           "description.Attributes.RawMessageDelivery",
	"redrive_policy":                 "description.Attributes.RedrivePolicy",
	"subscription_arn":               "description.Subscription.SubscriptionArn",
	"title":                          "description.Subscription.SubscriptionArn",
	"topic_arn":                      "description.Subscription.TopicArn",
}

func GetSNSSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSNSSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSNSSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSNSSubscriptionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SNSSubscription =============================

// ==========================  START: SQSQueue =============================

type SQSQueue struct {
	Description   aws.SQSQueueDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type SQSQueueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SQSQueue      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SQSQueueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SQSQueueHit     `json:"hits"`
}

type SQSQueueSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  SQSQueueHits `json:"hits"`
}

type SQSQueuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSQSQueuePaginator(filters []essdk.BoolFilter, limit *int64) (SQSQueuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sqs_queue", filters, limit)
	if err != nil {
		return SQSQueuePaginator{}, err
	}

	p := SQSQueuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SQSQueuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SQSQueuePaginator) NextPage(ctx context.Context) ([]SQSQueue, error) {
	var response SQSQueueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SQSQueue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSQSQueueFilters = map[string]string{
	"akas":                        "description.Attributes.QueueArn",
	"content_based_deduplication": "description.Attributes.ContentBasedDeduplication",
	"delay_seconds":               "description.Attributes.DelaySeconds",
	"fifo_queue":                  "description.Attributes.FifoQueue",
	"kaytu_account_id":            "metadata.SourceID",
	"kms_master_key_id":           "description.Attributes.KmsMasterKeyId",
	"max_message_size":            "description.Attributes.MaximumMessageSize",
	"message_retention_seconds":   "description.Attributes.MessageRetentionPeriod",
	"policy":                      "description.Attributes.Policy",
	"policy_std":                  "description.Attributes.Policy",
	"queue_arn":                   "description.Attributes.QueueArn",
	"queue_url":                   "description.Attributes.QueueUrl",
	"receive_wait_time_seconds":   "description.Attributes.ReceiveMessageWaitTimeSeconds",
	"redrive_policy":              "description.Attributes.RedrivePolicy",
	"tags":                        "description.Tags",
	"title":                       "description.Attributes.QueueUrl",
	"visibility_timeout_seconds":  "description.Attributes.VisibilityTimeout",
}

func ListSQSQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSQSQueue")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSQSQueuePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSQSQueueFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSQSQueueFilters = map[string]string{
	"akas":                        "description.Attributes.QueueArn",
	"content_based_deduplication": "description.Attributes.ContentBasedDeduplication",
	"delay_seconds":               "description.Attributes.DelaySeconds",
	"fifo_queue":                  "description.Attributes.FifoQueue",
	"kaytu_account_id":            "metadata.SourceID",
	"kms_master_key_id":           "description.Attributes.KmsMasterKeyId",
	"max_message_size":            "description.Attributes.MaximumMessageSize",
	"message_retention_seconds":   "description.Attributes.MessageRetentionPeriod",
	"policy":                      "description.Attributes.Policy",
	"policy_std":                  "description.Attributes.Policy",
	"queue_arn":                   "description.Attributes.QueueArn",
	"queue_url":                   "description.Attributes.QueueUrl",
	"receive_wait_time_seconds":   "description.Attributes.ReceiveMessageWaitTimeSeconds",
	"redrive_policy":              "description.Attributes.RedrivePolicy",
	"tags":                        "description.Tags",
	"title":                       "description.Attributes.QueueUrl",
	"visibility_timeout_seconds":  "description.Attributes.VisibilityTimeout",
}

func GetSQSQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSQSQueue")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSQSQueuePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSQSQueueFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SQSQueue =============================

// ==========================  START: S3Bucket =============================

type S3Bucket struct {
	Description   aws.S3BucketDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type S3BucketHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  S3Bucket      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type S3BucketHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []S3BucketHit     `json:"hits"`
}

type S3BucketSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  S3BucketHits `json:"hits"`
}

type S3BucketPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3BucketPaginator(filters []essdk.BoolFilter, limit *int64) (S3BucketPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_bucket", filters, limit)
	if err != nil {
		return S3BucketPaginator{}, err
	}

	p := S3BucketPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3BucketPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3BucketPaginator) NextPage(ctx context.Context) ([]S3Bucket, error) {
	var response S3BucketSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3Bucket
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3BucketFilters = map[string]string{
	"acl":                                  "description.BucketAcl",
	"block_public_acls":                    "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":                  "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_policy_is_public":              "description.PolicyStatus.IsPublic",
	"creation_date":                        "description.Bucket.CreationDate",
	"ignore_public_acls":                   "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"kaytu_account_id":                     "metadata.SourceID",
	"lifecycle_rules":                      "description.LifecycleRules",
	"logging":                              "description.LoggingEnabled",
	"name":                                 "description.Bucket.Name",
	"object_lock_configuration":            "description.ObjectLockConfiguration",
	"policy":                               "description.Policy",
	"policy_std":                           "description.Policy",
	"replication":                          "description.ReplicationConfiguration",
	"restrict_public_buckets":              "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"server_side_encryption_configuration": "description.ServerSideEncryptionConfiguration",
	"tags_src":                             "description.Tags",
	"title":                                "description.Bucket.Name",
	"versioning_enabled":                   "description.Versioning.Status",
	"versioning_mfa_delete":                "description.Versioning.MFADelete",
}

func ListS3Bucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3Bucket")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewS3BucketPaginator(essdk.BuildFilter(d.KeyColumnQuals, listS3BucketFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getS3BucketFilters = map[string]string{
	"acl":                                  "description.BucketAcl",
	"block_public_acls":                    "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":                  "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_policy_is_public":              "description.PolicyStatus.IsPublic",
	"creation_date":                        "description.Bucket.CreationDate",
	"ignore_public_acls":                   "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"kaytu_account_id":                     "metadata.SourceID",
	"lifecycle_rules":                      "description.LifecycleRules",
	"logging":                              "description.LoggingEnabled",
	"name":                                 "description.Bucket.Name",
	"object_lock_configuration":            "description.ObjectLockConfiguration",
	"policy":                               "description.Policy",
	"policy_std":                           "description.Policy",
	"replication":                          "description.ReplicationConfiguration",
	"restrict_public_buckets":              "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"server_side_encryption_configuration": "description.ServerSideEncryptionConfiguration",
	"tags_src":                             "description.Tags",
	"title":                                "description.Bucket.Name",
	"versioning_enabled":                   "description.Versioning.Status",
	"versioning_mfa_delete":                "description.Versioning.MFADelete",
}

func GetS3Bucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3Bucket")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewS3BucketPaginator(essdk.BuildFilter(d.KeyColumnQuals, getS3BucketFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: S3Bucket =============================

// ==========================  START: S3AccountSetting =============================

type S3AccountSetting struct {
	Description   aws.S3AccountSettingDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type S3AccountSettingHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  S3AccountSetting `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type S3AccountSettingHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []S3AccountSettingHit `json:"hits"`
}

type S3AccountSettingSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  S3AccountSettingHits `json:"hits"`
}

type S3AccountSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3AccountSettingPaginator(filters []essdk.BoolFilter, limit *int64) (S3AccountSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_accountsetting", filters, limit)
	if err != nil {
		return S3AccountSettingPaginator{}, err
	}

	p := S3AccountSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3AccountSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3AccountSettingPaginator) NextPage(ctx context.Context) ([]S3AccountSetting, error) {
	var response S3AccountSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3AccountSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3AccountSettingFilters = map[string]string{
	"block_public_acls":       "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":     "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"ignore_public_acls":      "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"kaytu_account_id":        "metadata.SourceID",
	"restrict_public_buckets": "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
}

func ListS3AccountSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3AccountSetting")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewS3AccountSettingPaginator(essdk.BuildFilter(d.KeyColumnQuals, listS3AccountSettingFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getS3AccountSettingFilters = map[string]string{
	"block_public_acls":       "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":     "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"ignore_public_acls":      "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"kaytu_account_id":        "metadata.SourceID",
	"restrict_public_buckets": "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
}

func GetS3AccountSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3AccountSetting")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewS3AccountSettingPaginator(essdk.BuildFilter(d.KeyColumnQuals, getS3AccountSettingFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: S3AccountSetting =============================

// ==========================  START: SageMakerEndpointConfiguration =============================

type SageMakerEndpointConfiguration struct {
	Description   aws.SageMakerEndpointConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type SageMakerEndpointConfigurationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  SageMakerEndpointConfiguration `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type SageMakerEndpointConfigurationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []SageMakerEndpointConfigurationHit `json:"hits"`
}

type SageMakerEndpointConfigurationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  SageMakerEndpointConfigurationHits `json:"hits"`
}

type SageMakerEndpointConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerEndpointConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerEndpointConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_endpointconfiguration", filters, limit)
	if err != nil {
		return SageMakerEndpointConfigurationPaginator{}, err
	}

	p := SageMakerEndpointConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerEndpointConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerEndpointConfigurationPaginator) NextPage(ctx context.Context) ([]SageMakerEndpointConfiguration, error) {
	var response SageMakerEndpointConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerEndpointConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerEndpointConfigurationFilters = map[string]string{
	"akas":                "description.EndpointConfig.EndpointConfigArn",
	"arn":                 "description.EndpointConfig.EndpointConfigArn",
	"creation_time":       "description.EndpointConfig.CreationTime",
	"data_capture_config": "description.EndpointConfig.DataCaptureConfig",
	"kaytu_account_id":    "metadata.SourceID",
	"kms_key_id":          "description.EndpointConfig.KmsKeyId",
	"name":                "description.EndpointConfig.EndpointConfigName",
	"production_variants": "description.EndpointConfig.ProductionVariants",
	"tags_src":            "description.Tags",
	"title":               "description.EndpointConfig.EndpointConfigName",
}

func ListSageMakerEndpointConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerEndpointConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSageMakerEndpointConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSageMakerEndpointConfigurationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSageMakerEndpointConfigurationFilters = map[string]string{
	"akas":                "description.EndpointConfig.EndpointConfigArn",
	"arn":                 "description.EndpointConfig.EndpointConfigArn",
	"creation_time":       "description.EndpointConfig.CreationTime",
	"data_capture_config": "description.EndpointConfig.DataCaptureConfig",
	"kaytu_account_id":    "metadata.SourceID",
	"kms_key_id":          "description.EndpointConfig.KmsKeyId",
	"name":                "description.EndpointConfig.EndpointConfigName",
	"production_variants": "description.EndpointConfig.ProductionVariants",
	"tags_src":            "description.Tags",
	"title":               "description.EndpointConfig.EndpointConfigName",
}

func GetSageMakerEndpointConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerEndpointConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSageMakerEndpointConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSageMakerEndpointConfigurationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SageMakerEndpointConfiguration =============================

// ==========================  START: SageMakerApp =============================

type SageMakerApp struct {
	Description   aws.SageMakerAppDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type SageMakerAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SageMakerApp  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SageMakerAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SageMakerAppHit `json:"hits"`
}

type SageMakerAppSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SageMakerAppHits `json:"hits"`
}

type SageMakerAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerAppPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_app", filters, limit)
	if err != nil {
		return SageMakerAppPaginator{}, err
	}

	p := SageMakerAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerAppPaginator) NextPage(ctx context.Context) ([]SageMakerApp, error) {
	var response SageMakerAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerAppFilters = map[string]string{
	"akas":                         "description.DescribeAppOutput.AppArn",
	"app_type":                     "description.AppDetails.AppType",
	"arn":                          "description.DescribeAppOutput.AppArn",
	"creation_time":                "description.AppDetails.CreationTime",
	"domain_id":                    "description.DescribeAppOutput.DomainId",
	"failure_reason":               "description.DescribeAppOutput.FailureReason",
	"kaytu_account_id":             "metadata.SourceID",
	"last_health_check_timestamp":  "description.DescribeAppOutput.LastHealthCheckTimestamp",
	"last_user_activity_timestamp": "description.DescribeAppOutput.LastUserActivityTimestamp",
	"name":                         "description.AppDetails.AppName",
	"resource_spec":                "description.DescribeAppOutput.ResourceSpec",
	"status":                       "description.AppDetails.Status",
	"title":                        "description.AppDetails.AppName",
	"user_profile_name":            "description.DescribeAppOutput.UserProfileName",
}

func ListSageMakerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSageMakerAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSageMakerAppFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSageMakerAppFilters = map[string]string{
	"akas":                         "description.DescribeAppOutput.AppArn",
	"app_type":                     "description.DescribeAppOutput.AppType",
	"arn":                          "description.DescribeAppOutput.AppArn",
	"creation_time":                "description.AppDetails.CreationTime",
	"domain_id":                    "description.DescribeAppOutput.DomainId",
	"failure_reason":               "description.DescribeAppOutput.FailureReason",
	"kaytu_account_id":             "metadata.SourceID",
	"last_health_check_timestamp":  "description.DescribeAppOutput.LastHealthCheckTimestamp",
	"last_user_activity_timestamp": "description.DescribeAppOutput.LastUserActivityTimestamp",
	"name":                         "description.DescribeAppOutput.AppName",
	"resource_spec":                "description.DescribeAppOutput.ResourceSpec",
	"status":                       "description.AppDetails.Status",
	"title":                        "description.AppDetails.AppName",
	"user_profile_name":            "description.DescribeAppOutput.UserProfileName",
}

func GetSageMakerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSageMakerAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSageMakerAppFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SageMakerApp =============================

// ==========================  START: SageMakerDomain =============================

type SageMakerDomain struct {
	Description   aws.SageMakerDomainDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type SageMakerDomainHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  SageMakerDomain `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type SageMakerDomainHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []SageMakerDomainHit `json:"hits"`
}

type SageMakerDomainSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  SageMakerDomainHits `json:"hits"`
}

type SageMakerDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerDomainPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_domain", filters, limit)
	if err != nil {
		return SageMakerDomainPaginator{}, err
	}

	p := SageMakerDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerDomainPaginator) NextPage(ctx context.Context) ([]SageMakerDomain, error) {
	var response SageMakerDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerDomainFilters = map[string]string{
	"akas":                                  "description.Domain.DomainArn",
	"app_network_access_type":               "description.Domain.AppNetworkAccessType",
	"app_security_group_management":         "description.Domain.AppSecurityGroupManagement",
	"arn":                                   "description.Domain.DomainArn",
	"auth_mode":                             "description.Domain.AuthMode",
	"creation_time":                         "description.Domain.CreationTime",
	"default_user_settings":                 "description.Domain.DefaultUserSettings",
	"domain_settings":                       "description.Domain.DomainSettings",
	"failure_reason":                        "description.Domain.FailureReason",
	"home_efs_file_system_id":               "description.Domain.HomeEfsFileSystemId",
	"id":                                    "description.Domain.DomainId",
	"kaytu_account_id":                      "metadata.SourceID",
	"kms_key_id":                            "description.Domain.KmsKeyId",
	"last_modified_time":                    "description.Domain.LastModifiedTime",
	"name":                                  "description.Domain.DomainName",
	"security_group_id_for_domain_boundary": "description.Domain.SecurityGroupIdForDomainBoundary",
	"single_sign_on_managed_application_instance_id": "description.Domain.SingleSignOnManagedApplicationInstanceId",
	"status":     "description.Domain.Status",
	"subnet_ids": "description.Domain.SubnetIds",
	"tags_src":   "description.Tags",
	"title":      "description.Domain.DomainName",
	"url":        "description.DomainItem.Url",
}

func ListSageMakerDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSageMakerDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSageMakerDomainFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSageMakerDomainFilters = map[string]string{
	"akas":                                  "description.Domain.DomainArn",
	"app_network_access_type":               "description.Domain.AppNetworkAccessType",
	"app_security_group_management":         "description.Domain.AppSecurityGroupManagement",
	"arn":                                   "description.Domain.DomainArn",
	"auth_mode":                             "description.Domain.AuthMode",
	"creation_time":                         "description.Domain.CreationTime",
	"default_user_settings":                 "description.Domain.DefaultUserSettings",
	"domain_settings":                       "description.Domain.DomainSettings",
	"failure_reason":                        "description.Domain.FailureReason",
	"home_efs_file_system_id":               "description.Domain.HomeEfsFileSystemId",
	"id":                                    "description.Domain.DomainId",
	"kaytu_account_id":                      "metadata.SourceID",
	"kms_key_id":                            "description.Domain.KmsKeyId",
	"last_modified_time":                    "description.Domain.LastModifiedTime",
	"name":                                  "description.Domain.DomainName",
	"security_group_id_for_domain_boundary": "description.Domain.SecurityGroupIdForDomainBoundary",
	"single_sign_on_managed_application_instance_id": "description.Domain.SingleSignOnManagedApplicationInstanceId",
	"status":     "description.Domain.Status",
	"subnet_ids": "description.Domain.SubnetIds",
	"tags_src":   "description.Tags",
	"title":      "description.Domain.DomainName",
	"url":        "description.DomainItem.Url",
}

func GetSageMakerDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSageMakerDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSageMakerDomainFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SageMakerDomain =============================

// ==========================  START: SageMakerNotebookInstance =============================

type SageMakerNotebookInstance struct {
	Description   aws.SageMakerNotebookInstanceDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type SageMakerNotebookInstanceHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  SageMakerNotebookInstance `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type SageMakerNotebookInstanceHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []SageMakerNotebookInstanceHit `json:"hits"`
}

type SageMakerNotebookInstanceSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  SageMakerNotebookInstanceHits `json:"hits"`
}

type SageMakerNotebookInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerNotebookInstancePaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerNotebookInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_notebookinstance", filters, limit)
	if err != nil {
		return SageMakerNotebookInstancePaginator{}, err
	}

	p := SageMakerNotebookInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerNotebookInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerNotebookInstancePaginator) NextPage(ctx context.Context) ([]SageMakerNotebookInstance, error) {
	var response SageMakerNotebookInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerNotebookInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerNotebookInstanceFilters = map[string]string{
	"accelerator_types":            "description.NotebookInstance.AcceleratorTypes",
	"additional_code_repositories": "description.NotebookInstance.AdditionalCodeRepositories",
	"akas":                         "description.NotebookInstance.NotebookInstanceArn",
	"arn":                          "description.NotebookInstance.NotebookInstanceArn",
	"creation_time":                "description.NotebookInstance.CreationTime",
	"default_code_repository":      "description.NotebookInstance.DefaultCodeRepository",
	"direct_internet_access":       "description.NotebookInstance.DirectInternetAccess",
	"failure_reason":               "description.NotebookInstance.FailureReason",
	"instance_type":                "description.NotebookInstance.InstanceType",
	"kaytu_account_id":             "metadata.SourceID",
	"kms_key_id":                   "description.NotebookInstance.KmsKeyId",
	"last_modified_time":           "description.NotebookInstance.LastModifiedTime",
	"name":                         "description.NotebookInstance.NotebookInstanceName",
	"network_interface_id":         "description.NotebookInstance.NetworkInterfaceId",
	"notebook_instance_lifecycle_config_name": "description.NotebookInstance.NotebookInstanceLifecycleConfigName",
	"notebook_instance_status":                "description.NotebookInstance.NotebookInstanceStatus",
	"role_arn":                                "description.NotebookInstance.RoleArn",
	"root_access":                             "description.NotebookInstance.RootAccess",
	"security_groups":                         "description.NotebookInstance.SecurityGroups",
	"subnet_id":                               "description.NotebookInstance.SubnetId",
	"tags_src":                                "description.Tags",
	"title":                                   "description.NotebookInstance.NotebookInstanceName",
	"url":                                     "description.NotebookInstance.Url",
	"volume_size_in_gb":                       "description.NotebookInstance.VolumeSizeInGB",
}

func ListSageMakerNotebookInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerNotebookInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSageMakerNotebookInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSageMakerNotebookInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSageMakerNotebookInstanceFilters = map[string]string{
	"accelerator_types":            "description.NotebookInstance.AcceleratorTypes",
	"additional_code_repositories": "description.NotebookInstance.AdditionalCodeRepositories",
	"akas":                         "description.NotebookInstance.NotebookInstanceArn",
	"arn":                          "description.NotebookInstance.NotebookInstanceArn",
	"creation_time":                "description.NotebookInstance.CreationTime",
	"default_code_repository":      "description.NotebookInstance.DefaultCodeRepository",
	"direct_internet_access":       "description.NotebookInstance.DirectInternetAccess",
	"failure_reason":               "description.NotebookInstance.FailureReason",
	"instance_type":                "description.NotebookInstance.InstanceType",
	"kaytu_account_id":             "metadata.SourceID",
	"kms_key_id":                   "description.NotebookInstance.KmsKeyId",
	"last_modified_time":           "description.NotebookInstance.LastModifiedTime",
	"name":                         "description.NotebookInstance.NotebookInstanceName",
	"network_interface_id":         "description.NotebookInstance.NetworkInterfaceId",
	"notebook_instance_lifecycle_config_name": "description.NotebookInstance.NotebookInstanceLifecycleConfigName",
	"notebook_instance_status":                "description.NotebookInstance.NotebookInstanceStatus",
	"role_arn":                                "description.NotebookInstance.RoleArn",
	"root_access":                             "description.NotebookInstance.RootAccess",
	"security_groups":                         "description.NotebookInstance.SecurityGroups",
	"subnet_id":                               "description.NotebookInstance.SubnetId",
	"tags_src":                                "description.Tags",
	"title":                                   "description.NotebookInstance.NotebookInstanceName",
	"url":                                     "description.NotebookInstance.Url",
	"volume_size_in_gb":                       "description.NotebookInstance.VolumeSizeInGB",
}

func GetSageMakerNotebookInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerNotebookInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSageMakerNotebookInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSageMakerNotebookInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SageMakerNotebookInstance =============================

// ==========================  START: SageMakerModel =============================

type SageMakerModel struct {
	Description   aws.SageMakerModelDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type SageMakerModelHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SageMakerModel `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SageMakerModelHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SageMakerModelHit `json:"hits"`
}

type SageMakerModelSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SageMakerModelHits `json:"hits"`
}

type SageMakerModelPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerModelPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerModelPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_model", filters, limit)
	if err != nil {
		return SageMakerModelPaginator{}, err
	}

	p := SageMakerModelPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerModelPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerModelPaginator) NextPage(ctx context.Context) ([]SageMakerModel, error) {
	var response SageMakerModelSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerModel
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerModelFilters = map[string]string{
	"akas":                       "description.Model.ModelArn",
	"arn":                        "description.Model.ModelArn",
	"containers":                 "description.Model.Containers",
	"creation_time":              "description.Model.CreationTime",
	"enable_network_isolation":   "description.Model.EnableNetworkIsolation",
	"execution_role_arn":         "description.Model.ExecutionRoleArn",
	"inference_execution_config": "description.Model.InferenceExecutionConfig",
	"kaytu_account_id":           "metadata.SourceID",
	"name":                       "description.Model.ModelName",
	"primary_container":          "description.Model.PrimaryContainer",
	"tags_src":                   "description.Tags",
	"title":                      "description.Model.ModelName",
	"vpc_config":                 "description.Model.VpcConfig",
}

func ListSageMakerModel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerModel")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSageMakerModelPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSageMakerModelFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSageMakerModelFilters = map[string]string{
	"akas":                       "description.Model.ModelArn",
	"arn":                        "description.Model.ModelArn",
	"containers":                 "description.Model.Containers",
	"creation_time":              "description.Model.CreationTime",
	"enable_network_isolation":   "description.Model.EnableNetworkIsolation",
	"execution_role_arn":         "description.Model.ExecutionRoleArn",
	"inference_execution_config": "description.Model.InferenceExecutionConfig",
	"kaytu_account_id":           "metadata.SourceID",
	"name":                       "description.Model.ModelName",
	"primary_container":          "description.Model.PrimaryContainer",
	"tags_src":                   "description.Tags",
	"title":                      "description.Model.ModelName",
	"vpc_config":                 "description.Model.VpcConfig",
}

func GetSageMakerModel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerModel")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSageMakerModelPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSageMakerModelFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SageMakerModel =============================

// ==========================  START: SageMakerTrainingJob =============================

type SageMakerTrainingJob struct {
	Description   aws.SageMakerTrainingJobDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SageMakerTrainingJobHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SageMakerTrainingJob `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SageMakerTrainingJobHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SageMakerTrainingJobHit `json:"hits"`
}

type SageMakerTrainingJobSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SageMakerTrainingJobHits `json:"hits"`
}

type SageMakerTrainingJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerTrainingJobPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerTrainingJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_trainingjob", filters, limit)
	if err != nil {
		return SageMakerTrainingJobPaginator{}, err
	}

	p := SageMakerTrainingJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerTrainingJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerTrainingJobPaginator) NextPage(ctx context.Context) ([]SageMakerTrainingJob, error) {
	var response SageMakerTrainingJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerTrainingJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerTrainingJobFilters = map[string]string{
	"akas":                           "description.TrainingJob.TrainingJobArn",
	"algorithm_specification":        "description.TrainingJob.AlgorithmSpecification",
	"arn":                            "description.TrainingJob.TrainingJobArn",
	"auto_ml_job_arn":                "description.TrainingJob.AutoMLJobArn",
	"billable_time_in_seconds":       "description.TrainingJob.BillableTimeInSeconds",
	"checkpoint_config":              "description.TrainingJob.CheckpointConfig",
	"creation_time":                  "description.TrainingJob.CreationTime",
	"debug_hook_config":              "description.TrainingJob.DebugHookConfig",
	"debug_rule_configurations":      "description.TrainingJob.DebugRuleConfigurations",
	"debug_rule_evaluation_statuses": "description.TrainingJob.DebugRuleEvaluationStatuses",
	"enable_inter_container_traffic_encryption": "description.TrainingJob.EnableInterContainerTrafficEncryption",
	"enable_managed_spot_training":              "description.TrainingJob.EnableManagedSpotTraining",
	"enable_network_isolation":                  "description.TrainingJob.EnableNetworkIsolation",
	"environment":                               "description.TrainingJob.Environment",
	"experiment_config":                         "description.TrainingJob.ExperimentConfig",
	"failure_reason":                            "description.TrainingJob.FailureReason",
	"final_metric_data_list":                    "description.TrainingJob.FinalMetricDataList",
	"hyper_parameters":                          "description.TrainingJob.HyperParameters",
	"input_data_config":                         "description.TrainingJob.InputDataConfig",
	"kaytu_account_id":                          "metadata.SourceID",
	"labeling_job_arn":                          "description.TrainingJob.LabelingJobArn",
	"last_modified_time":                        "description.TrainingJob.LastModifiedTime",
	"model_artifacts":                           "description.TrainingJob.ModelArtifacts",
	"name":                                      "description.TrainingJob.TrainingJobName",
	"output_data_config":                        "description.TrainingJob.OutputDataConfig",
	"profiler_config":                           "description.TrainingJob.ProfilerConfig",
	"profiler_rule_configurations":              "description.TrainingJob.ProfilerRuleConfigurations",
	"profiler_rule_evaluation_statuses":         "description.TrainingJob.ProfilerRuleEvaluationStatuses",
	"profiling_status":                          "description.TrainingJob.ProfilingStatus",
	"resource_config":                           "description.TrainingJob.ResourceConfig",
	"role_arn":                                  "description.TrainingJob.RoleArn",
	"secondary_status":                          "description.TrainingJob.SecondaryStatus",
	"secondary_status_transitions":              "description.TrainingJob.SecondaryStatusTransitions",
	"stopping_condition":                        "description.TrainingJob.StoppingCondition",
	"tags_src":                                  "description.Tags",
	"tensor_board_output_config":                "description.TrainingJob.TensorBoardOutputConfig",
	"title":                                     "description.TrainingJob.TrainingJobName",
	"training_end_time":                         "description.TrainingJob.TrainingEndTime",
	"training_job_status":                       "description.TrainingJob.TrainingJobStatus",
	"training_start_time":                       "description.TrainingJob.TrainingStartTime",
	"training_time_in_seconds":                  "description.TrainingJob.TrainingTimeInSeconds",
	"tuning_job_arn":                            "description.TrainingJob.TuningJobArn",
	"vpc_config":                                "description.TrainingJob.VpcConfig",
}

func ListSageMakerTrainingJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerTrainingJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSageMakerTrainingJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSageMakerTrainingJobFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSageMakerTrainingJobFilters = map[string]string{
	"akas":                           "description.TrainingJob.TrainingJobArn",
	"algorithm_specification":        "description.TrainingJob.AlgorithmSpecification",
	"arn":                            "description.TrainingJob.TrainingJobArn",
	"auto_ml_job_arn":                "description.TrainingJob.AutoMLJobArn",
	"billable_time_in_seconds":       "description.TrainingJob.BillableTimeInSeconds",
	"checkpoint_config":              "description.TrainingJob.CheckpointConfig",
	"creation_time":                  "description.TrainingJob.CreationTime",
	"debug_hook_config":              "description.TrainingJob.DebugHookConfig",
	"debug_rule_configurations":      "description.TrainingJob.DebugRuleConfigurations",
	"debug_rule_evaluation_statuses": "description.TrainingJob.DebugRuleEvaluationStatuses",
	"enable_inter_container_traffic_encryption": "description.TrainingJob.EnableInterContainerTrafficEncryption",
	"enable_managed_spot_training":              "description.TrainingJob.EnableManagedSpotTraining",
	"enable_network_isolation":                  "description.TrainingJob.EnableNetworkIsolation",
	"environment":                               "description.TrainingJob.Environment",
	"experiment_config":                         "description.TrainingJob.ExperimentConfig",
	"failure_reason":                            "description.TrainingJob.FailureReason",
	"final_metric_data_list":                    "description.TrainingJob.FinalMetricDataList",
	"hyper_parameters":                          "description.TrainingJob.HyperParameters",
	"input_data_config":                         "description.TrainingJob.InputDataConfig",
	"kaytu_account_id":                          "metadata.SourceID",
	"labeling_job_arn":                          "description.TrainingJob.LabelingJobArn",
	"last_modified_time":                        "description.TrainingJob.LastModifiedTime",
	"model_artifacts":                           "description.TrainingJob.ModelArtifacts",
	"name":                                      "description.TrainingJob.Name",
	"output_data_config":                        "description.TrainingJob.OutputDataConfig",
	"profiler_config":                           "description.TrainingJob.ProfilerConfig",
	"profiler_rule_configurations":              "description.TrainingJob.ProfilerRuleConfigurations",
	"profiler_rule_evaluation_statuses":         "description.TrainingJob.ProfilerRuleEvaluationStatuses",
	"profiling_status":                          "description.TrainingJob.ProfilingStatus",
	"resource_config":                           "description.TrainingJob.ResourceConfig",
	"role_arn":                                  "description.TrainingJob.RoleArn",
	"secondary_status":                          "description.TrainingJob.SecondaryStatus",
	"secondary_status_transitions":              "description.TrainingJob.SecondaryStatusTransitions",
	"stopping_condition":                        "description.TrainingJob.StoppingCondition",
	"tags_src":                                  "description.Tags",
	"tensor_board_output_config":                "description.TrainingJob.TensorBoardOutputConfig",
	"title":                                     "description.TrainingJob.TrainingJobName",
	"training_end_time":                         "description.TrainingJob.TrainingEndTime",
	"training_job_status":                       "description.TrainingJob.TrainingJobStatus",
	"training_start_time":                       "description.TrainingJob.TrainingStartTime",
	"training_time_in_seconds":                  "description.TrainingJob.TrainingTimeInSeconds",
	"tuning_job_arn":                            "description.TrainingJob.TuningJobArn",
	"vpc_config":                                "description.TrainingJob.VpcConfig",
}

func GetSageMakerTrainingJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerTrainingJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSageMakerTrainingJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSageMakerTrainingJobFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SageMakerTrainingJob =============================

// ==========================  START: SecretsManagerSecret =============================

type SecretsManagerSecret struct {
	Description   aws.SecretsManagerSecretDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SecretsManagerSecretHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SecretsManagerSecret `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SecretsManagerSecretHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SecretsManagerSecretHit `json:"hits"`
}

type SecretsManagerSecretSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SecretsManagerSecretHits `json:"hits"`
}

type SecretsManagerSecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecretsManagerSecretPaginator(filters []essdk.BoolFilter, limit *int64) (SecretsManagerSecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_secretsmanager_secret", filters, limit)
	if err != nil {
		return SecretsManagerSecretPaginator{}, err
	}

	p := SecretsManagerSecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecretsManagerSecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecretsManagerSecretPaginator) NextPage(ctx context.Context) ([]SecretsManagerSecret, error) {
	var response SecretsManagerSecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecretsManagerSecret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecretsManagerSecretFilters = map[string]string{
	"akas":                      "description.Secret.ARN",
	"arn":                       "description.Secret.ARN",
	"created_date":              "description.Secret.CreatedDate",
	"deleted_date":              "description.Secret.DeletedDate",
	"description":               "description.Secret.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"kms_key_id":                "description.Secret.KmsKeyId",
	"last_accessed_date":        "description.Secret.LastAccessedDate",
	"last_changed_date":         "description.Secret.LastChangedDate",
	"last_rotated_date":         "description.Secret.LastRotatedDate",
	"name":                      "description.Secret.Name",
	"owning_service":            "description.Secret.OwningService",
	"policy":                    "description.ResourcePolicy",
	"policy_std":                "description.ResourcePolicy",
	"primary_region":            "description.Secret.PrimaryRegion",
	"replication_status":        "description.Secret.ReplicationStatus",
	"rotation_enabled":          "description.Secret.RotationEnabled",
	"rotation_lambda_arn":       "description.Secret.RotationLambdaARN",
	"rotation_rules":            "description.Secret.RotationRules",
	"secret_versions_to_stages": "description.Secret.VersionIdsToStages",
	"tags":                      "description.Secret.Tags",
	"tags_src":                  "description.Secret.Tags",
	"title":                     "description.Secret.Name",
}

func ListSecretsManagerSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecretsManagerSecret")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecretsManagerSecretPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecretsManagerSecretFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecretsManagerSecretFilters = map[string]string{
	"akas":                      "description.Secret.ARN",
	"arn":                       "description.Secret.ARN",
	"created_date":              "description.Secret.CreatedDate",
	"deleted_date":              "description.Secret.DeletedDate",
	"description":               "description.Secret.Description",
	"kaytu_account_id":          "metadata.SourceID",
	"kms_key_id":                "description.Secret.KmsKeyId",
	"last_accessed_date":        "description.Secret.LastAccessedDate",
	"last_changed_date":         "description.Secret.LastChangedDate",
	"last_rotated_date":         "description.Secret.LastRotatedDate",
	"name":                      "description.Secret.Name",
	"owning_service":            "description.Secret.OwningService",
	"policy":                    "description.ResourcePolicy",
	"policy_std":                "description.ResourcePolicy",
	"primary_region":            "description.Secret.PrimaryRegion",
	"replication_status":        "description.Secret.ReplicationStatus",
	"rotation_enabled":          "description.Secret.RotationEnabled",
	"rotation_lambda_arn":       "description.Secret.RotationLambdaARN",
	"rotation_rules":            "description.Secret.RotationRules",
	"secret_versions_to_stages": "description.Secret.VersionIdsToStages",
	"tags":                      "description.Secret.Tags",
	"tags_src":                  "description.Secret.Tags",
	"title":                     "description.Secret.Name",
}

func GetSecretsManagerSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecretsManagerSecret")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecretsManagerSecretPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecretsManagerSecretFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecretsManagerSecret =============================

// ==========================  START: SecurityHubHub =============================

type SecurityHubHub struct {
	Description   aws.SecurityHubHubDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type SecurityHubHubHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SecurityHubHub `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SecurityHubHubHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SecurityHubHubHit `json:"hits"`
}

type SecurityHubHubSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SecurityHubHubHits `json:"hits"`
}

type SecurityHubHubPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubHubPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubHubPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_hub", filters, limit)
	if err != nil {
		return SecurityHubHubPaginator{}, err
	}

	p := SecurityHubHubPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubHubPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubHubPaginator) NextPage(ctx context.Context) ([]SecurityHubHub, error) {
	var response SecurityHubHubSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubHub
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubHubFilters = map[string]string{
	"akas":                 "hubArn",
	"auto_enable_controls": "description.Hub.AutoEnableControls",
	"hub_arn":              "description.Hub.HubArn",
	"kaytu_account_id":     "metadata.SourceID",
	"subscribed_at":        "description.Hub.SubscribedAt",
	"tags":                 "description.Tags",
}

func ListSecurityHubHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubHub")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubHubPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubHubFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubHubFilters = map[string]string{
	"akas":                 "hubArn",
	"auto_enable_controls": "description.Hub.AutoEnableControls",
	"hub_arn":              "description.Hub.HubArn",
	"kaytu_account_id":     "metadata.SourceID",
	"subscribed_at":        "description.Hub.SubscribedAt",
	"tags":                 "description.Tags",
}

func GetSecurityHubHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubHub")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubHubPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubHubFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubHub =============================

// ==========================  START: SecurityHubActionTarget =============================

type SecurityHubActionTarget struct {
	Description   aws.SecurityHubActionTargetDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type SecurityHubActionTargetHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  SecurityHubActionTarget `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type SecurityHubActionTargetHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []SecurityHubActionTargetHit `json:"hits"`
}

type SecurityHubActionTargetSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  SecurityHubActionTargetHits `json:"hits"`
}

type SecurityHubActionTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubActionTargetPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubActionTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_actiontarget", filters, limit)
	if err != nil {
		return SecurityHubActionTargetPaginator{}, err
	}

	p := SecurityHubActionTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubActionTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubActionTargetPaginator) NextPage(ctx context.Context) ([]SecurityHubActionTarget, error) {
	var response SecurityHubActionTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubActionTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubActionTargetFilters = map[string]string{
	"akas":             "description.ActionTarget.ActionTargetArn",
	"arn":              "description.ActionTarget.ActionTargetArn",
	"description":      "description.ActionTarget.Description",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ActionTarget.Name",
	"title":            "description.ActionTarget.Name",
}

func ListSecurityHubActionTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubActionTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubActionTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubActionTargetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubActionTargetFilters = map[string]string{
	"akas":             "description.ActionTarget.ActionTargetArn",
	"arn":              "description.ActionTarget.ActionTargetArn",
	"description":      "description.ActionTarget.Description",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ActionTarget.Name",
	"title":            "description.ActionTarget.Name",
}

func GetSecurityHubActionTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubActionTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubActionTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubActionTargetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubActionTarget =============================

// ==========================  START: SecurityHubFinding =============================

type SecurityHubFinding struct {
	Description   aws.SecurityHubFindingDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SecurityHubFindingHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SecurityHubFinding `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SecurityHubFindingHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SecurityHubFindingHit `json:"hits"`
}

type SecurityHubFindingSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SecurityHubFindingHits `json:"hits"`
}

type SecurityHubFindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubFindingPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubFindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_finding", filters, limit)
	if err != nil {
		return SecurityHubFindingPaginator{}, err
	}

	p := SecurityHubFindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubFindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubFindingPaginator) NextPage(ctx context.Context) ([]SecurityHubFinding, error) {
	var response SecurityHubFindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubFinding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubFindingFilters = map[string]string{
	"action":                  "description.Finding.Action",
	"arn":                     "description.Finding.Id",
	"company_name":            "description.Finding.CompanyName",
	"compliance":              "description.Finding.Compliance",
	"compliance_status":       "description.Finding.Compliance.Status",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"criticality":             "description.Finding.Criticality",
	"description":             "description.Finding.Description",
	"finding_provider_fields": "description.Finding.FindingProviderFields",
	"first_observed_at":       "description.Finding.FirstObservedAt",
	"generator_id":            "description.Finding.GeneratorId",
	"id":                      "description.Finding.Id",
	"kaytu_account_id":        "metadata.SourceID",
	"last_observed_at":        "description.Finding.LastObservedAt",
	"malware":                 "description.Finding.Malware",
	"network":                 "description.Finding.Network",
	"network_path":            "description.Finding.NetworkPath",
	"note":                    "description.Finding.Note",
	"patch_summary":           "description.Finding.PatchSummary",
	"process":                 "description.Finding.Process",
	"product_arn":             "description.Finding.ProductArn",
	"product_fields":          "description.Finding.ProductFields",
	"product_name":            "description.Finding.ProductName",
	"record_state":            "description.Finding.RecordState",
	"related_findings":        "description.Finding.RelatedFindings",
	"remediation":             "description.Finding.Remediation",
	"resources":               "description.Finding.Resources",
	"schema_version":          "description.Finding.SchemaVersion",
	"severity":                "description.Finding.Severity",
	"source_url":              "description.Finding.SourceUrl",
	"threat_intel_indicators": "description.Finding.ThreatIntelIndicators",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_defined_fields":     "description.Finding.UserDefinedFields",
	"verification_state":      "description.Finding.VerificationState",
	"vulnerabilities":         "description.Finding.Vulnerabilities",
	"workflow_state":          "description.Finding.WorkflowState",
	"workflow_status":         "description.Finding.Workflow.Status",
}

func ListSecurityHubFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubFinding")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubFindingPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubFindingFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubFindingFilters = map[string]string{
	"action":                  "description.Finding.Action",
	"arn":                     "description.Finding.Id",
	"company_name":            "description.Finding.CompanyName",
	"compliance":              "description.Finding.Compliance",
	"compliance_status":       "description.Finding.Compliance.Status",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"criticality":             "description.Finding.Criticality",
	"description":             "description.Finding.Description",
	"finding_provider_fields": "description.Finding.FindingProviderFields",
	"first_observed_at":       "description.Finding.FirstObservedAt",
	"generator_id":            "description.Finding.GeneratorId",
	"id":                      "description.Finding.Id",
	"kaytu_account_id":        "metadata.SourceID",
	"last_observed_at":        "description.Finding.LastObservedAt",
	"malware":                 "description.Finding.Malware",
	"network":                 "description.Finding.Network",
	"network_path":            "description.Finding.NetworkPath",
	"note":                    "description.Finding.Note",
	"patch_summary":           "description.Finding.PatchSummary",
	"process":                 "description.Finding.Process",
	"product_arn":             "description.Finding.ProductArn",
	"product_fields":          "description.Finding.ProductFields",
	"product_name":            "description.Finding.ProductName",
	"record_state":            "description.Finding.RecordState",
	"related_findings":        "description.Finding.RelatedFindings",
	"remediation":             "description.Finding.Remediation",
	"resources":               "description.Finding.Resources",
	"schema_version":          "description.Finding.SchemaVersion",
	"severity":                "description.Finding.Severity",
	"source_url":              "description.Finding.SourceUrl",
	"threat_intel_indicators": "description.Finding.ThreatIntelIndicators",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_defined_fields":     "description.Finding.UserDefinedFields",
	"verification_state":      "description.Finding.VerificationState",
	"vulnerabilities":         "description.Finding.Vulnerabilities",
	"workflow_state":          "description.Finding.WorkflowState",
	"workflow_status":         "description.Finding.Workflow.Status",
}

func GetSecurityHubFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubFinding")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubFindingPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubFindingFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubFinding =============================

// ==========================  START: SecurityHubFindingAggregator =============================

type SecurityHubFindingAggregator struct {
	Description   aws.SecurityHubFindingAggregatorDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type SecurityHubFindingAggregatorHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SecurityHubFindingAggregator `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SecurityHubFindingAggregatorHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SecurityHubFindingAggregatorHit `json:"hits"`
}

type SecurityHubFindingAggregatorSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SecurityHubFindingAggregatorHits `json:"hits"`
}

type SecurityHubFindingAggregatorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubFindingAggregatorPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubFindingAggregatorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_findingaggregator", filters, limit)
	if err != nil {
		return SecurityHubFindingAggregatorPaginator{}, err
	}

	p := SecurityHubFindingAggregatorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubFindingAggregatorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubFindingAggregatorPaginator) NextPage(ctx context.Context) ([]SecurityHubFindingAggregator, error) {
	var response SecurityHubFindingAggregatorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubFindingAggregator
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubFindingAggregatorFilters = map[string]string{
	"akas":                       "description.FindingAggregator.FindingAggregatorArn",
	"arn":                        "description.FindingAggregator.FindingAggregatorArn",
	"finding_aggregation_region": "description.FindingAggregator.FindingAggregationRegion",
	"kaytu_account_id":           "metadata.SourceID",
	"region_linking_mode":        "description.FindingAggregator.RegionLinkingMode",
	"regions":                    "description.FindingAggregator.Regions",
}

func ListSecurityHubFindingAggregator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubFindingAggregator")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubFindingAggregatorPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubFindingAggregatorFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubFindingAggregatorFilters = map[string]string{
	"akas":                       "description.FindingAggregator.FindingAggregatorArn",
	"arn":                        "description.FindingAggregator.FindingAggregatorArn",
	"finding_aggregation_region": "description.FindingAggregator.FindingAggregationRegion",
	"kaytu_account_id":           "metadata.SourceID",
	"region_linking_mode":        "description.FindingAggregator.RegionLinkingMode",
	"regions":                    "description.FindingAggregator.Regions",
}

func GetSecurityHubFindingAggregator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubFindingAggregator")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubFindingAggregatorPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubFindingAggregatorFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubFindingAggregator =============================

// ==========================  START: SecurityHubInsight =============================

type SecurityHubInsight struct {
	Description   aws.SecurityHubInsightDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SecurityHubInsightHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SecurityHubInsight `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SecurityHubInsightHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SecurityHubInsightHit `json:"hits"`
}

type SecurityHubInsightSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SecurityHubInsightHits `json:"hits"`
}

type SecurityHubInsightPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubInsightPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubInsightPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_insight", filters, limit)
	if err != nil {
		return SecurityHubInsightPaginator{}, err
	}

	p := SecurityHubInsightPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubInsightPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubInsightPaginator) NextPage(ctx context.Context) ([]SecurityHubInsight, error) {
	var response SecurityHubInsightSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubInsight
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubInsightFilters = map[string]string{
	"akas":               "description.Insight.InsightArn",
	"arn":                "description.Insight.InsightArn",
	"filters":            "description.Insight.Filters",
	"group_by_attribute": "description.Insight.GroupByAttribute",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.Insight.Name",
	"title":              "description.Insight.Name",
}

func ListSecurityHubInsight(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubInsight")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubInsightPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubInsightFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubInsightFilters = map[string]string{
	"akas":               "description.Insight.InsightArn",
	"arn":                "description.Insight.InsightArn",
	"filters":            "description.Insight.Filters",
	"group_by_attribute": "description.Insight.GroupByAttribute",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.Insight.Name",
	"title":              "description.Insight.Name",
}

func GetSecurityHubInsight(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubInsight")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubInsightPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubInsightFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubInsight =============================

// ==========================  START: SecurityHubMember =============================

type SecurityHubMember struct {
	Description   aws.SecurityHubMemberDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type SecurityHubMemberHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  SecurityHubMember `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type SecurityHubMemberHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []SecurityHubMemberHit `json:"hits"`
}

type SecurityHubMemberSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  SecurityHubMemberHits `json:"hits"`
}

type SecurityHubMemberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubMemberPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubMemberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_member", filters, limit)
	if err != nil {
		return SecurityHubMemberPaginator{}, err
	}

	p := SecurityHubMemberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubMemberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubMemberPaginator) NextPage(ctx context.Context) ([]SecurityHubMember, error) {
	var response SecurityHubMemberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubMember
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubMemberFilters = map[string]string{
	"administrator_id":  "description.Member.AdministratorId",
	"email":             "description.Member.Email",
	"invited_at":        "description.Member.InvitedAt",
	"kaytu_account_id":  "metadata.SourceID",
	"master_id":         "description.Member.MasterId",
	"member_account_id": "description.Member.AccountId",
	"member_status":     "description.Member.MemberStatus",
	"title":             "description.Member.AccountId",
	"updated_at":        "description.Member.UpdatedAt",
}

func ListSecurityHubMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubMember")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubMemberPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubMemberFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubMemberFilters = map[string]string{
	"administrator_id":  "description.Member.AdministratorId",
	"email":             "description.Member.Email",
	"invited_at":        "description.Member.InvitedAt",
	"kaytu_account_id":  "metadata.SourceID",
	"master_id":         "description.Member.MasterId",
	"member_account_id": "description.Member.AccountId",
	"member_status":     "description.Member.MemberStatus",
	"title":             "description.Member.AccountId",
	"updated_at":        "description.Member.UpdatedAt",
}

func GetSecurityHubMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubMember")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubMemberPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubMemberFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubMember =============================

// ==========================  START: SecurityHubProduct =============================

type SecurityHubProduct struct {
	Description   aws.SecurityHubProductDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SecurityHubProductHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SecurityHubProduct `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SecurityHubProductHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SecurityHubProductHit `json:"hits"`
}

type SecurityHubProductSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SecurityHubProductHits `json:"hits"`
}

type SecurityHubProductPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubProductPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubProductPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_product", filters, limit)
	if err != nil {
		return SecurityHubProductPaginator{}, err
	}

	p := SecurityHubProductPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubProductPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubProductPaginator) NextPage(ctx context.Context) ([]SecurityHubProduct, error) {
	var response SecurityHubProductSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubProduct
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubProductFilters = map[string]string{
	"activation_url":                       "description.Product.ActivationUrl",
	"akas":                                 "description.Product.ProductArn",
	"categories":                           "description.Product.Categories",
	"company_name":                         "description.Product.CompanyName",
	"description":                          "description.Product.Description",
	"integration_types":                    "description.Product.IntegrationTypes",
	"kaytu_account_id":                     "metadata.SourceID",
	"marketplace_url":                      "description.Product.MarketplaceUrl",
	"name":                                 "description.Product.ProductName",
	"product_arn":                          "description.Product.ProductArn",
	"product_subscription_resource_policy": "description.Product.ProductSubscriptionResourcePolicy",
	"title":                                "description.Product.ProductName",
}

func ListSecurityHubProduct(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubProduct")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubProductPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubProductFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubProductFilters = map[string]string{
	"activation_url":                       "description.Product.ActivationUrl",
	"akas":                                 "description.Product.ProductArn",
	"categories":                           "description.Product.Categories",
	"company_name":                         "description.Product.CompanyName",
	"description":                          "description.Product.Description",
	"integration_types":                    "description.Product.IntegrationTypes",
	"kaytu_account_id":                     "metadata.SourceID",
	"marketplace_url":                      "description.Product.MarketplaceUrl",
	"name":                                 "description.Product.ProductName",
	"product_arn":                          "description.Product.ProductArn",
	"product_subscription_resource_policy": "description.Product.ProductSubscriptionResourcePolicy",
	"title":                                "description.Product.ProductName",
}

func GetSecurityHubProduct(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubProduct")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubProductPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubProductFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubProduct =============================

// ==========================  START: SecurityHubStandardsControl =============================

type SecurityHubStandardsControl struct {
	Description   aws.SecurityHubStandardsControlDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type SecurityHubStandardsControlHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  SecurityHubStandardsControl `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type SecurityHubStandardsControlHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []SecurityHubStandardsControlHit `json:"hits"`
}

type SecurityHubStandardsControlSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  SecurityHubStandardsControlHits `json:"hits"`
}

type SecurityHubStandardsControlPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubStandardsControlPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubStandardsControlPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_standardscontrol", filters, limit)
	if err != nil {
		return SecurityHubStandardsControlPaginator{}, err
	}

	p := SecurityHubStandardsControlPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubStandardsControlPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubStandardsControlPaginator) NextPage(ctx context.Context) ([]SecurityHubStandardsControl, error) {
	var response SecurityHubStandardsControlSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubStandardsControl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubStandardsControlFilters = map[string]string{
	"akas":                      "description.StandardsControl.StandardsControlArn",
	"arn":                       "description.StandardsControl.StandardsControlArn",
	"control_id":                "description.StandardsControl.ControlId",
	"control_status":            "description.StandardsControl.ControlStatus",
	"control_status_updated_at": "description.StandardsControl.ControlStatusUpdatedAt",
	"description":               "description.StandardsControl.Description",
	"disabled_reason":           "description.StandardsControl.DisabledReason",
	"kaytu_account_id":          "metadata.SourceID",
	"related_requirements":      "description.StandardsControl.RelatedRequirements",
	"remediation_url":           "description.StandardsControl.RemediationUrl",
	"severity_rating":           "description.StandardsControl.SeverityRating",
	"title":                     "description.StandardsControl.Title",
}

func ListSecurityHubStandardsControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubStandardsControl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubStandardsControlPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubStandardsControlFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubStandardsControlFilters = map[string]string{
	"akas":                      "description.StandardsControl.StandardsControlArn",
	"arn":                       "description.StandardsControl.StandardsControlArn",
	"control_id":                "description.StandardsControl.ControlId",
	"control_status":            "description.StandardsControl.ControlStatus",
	"control_status_updated_at": "description.StandardsControl.ControlStatusUpdatedAt",
	"description":               "description.StandardsControl.Description",
	"disabled_reason":           "description.StandardsControl.DisabledReason",
	"kaytu_account_id":          "metadata.SourceID",
	"related_requirements":      "description.StandardsControl.RelatedRequirements",
	"remediation_url":           "description.StandardsControl.RemediationUrl",
	"severity_rating":           "description.StandardsControl.SeverityRating",
	"title":                     "description.StandardsControl.Title",
}

func GetSecurityHubStandardsControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubStandardsControl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubStandardsControlPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubStandardsControlFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubStandardsControl =============================

// ==========================  START: SecurityHubStandardsSubscription =============================

type SecurityHubStandardsSubscription struct {
	Description   aws.SecurityHubStandardsSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                                    `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type SecurityHubStandardsSubscriptionHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  SecurityHubStandardsSubscription `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type SecurityHubStandardsSubscriptionHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []SecurityHubStandardsSubscriptionHit `json:"hits"`
}

type SecurityHubStandardsSubscriptionSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  SecurityHubStandardsSubscriptionHits `json:"hits"`
}

type SecurityHubStandardsSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubStandardsSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubStandardsSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_standardssubscription", filters, limit)
	if err != nil {
		return SecurityHubStandardsSubscriptionPaginator{}, err
	}

	p := SecurityHubStandardsSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubStandardsSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubStandardsSubscriptionPaginator) NextPage(ctx context.Context) ([]SecurityHubStandardsSubscription, error) {
	var response SecurityHubStandardsSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubStandardsSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubStandardsSubscriptionFilters = map[string]string{
	"akas":                         "description.Standard.StandardsArn",
	"description":                  "description.Standard.Description",
	"enabled_by_default":           "description.Standard.EnabledByDefault",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.Standard.Name",
	"standards_arn":                "description.Standard.StandardsArn",
	"standards_input":              "description.StandardsSubscription.StandardsInput",
	"standards_managed_by":         "description.Standard.StandardsManagedBy",
	"standards_status":             "description.StandardsSubscription.StandardsStatus",
	"standards_status_reason_code": "description.StandardsSubscription.StandardsStatusReason.StatusReasonCode",
	"standards_subscription_arn":   "description.StandardsSubscription.StandardsSubscriptionArn",
	"title":                        "description.Standard.Name",
}

func ListSecurityHubStandardsSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubStandardsSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityHubStandardsSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityHubStandardsSubscriptionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityHubStandardsSubscriptionFilters = map[string]string{
	"akas":                         "description.Standard.StandardsArn",
	"description":                  "description.Standard.Description",
	"enabled_by_default":           "description.Standard.EnabledByDefault",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.Standard.Name",
	"standards_arn":                "description.Standard.StandardsArn",
	"standards_input":              "description.StandardsSubscription.StandardsInput",
	"standards_managed_by":         "description.Standard.StandardsManagedBy",
	"standards_status":             "description.StandardsSubscription.StandardsStatus",
	"standards_status_reason_code": "description.StandardsSubscription.StandardsStatusReason.StatusReasonCode",
	"standards_subscription_arn":   "description.StandardsSubscription.StandardsSubscriptionArn",
	"title":                        "description.Standard.Name",
}

func GetSecurityHubStandardsSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubStandardsSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityHubStandardsSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityHubStandardsSubscriptionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityHubStandardsSubscription =============================

// ==========================  START: SSMManagedInstance =============================

type SSMManagedInstance struct {
	Description   aws.SSMManagedInstanceDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SSMManagedInstanceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SSMManagedInstance `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SSMManagedInstanceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SSMManagedInstanceHit `json:"hits"`
}

type SSMManagedInstanceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SSMManagedInstanceHits `json:"hits"`
}

type SSMManagedInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMManagedInstancePaginator(filters []essdk.BoolFilter, limit *int64) (SSMManagedInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_managedinstance", filters, limit)
	if err != nil {
		return SSMManagedInstancePaginator{}, err
	}

	p := SSMManagedInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMManagedInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMManagedInstancePaginator) NextPage(ctx context.Context) ([]SSMManagedInstance, error) {
	var response SSMManagedInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMManagedInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMManagedInstanceFilters = map[string]string{
	"activation_id":                              "description.InstanceInformation.ActivationId",
	"agent_version":                              "description.InstanceInformation.AgentVersion",
	"association_overview":                       "description.InstanceInformation.AssociationOverview",
	"association_status":                         "description.InstanceInformation.AssociationStatus",
	"computer_name":                              "description.InstanceInformation.ComputerName",
	"instance_id":                                "description.InstanceInformation.InstanceId",
	"ip_address":                                 "description.InstanceInformation.IPAddress",
	"is_latest_version":                          "description.InstanceInformation.IsLatestVersion",
	"kaytu_account_id":                           "metadata.SourceID",
	"last_association_execution_date":            "description.InstanceInformation.LastAssociationExecutionDate",
	"last_ping_date_time":                        "description.InstanceInformation.LastPingDateTime",
	"last_successful_association_execution_date": "description.InstanceInformation.LastSuccessfulAssociationExecutionDate",
	"name":              "description.InstanceInformation.Name",
	"ping_status":       "description.InstanceInformation.PingStatus",
	"platform_name":     "description.InstanceInformation.PlatformName",
	"platform_type":     "description.InstanceInformation.PlatformType",
	"platform_version":  "description.InstanceInformation.PlatformVersion",
	"registration_date": "description.InstanceInformation.RegistrationDate",
	"resource_type":     "description.InstanceInformation.ResourceType",
	"title":             "description.InstanceInformation.InstanceId",
}

func ListSSMManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMManagedInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSSMManagedInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSSMManagedInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSSMManagedInstanceFilters = map[string]string{
	"activation_id":                              "description.InstanceInformation.ActivationId",
	"agent_version":                              "description.InstanceInformation.AgentVersion",
	"association_overview":                       "description.InstanceInformation.AssociationOverview",
	"association_status":                         "description.InstanceInformation.AssociationStatus",
	"computer_name":                              "description.InstanceInformation.ComputerName",
	"instance_id":                                "description.InstanceInformation.InstanceId",
	"ip_address":                                 "description.InstanceInformation.IPAddress",
	"is_latest_version":                          "description.InstanceInformation.IsLatestVersion",
	"kaytu_account_id":                           "metadata.SourceID",
	"last_association_execution_date":            "description.InstanceInformation.LastAssociationExecutionDate",
	"last_ping_date_time":                        "description.InstanceInformation.LastPingDateTime",
	"last_successful_association_execution_date": "description.InstanceInformation.LastSuccessfulAssociationExecutionDate",
	"name":              "description.InstanceInformation.Name",
	"ping_status":       "description.InstanceInformation.PingStatus",
	"platform_name":     "description.InstanceInformation.PlatformName",
	"platform_type":     "description.InstanceInformation.PlatformType",
	"platform_version":  "description.InstanceInformation.PlatformVersion",
	"registration_date": "description.InstanceInformation.RegistrationDate",
	"resource_type":     "description.InstanceInformation.ResourceType",
	"title":             "description.InstanceInformation.InstanceId",
}

func GetSSMManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMManagedInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSSMManagedInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSSMManagedInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SSMManagedInstance =============================

// ==========================  START: SSMAssociation =============================

type SSMAssociation struct {
	Description   aws.SSMAssociationDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type SSMAssociationHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SSMAssociation `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SSMAssociationHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SSMAssociationHit `json:"hits"`
}

type SSMAssociationSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SSMAssociationHits `json:"hits"`
}

type SSMAssociationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMAssociationPaginator(filters []essdk.BoolFilter, limit *int64) (SSMAssociationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_association", filters, limit)
	if err != nil {
		return SSMAssociationPaginator{}, err
	}

	p := SSMAssociationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMAssociationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMAssociationPaginator) NextPage(ctx context.Context) ([]SSMAssociation, error) {
	var response SSMAssociationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMAssociation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMAssociationFilters = map[string]string{
	"apply_only_at_cron_interval":      "description.Association.AssociationDescription.ApplyOnlyAtCronInterval",
	"association_id":                   "description.AssociationItem.AssociationId",
	"association_name":                 "description.AssociationItem.AssociationName",
	"association_version":              "description.AssociationItem.AssociationVersion",
	"automation_target_parameter_name": "description.Association.AssociationDescription.AutomationTargetParameterName",
	"compliance_severity":              "description.Association.AssociationDescription.ComplianceSeverity",
	"date":                             "description.AssociationItem.LastExecutionDate",
	"document_name":                    "description.AssociationItem.Name",
	"document_version":                 "description.AssociationItem.DocumentVersion",
	"instance_id":                      "description.AssociationItem.InstanceId",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_execution_date":              "description.Association.AssociationDescription.LastExecutionDate",
	"last_successful_execution_date":   "description.Association.AssociationDescription.LastSuccessfulExecutionDate",
	"last_update_association_date":     "description.Association.AssociationDescription.LastUpdateAssociationDate",
	"max_concurrency":                  "description.Association.AssociationDescription.MaxConcurrency",
	"max_errors":                       "description.Association.AssociationDescription.MaxErrors",
	"output_location":                  "description.Association.AssociationDescription.OutputLocation",
	"overview":                         "description.AssociationItem.Overview",
	"parameters":                       "description.Association.AssociationDescription.Parameters",
	"schedule_expression":              "description.AssociationItem.ScheduleExpression",
	"status":                           "description.Association.AssociationDescription.Status",
	"sync_compliance":                  "description.Association.AssociationDescription.SyncCompliance",
	"target_locations":                 "description.Association.AssociationDescription.TargetLocations",
	"targets":                          "description.AssociationItem.Targets",
	"title":                            "description.AssociationItem.Name",
}

func ListSSMAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMAssociation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSSMAssociationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSSMAssociationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSSMAssociationFilters = map[string]string{
	"apply_only_at_cron_interval":      "description.Association.AssociationDescription.ApplyOnlyAtCronInterval",
	"association_id":                   "description.AssociationItem.AssociationId",
	"association_name":                 "description.AssociationItem.AssociationName",
	"association_version":              "description.AssociationItem.AssociationVersion",
	"automation_target_parameter_name": "description.Association.AssociationDescription.AutomationTargetParameterName",
	"compliance_severity":              "description.Association.AssociationDescription.ComplianceSeverity",
	"date":                             "description.AssociationItem.LastExecutionDate",
	"document_name":                    "description.AssociationItem.Name",
	"document_version":                 "description.AssociationItem.DocumentVersion",
	"instance_id":                      "description.AssociationItem.InstanceId",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_execution_date":              "description.AssociationItem.LastExecutionDate",
	"last_successful_execution_date":   "description.Association.AssociationDescription.LastSuccessfulExecutionDate",
	"last_update_association_date":     "description.Association.AssociationDescription.LastUpdateAssociationDate",
	"max_concurrency":                  "description.Association.AssociationDescription.MaxConcurrency",
	"max_errors":                       "description.Association.AssociationDescription.MaxErrors",
	"output_location":                  "description.Association.AssociationDescription.OutputLocation",
	"overview":                         "description.AssociationItem.Overview",
	"parameters":                       "description.Association.AssociationDescription.Parameters",
	"schedule_expression":              "description.AssociationItem.ScheduleExpression",
	"status":                           "description.AssociationItem.Overview.Status",
	"sync_compliance":                  "description.Association.AssociationDescription.SyncCompliance",
	"target_locations":                 "description.Association.AssociationDescription.TargetLocations",
	"targets":                          "description.AssociationItem.Targets",
	"title":                            "description.AssociationItem.Name",
}

func GetSSMAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMAssociation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSSMAssociationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSSMAssociationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SSMAssociation =============================

// ==========================  START: SSMDocument =============================

type SSMDocument struct {
	Description   aws.SSMDocumentDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type SSMDocumentHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SSMDocument   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SSMDocumentHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SSMDocumentHit  `json:"hits"`
}

type SSMDocumentSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SSMDocumentHits `json:"hits"`
}

type SSMDocumentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMDocumentPaginator(filters []essdk.BoolFilter, limit *int64) (SSMDocumentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_document", filters, limit)
	if err != nil {
		return SSMDocumentPaginator{}, err
	}

	p := SSMDocumentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMDocumentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMDocumentPaginator) NextPage(ctx context.Context) ([]SSMDocument, error) {
	var response SSMDocumentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMDocument
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMDocumentFilters = map[string]string{
	"account_ids":               "description.Permissions.AccountIds",
	"account_sharing_info_list": "description.Permissions.AccountSharingInfoList",
	"akas":                      "description.Document.Document.Parameters",
	"approved_version":          "description.Document.Document.ApprovedVersion",
	"attachments_information":   "description.Document.Document.AttachmentsInformation",
	"author":                    "description.Document.Document.Author",
	"created_date":              "description.Document.Document.CreatedDate",
	"default_version":           "description.Document.Document.DefaultVersion",
	"description":               "description.Document.Document.Description",
	"document_format":           "description.DocumentIdentifier.DocumentFormat",
	"document_type":             "description.DocumentIdentifier.DocumentType",
	"document_version":          "description.DocumentIdentifier.DocumentVersion",
	"hash":                      "description.Document.Document.Hash",
	"hash_type":                 "description.Document.Document.HashType",
	"kaytu_account_id":          "metadata.SourceID",
	"latest_version":            "description.Document.Document.LatestVersion",
	"name":                      "description.Document.Document.Name",
	"owner":                     "description.Document.Document.Owner",
	"owner_type":                "description.DocumentIdentifier.Owner",
	"parameters":                "description.Document.Document.Parameters",
	"pending_review_version":    "description.Document.Document.PendingReviewVersion",
	"platform_types":            "description.Document.Document.PlatformTypes",
	"requires":                  "description.DocumentIdentifier.Requires",
	"review_information":        "description.Document.Document.ReviewInformation",
	"review_status":             "description.DocumentIdentifier.ReviewStatus",
	"schema_version":            "description.Document.Document.SchemaVersion",
	"sha1":                      "description.Document.Document.Sha1",
	"status":                    "description.Document.Document.Status",
	"status_information":        "description.Document.Document.StatusInformation",
	"tags":                      "description.Document.Document.Tags",
	"tags_src":                  "description.Document.Document.Tags",
	"target_type":               "description.Document.Document.TargetType",
	"title":                     "description.Document.Document.Name",
	"version_name":              "description.Document.Document.VersionName",
}

func ListSSMDocument(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMDocument")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSSMDocumentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSSMDocumentFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSSMDocumentFilters = map[string]string{
	"account_ids":               "description.Permissions.AccountIds",
	"account_sharing_info_list": "description.Permissions.AccountSharingInfoList",
	"akas":                      "description.Document.Document.Parameters",
	"approved_version":          "description.Document.Document.ApprovedVersion",
	"attachments_information":   "description.Document.Document.AttachmentsInformation",
	"author":                    "description.Document.Document.Author",
	"created_date":              "description.Document.Document.CreatedDate",
	"default_version":           "description.Document.Document.DefaultVersion",
	"description":               "description.Document.Document.Description",
	"document_format":           "description.DocumentIdentifier.DocumentFormat",
	"document_type":             "description.Document.Document.DocumentType",
	"document_version":          "description.DocumentIdentifier.DocumentVersion",
	"hash":                      "description.Document.Document.Hash",
	"hash_type":                 "description.Document.Document.HashType",
	"kaytu_account_id":          "metadata.SourceID",
	"latest_version":            "description.Document.Document.LatestVersion",
	"name":                      "description.DocumentIdentifier.Name",
	"owner":                     "description.Document.Document.Owner",
	"parameters":                "description.Document.Document.Parameters",
	"pending_review_version":    "description.Document.Document.PendingReviewVersion",
	"platform_types":            "description.Document.Document.PlatformTypes",
	"requires":                  "description.DocumentIdentifier.Requires",
	"review_information":        "description.Document.Document.ReviewInformation",
	"review_status":             "description.DocumentIdentifier.ReviewStatus",
	"schema_version":            "description.Document.Document.SchemaVersion",
	"sha1":                      "description.Document.Document.Sha1",
	"status":                    "description.Document.Document.Status",
	"status_information":        "description.Document.Document.StatusInformation",
	"tags":                      "description.Document.Document.Tags",
	"tags_src":                  "description.Document.Document.Tags",
	"target_type":               "description.Document.Document.TargetType",
	"title":                     "description.Document.Document.Name",
	"version_name":              "description.Document.Document.VersionName",
}

func GetSSMDocument(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMDocument")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSSMDocumentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSSMDocumentFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SSMDocument =============================

// ==========================  START: SSMInventory =============================

type SSMInventory struct {
	Description   aws.SSMInventoryDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type SSMInventoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SSMInventory  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SSMInventoryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SSMInventoryHit `json:"hits"`
}

type SSMInventorySearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SSMInventoryHits `json:"hits"`
}

type SSMInventoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMInventoryPaginator(filters []essdk.BoolFilter, limit *int64) (SSMInventoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_inventory", filters, limit)
	if err != nil {
		return SSMInventoryPaginator{}, err
	}

	p := SSMInventoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMInventoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMInventoryPaginator) NextPage(ctx context.Context) ([]SSMInventory, error) {
	var response SSMInventorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMInventory
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMInventoryFilters = map[string]string{
	"capture_time":     "description.CaptureTime",
	"content":          "description.Content",
	"id":               "description.Id",
	"kaytu_account_id": "metadata.SourceID",
	"schema":           "description.Schemas",
	"schema_version":   "description.SchemaVersion",
	"title":            "description.Id",
	"type_name":        "description.TypeName",
}

func ListSSMInventory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMInventory")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSSMInventoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSSMInventoryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSSMInventoryFilters = map[string]string{
	"capture_time":     "description.CaptureTime",
	"content":          "description.Content",
	"id":               "description.Id",
	"kaytu_account_id": "metadata.SourceID",
	"schema":           "description.Schemas",
	"schema_version":   "description.SchemaVersion",
	"title":            "description.Id",
	"type_name":        "description.TypeName",
}

func GetSSMInventory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMInventory")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSSMInventoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSSMInventoryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SSMInventory =============================

// ==========================  START: SSMMaintenanceWindow =============================

type SSMMaintenanceWindow struct {
	Description   aws.SSMMaintenanceWindowDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SSMMaintenanceWindowHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SSMMaintenanceWindow `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SSMMaintenanceWindowHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SSMMaintenanceWindowHit `json:"hits"`
}

type SSMMaintenanceWindowSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SSMMaintenanceWindowHits `json:"hits"`
}

type SSMMaintenanceWindowPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMMaintenanceWindowPaginator(filters []essdk.BoolFilter, limit *int64) (SSMMaintenanceWindowPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_maintenancewindow", filters, limit)
	if err != nil {
		return SSMMaintenanceWindowPaginator{}, err
	}

	p := SSMMaintenanceWindowPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMMaintenanceWindowPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMMaintenanceWindowPaginator) NextPage(ctx context.Context) ([]SSMMaintenanceWindow, error) {
	var response SSMMaintenanceWindowSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMMaintenanceWindow
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMMaintenanceWindowFilters = map[string]string{
	"akas":                       "description.ARN",
	"allow_unassociated_targets": "description.MaintenanceWindow.AllowUnassociatedTargets",
	"created_date":               "description.MaintenanceWindow.CreatedDate",
	"cutoff":                     "description.MaintenanceWindow.Cutoff",
	"description":                "description.MaintenanceWindow.Description",
	"duration":                   "description.MaintenanceWindow.Duration",
	"enabled":                    "description.MaintenanceWindowIdentity.Enabled",
	"end_date":                   "description.MaintenanceWindow.EndDate",
	"kaytu_account_id":           "metadata.SourceID",
	"modified_date":              "description.MaintenanceWindow.ModifiedDate",
	"name":                       "description.MaintenanceWindowIdentity.Name",
	"next_execution_time":        "description.MaintenanceWindow.NextExecutionTime",
	"schedule":                   "description.MaintenanceWindow.Schedule",
	"schedule_offset":            "description.MaintenanceWindow.ScheduleOffset",
	"schedule_timezone":          "description.MaintenanceWindow.ScheduleTimezone",
	"start_date":                 "description.MaintenanceWindow.StartDate",
	"tags":                       "description.Tags",
	"tags_src":                   "description.Tags",
	"targets":                    "description.Targets",
	"tasks":                      "description.Tasks",
	"title":                      "description.MaintenanceWindow.Name",
	"window_id":                  "description.MaintenanceWindowIdentity.WindowId",
}

func ListSSMMaintenanceWindow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMMaintenanceWindow")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSSMMaintenanceWindowPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSSMMaintenanceWindowFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSSMMaintenanceWindowFilters = map[string]string{
	"akas":                       "description.ARN",
	"allow_unassociated_targets": "description.MaintenanceWindow.AllowUnassociatedTargets",
	"created_date":               "description.MaintenanceWindow.CreatedDate",
	"cutoff":                     "description.MaintenanceWindow.Cutoff",
	"description":                "description.MaintenanceWindow.Description",
	"duration":                   "description.MaintenanceWindow.Duration",
	"enabled":                    "description.MaintenanceWindow.Enabled",
	"end_date":                   "description.MaintenanceWindow.EndDate",
	"kaytu_account_id":           "metadata.SourceID",
	"modified_date":              "description.MaintenanceWindow.ModifiedDate",
	"name":                       "description.MaintenanceWindow.Name",
	"next_execution_time":        "description.MaintenanceWindow.NextExecutionTime",
	"schedule":                   "description.MaintenanceWindow.Schedule",
	"schedule_offset":            "description.MaintenanceWindow.ScheduleOffset",
	"schedule_timezone":          "description.MaintenanceWindow.ScheduleTimezone",
	"start_date":                 "description.MaintenanceWindow.StartDate",
	"tags":                       "description.Tags",
	"tags_src":                   "description.Tags",
	"targets":                    "description.Targets",
	"tasks":                      "description.Tasks",
	"title":                      "description.MaintenanceWindow.Name",
	"window_id":                  "description.MaintenanceWindowIdentity.WindowId",
}

func GetSSMMaintenanceWindow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMMaintenanceWindow")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSSMMaintenanceWindowPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSSMMaintenanceWindowFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SSMMaintenanceWindow =============================

// ==========================  START: SSMParameter =============================

type SSMParameter struct {
	Description   aws.SSMParameterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type SSMParameterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SSMParameter  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SSMParameterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SSMParameterHit `json:"hits"`
}

type SSMParameterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SSMParameterHits `json:"hits"`
}

type SSMParameterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMParameterPaginator(filters []essdk.BoolFilter, limit *int64) (SSMParameterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_parameter", filters, limit)
	if err != nil {
		return SSMParameterPaginator{}, err
	}

	p := SSMParameterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMParameterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMParameterPaginator) NextPage(ctx context.Context) ([]SSMParameter, error) {
	var response SSMParameterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMParameter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMParameterFilters = map[string]string{
	"akas":               "description.Parameter.ARN",
	"arn":                "description.Parameter.ARN",
	"data_type":          "description.ParameterMetadata.DataType",
	"kaytu_account_id":   "metadata.SourceID",
	"key_id":             "description.ParameterMetadata.KeyId",
	"last_modified_date": "description.Parameter.LastModifiedDate",
	"last_modified_user": "description.ParameterMetadata.LastModifiedUser",
	"name":               "description.Parameter.Name",
	"policies":           "description.ParameterMetadata.Policies",
	"selector":           "description.Parameter.Selector",
	"source_result":      "description.Parameter.SourceResult",
	"tags":               "description.Tags",
	"tags_src":           "description.Tags",
	"tier":               "description.ParameterMetadata.Tier",
	"title":              "description.Parameter.Name",
	"type":               "description.ParameterMetadata.Type",
	"value":              "description.Parameter.Value",
	"version":            "description.Parameter.Version",
}

func ListSSMParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMParameter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSSMParameterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSSMParameterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSSMParameterFilters = map[string]string{
	"akas":               "description.Parameter.ARN",
	"arn":                "description.Parameter.ARN",
	"data_type":          "description.Parameter.DataType",
	"kaytu_account_id":   "metadata.SourceID",
	"key_id":             "description.ParameterMetadata.KeyId",
	"last_modified_date": "description.Parameter.LastModifiedDate",
	"last_modified_user": "description.ParameterMetadata.LastModifiedUser",
	"name":               "description.ParameterMetadata.Name",
	"policies":           "description.ParameterMetadata.Policies",
	"selector":           "description.Parameter.Selector",
	"source_result":      "description.Parameter.SourceResult",
	"tags":               "description.Tags",
	"tags_src":           "description.Tags",
	"tier":               "description.ParameterMetadata.Tier",
	"title":              "description.Parameter.Name",
	"type":               "description.Parameter.Type",
	"value":              "description.Parameter.Value",
	"version":            "description.Parameter.Version",
}

func GetSSMParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMParameter")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSSMParameterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSSMParameterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SSMParameter =============================

// ==========================  START: SSMPatchBaseline =============================

type SSMPatchBaseline struct {
	Description   aws.SSMPatchBaselineDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type SSMPatchBaselineHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  SSMPatchBaseline `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type SSMPatchBaselineHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []SSMPatchBaselineHit `json:"hits"`
}

type SSMPatchBaselineSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  SSMPatchBaselineHits `json:"hits"`
}

type SSMPatchBaselinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMPatchBaselinePaginator(filters []essdk.BoolFilter, limit *int64) (SSMPatchBaselinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_patchbaseline", filters, limit)
	if err != nil {
		return SSMPatchBaselinePaginator{}, err
	}

	p := SSMPatchBaselinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMPatchBaselinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMPatchBaselinePaginator) NextPage(ctx context.Context) ([]SSMPatchBaseline, error) {
	var response SSMPatchBaselineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMPatchBaseline
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMPatchBaselineFilters = map[string]string{
	"akas":                                 "description.ARN",
	"approval_rules":                       "description.PatchBaseline.ApprovalRules",
	"approved_patches":                     "description.PatchBaseline.ApprovedPatches",
	"approved_patches_compliance_level":    "description.PatchBaseline.ApprovedPatchesComplianceLevel",
	"approved_patches_enable_non_security": "description.PatchBaseline.ApprovedPatchesEnableNonSecurity",
	"baseline_id":                          "description.PatchBaseline.BaselineId",
	"created_date":                         "description.PatchBaseline.CreatedDate",
	"description":                          "description.PatchBaseline.Description",
	"global_filters":                       "description.PatchBaseline.GlobalFilters",
	"kaytu_account_id":                     "metadata.SourceID",
	"modified_date":                        "description.PatchBaseline.ModifiedDate",
	"name":                                 "description.ParameterMetadata.Type",
	"operating_system":                     "description.ParameterMetadata.KeyId",
	"patch_groups":                         "description.PatchBaseline.PatchGroups",
	"rejected_patches":                     "description.PatchBaseline.RejectedPatches",
	"rejected_patches_action":              "description.PatchBaseline.RejectedPatchesAction",
	"sources":                              "description.PatchBaseline.Sources",
	"tags":                                 "description.Tags",
	"tags_src":                             "description.Tags",
	"title":                                "description.PatchBaselineIdentity.BaselineName",
}

func ListSSMPatchBaseline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMPatchBaseline")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSSMPatchBaselinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSSMPatchBaselineFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSSMPatchBaselineFilters = map[string]string{
	"akas":                                 "description.ARN",
	"approval_rules":                       "description.PatchBaseline.ApprovalRules",
	"approved_patches":                     "description.PatchBaseline.ApprovedPatches",
	"approved_patches_compliance_level":    "description.PatchBaseline.ApprovedPatchesComplianceLevel",
	"approved_patches_enable_non_security": "description.PatchBaseline.ApprovedPatchesEnableNonSecurity",
	"baseline_id":                          "description.ParameterMetadata.Name",
	"created_date":                         "description.PatchBaseline.CreatedDate",
	"description":                          "description.PatchBaseline.Description",
	"global_filters":                       "description.PatchBaseline.GlobalFilters",
	"kaytu_account_id":                     "metadata.SourceID",
	"modified_date":                        "description.PatchBaseline.ModifiedDate",
	"name":                                 "description.PatchBaselineIdentity.BaselineName",
	"operating_system":                     "description.PatchBaseline.OperatingSystem",
	"patch_groups":                         "description.PatchBaseline.PatchGroups",
	"rejected_patches":                     "description.PatchBaseline.RejectedPatches",
	"rejected_patches_action":              "description.PatchBaseline.RejectedPatchesAction",
	"sources":                              "description.PatchBaseline.Sources",
	"tags":                                 "description.Tags",
	"tags_src":                             "description.Tags",
	"title":                                "description.PatchBaselineIdentity.BaselineName",
}

func GetSSMPatchBaseline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMPatchBaseline")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSSMPatchBaselinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSSMPatchBaselineFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SSMPatchBaseline =============================

// ==========================  START: ECSTaskDefinition =============================

type ECSTaskDefinition struct {
	Description   aws.ECSTaskDefinitionDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ECSTaskDefinitionHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ECSTaskDefinition `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ECSTaskDefinitionHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ECSTaskDefinitionHit `json:"hits"`
}

type ECSTaskDefinitionSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ECSTaskDefinitionHits `json:"hits"`
}

type ECSTaskDefinitionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSTaskDefinitionPaginator(filters []essdk.BoolFilter, limit *int64) (ECSTaskDefinitionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_taskdefinition", filters, limit)
	if err != nil {
		return ECSTaskDefinitionPaginator{}, err
	}

	p := ECSTaskDefinitionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSTaskDefinitionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSTaskDefinitionPaginator) NextPage(ctx context.Context) ([]ECSTaskDefinition, error) {
	var response ECSTaskDefinitionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSTaskDefinition
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSTaskDefinitionFilters = map[string]string{
	"akas":                     "description.TaskDefinition.TaskDefinitionArn",
	"compatibilities":          "description.TaskDefinition.Compatibilities",
	"container_definitions":    "description.TaskDefinition.ContainerDefinitions",
	"cpu":                      "taskDefinition.Cpu",
	"execution_role_arn":       "description.TaskDefinition.ExecutionRoleArn",
	"family":                   "description.TaskDefinition.Family",
	"inference_accelerators":   "description.TaskDefinition.InferenceAccelerators",
	"ipc_mode":                 "description.TaskDefinition.IpcMode",
	"kaytu_account_id":         "metadata.SourceID",
	"memory":                   "description.TaskDefinition.Memory",
	"network_mode":             "description.TaskDefinition.NetworkMode",
	"pid_mode":                 "description.TaskDefinition.PidMode",
	"placement_constraints":    "description.TaskDefinition.PlacementConstraints",
	"proxy_configuration":      "description.TaskDefinition.ProxyConfiguration",
	"registered_at":            "description.TaskDefinition.RegisteredAt",
	"registered_by":            "description.TaskDefinition.RegisteredBy",
	"requires_attributes":      "description.TaskDefinition.RequiresAttributes",
	"requires_compatibilities": "description.TaskDefinition.RequiresCompatibilities",
	"revision":                 "description.TaskDefinition.Revision",
	"status":                   "description.TaskDefinition.Status",
	"tags_src":                 "description.Tags",
	"task_definition_arn":      "description.TaskDefinition.TaskDefinitionArn",
	"task_role_arn":            "description.TaskDefinition.TaskRoleArn",
	"volumes":                  "description.TaskDefinition.Volumes",
}

func ListECSTaskDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSTaskDefinition")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECSTaskDefinitionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listECSTaskDefinitionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECSTaskDefinitionFilters = map[string]string{
	"akas":                     "description.TaskDefinition.TaskDefinitionArn",
	"compatibilities":          "description.TaskDefinition.Compatibilities",
	"container_definitions":    "description.TaskDefinition.ContainerDefinitions",
	"cpu":                      "taskDefinition.Cpu",
	"execution_role_arn":       "description.TaskDefinition.ExecutionRoleArn",
	"family":                   "description.TaskDefinition.Family",
	"inference_accelerators":   "description.TaskDefinition.InferenceAccelerators",
	"ipc_mode":                 "description.TaskDefinition.IpcMode",
	"kaytu_account_id":         "metadata.SourceID",
	"memory":                   "description.TaskDefinition.Memory",
	"network_mode":             "description.TaskDefinition.NetworkMode",
	"pid_mode":                 "description.TaskDefinition.PidMode",
	"placement_constraints":    "description.TaskDefinition.PlacementConstraints",
	"proxy_configuration":      "description.TaskDefinition.ProxyConfiguration",
	"registered_at":            "description.TaskDefinition.RegisteredAt",
	"registered_by":            "description.TaskDefinition.RegisteredBy",
	"requires_attributes":      "description.TaskDefinition.RequiresAttributes",
	"requires_compatibilities": "description.TaskDefinition.RequiresCompatibilities",
	"revision":                 "description.TaskDefinition.Revision",
	"status":                   "description.TaskDefinition.Status",
	"tags_src":                 "description.Tags",
	"task_definition_arn":      "description.TaskDefinition.TaskDefinitionArn",
	"task_role_arn":            "description.TaskDefinition.TaskRoleArn",
	"volumes":                  "description.TaskDefinition.Volumes",
}

func GetECSTaskDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSTaskDefinition")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECSTaskDefinitionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getECSTaskDefinitionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECSTaskDefinition =============================

// ==========================  START: ECSCluster =============================

type ECSCluster struct {
	Description   aws.ECSClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ECSClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSClusterHit   `json:"hits"`
}

type ECSClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ECSClusterHits `json:"hits"`
}

type ECSClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSClusterPaginator(filters []essdk.BoolFilter, limit *int64) (ECSClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_cluster", filters, limit)
	if err != nil {
		return ECSClusterPaginator{}, err
	}

	p := ECSClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSClusterPaginator) NextPage(ctx context.Context) ([]ECSCluster, error) {
	var response ECSClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSClusterFilters = map[string]string{
	"active_services_count":                "description.Cluster.ActiveServicesCount",
	"akas":                                 "description.Cluster.ClusterArn",
	"attachments":                          "description.Cluster.Attachments",
	"attachments_status":                   "description.Cluster.AttachmentsStatus",
	"capacity_providers":                   "description.Cluster.CapacityProviders",
	"cluster_arn":                          "description.Cluster.ClusterArn",
	"cluster_name":                         "description.Cluster.ClusterName",
	"default_capacity_provider_strategy":   "description.Cluster.DefaultCapacityProviderStrategy",
	"kaytu_account_id":                     "metadata.SourceID",
	"pending_tasks_count":                  "description.Cluster.PendingTasksCount",
	"registered_container_instances_count": "description.Cluster.RegisteredContainerInstancesCount",
	"running_tasks_count":                  "description.Cluster.RunningTasksCount",
	"settings":                             "description.Cluster.Settings",
	"statistics":                           "description.Cluster.Statistics",
	"status":                               "description.Cluster.Status",
	"tags":                                 "description.Cluster.Tags",
	"tags_src":                             "description.Cluster.Tags",
	"title":                                "description.Cluster.ClusterName",
}

func ListECSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECSClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listECSClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECSClusterFilters = map[string]string{
	"active_services_count":                "description.Cluster.ActiveServicesCount",
	"akas":                                 "description.Cluster.ClusterArn",
	"attachments":                          "description.Cluster.Attachments",
	"attachments_status":                   "description.Cluster.AttachmentsStatus",
	"capacity_providers":                   "description.Cluster.CapacityProviders",
	"cluster_arn":                          "description.Cluster.ClusterArn",
	"cluster_name":                         "description.Cluster.ClusterName",
	"default_capacity_provider_strategy":   "description.Cluster.DefaultCapacityProviderStrategy",
	"kaytu_account_id":                     "metadata.SourceID",
	"pending_tasks_count":                  "description.Cluster.PendingTasksCount",
	"registered_container_instances_count": "description.Cluster.RegisteredContainerInstancesCount",
	"running_tasks_count":                  "description.Cluster.RunningTasksCount",
	"settings":                             "description.Cluster.Settings",
	"statistics":                           "description.Cluster.Statistics",
	"status":                               "description.Cluster.Status",
	"tags":                                 "description.Cluster.Tags",
	"tags_src":                             "description.Cluster.Tags",
	"title":                                "description.Cluster.ClusterName",
}

func GetECSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECSClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getECSClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECSCluster =============================

// ==========================  START: ECSService =============================

type ECSService struct {
	Description   aws.ECSServiceDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ECSServiceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSService    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSServiceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSServiceHit   `json:"hits"`
}

type ECSServiceSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ECSServiceHits `json:"hits"`
}

type ECSServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSServicePaginator(filters []essdk.BoolFilter, limit *int64) (ECSServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_service", filters, limit)
	if err != nil {
		return ECSServicePaginator{}, err
	}

	p := ECSServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSServicePaginator) NextPage(ctx context.Context) ([]ECSService, error) {
	var response ECSServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSServiceFilters = map[string]string{
	"akas":                              "description.Service.ServiceArn",
	"arn":                               "description.Service.ServiceArn",
	"capacity_provider_strategy":        "description.Service.CapacityProviderStrategy",
	"cluster_arn":                       "description.Service.ClusterArn",
	"created_at":                        "description.Service.CreatedAt",
	"created_by":                        "description.Service.CreatedBy",
	"deployment_configuration":          "description.Service.DeploymentConfiguration",
	"deployment_controller_type":        "description.Service.DeploymentController.Type",
	"deployments":                       "description.Service.Deployments",
	"desired_count":                     "description.Service.DesiredCount",
	"enable_ecs_managed_tags":           "description.Service.EnableECSManagedTags",
	"enable_execute_command":            "description.Service.EnableExecuteCommand",
	"events":                            "description.Service.Events",
	"health_check_grace_period_seconds": "description.Service.HealthCheckGracePeriodSeconds",
	"kaytu_account_id":                  "metadata.SourceID",
	"launch_type":                       "description.Service.LaunchType",
	"load_balancers":                    "description.Service.LoadBalancers",
	"network_configuration":             "description.Service.NetworkConfiguration",
	"pending_count":                     "description.Service.PendingCount",
	"placement_constraints":             "description.Service.PlacementConstraints",
	"placement_strategy":                "description.Service.PlacementStrategy",
	"platform_version":                  "description.Service.PlatformVersion",
	"propagate_tags":                    "description.Service.PropagateTags",
	"role_arn":                          "description.Service.RoleArn",
	"running_count":                     "description.Service.RunningCount",
	"scheduling_strategy":               "description.Service.SchedulingStrategy",
	"service_name":                      "description.Service.ServiceName",
	"service_registries":                "description.Service.ServiceRegistries",
	"status":                            "description.Service.Status",
	"tags_src":                          "description.Service.Tags",
	"task_definition":                   "description.Service.TaskDefinition",
	"task_sets":                         "description.Service.TaskSets",
	"title":                             "description.Service.ServiceName",
}

func ListECSService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECSServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listECSServiceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECSServiceFilters = map[string]string{
	"akas":                              "description.Service.ServiceArn",
	"arn":                               "description.Service.ServiceArn",
	"capacity_provider_strategy":        "description.Service.CapacityProviderStrategy",
	"cluster_arn":                       "description.Service.ClusterArn",
	"created_at":                        "description.Service.CreatedAt",
	"created_by":                        "description.Service.CreatedBy",
	"deployment_configuration":          "description.Service.DeploymentConfiguration",
	"deployment_controller_type":        "description.Service.DeploymentController.Type",
	"deployments":                       "description.Service.Deployments",
	"desired_count":                     "description.Service.DesiredCount",
	"enable_ecs_managed_tags":           "description.Service.EnableECSManagedTags",
	"enable_execute_command":            "description.Service.EnableExecuteCommand",
	"events":                            "description.Service.Events",
	"health_check_grace_period_seconds": "description.Service.HealthCheckGracePeriodSeconds",
	"kaytu_account_id":                  "metadata.SourceID",
	"launch_type":                       "description.Service.LaunchType",
	"load_balancers":                    "description.Service.LoadBalancers",
	"network_configuration":             "description.Service.NetworkConfiguration",
	"pending_count":                     "description.Service.PendingCount",
	"placement_constraints":             "description.Service.PlacementConstraints",
	"placement_strategy":                "description.Service.PlacementStrategy",
	"platform_version":                  "description.Service.PlatformVersion",
	"propagate_tags":                    "description.Service.PropagateTags",
	"role_arn":                          "description.Service.RoleArn",
	"running_count":                     "description.Service.RunningCount",
	"scheduling_strategy":               "description.Service.SchedulingStrategy",
	"service_name":                      "description.Service.ServiceName",
	"service_registries":                "description.Service.ServiceRegistries",
	"status":                            "description.Service.Status",
	"tags_src":                          "description.Service.Tags",
	"task_definition":                   "description.Service.TaskDefinition",
	"task_sets":                         "description.Service.TaskSets",
	"title":                             "description.Service.ServiceName",
}

func GetECSService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECSServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getECSServiceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECSService =============================

// ==========================  START: ECSContainerInstance =============================

type ECSContainerInstance struct {
	Description   aws.ECSContainerInstanceDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ECSContainerInstanceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ECSContainerInstance `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ECSContainerInstanceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ECSContainerInstanceHit `json:"hits"`
}

type ECSContainerInstanceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ECSContainerInstanceHits `json:"hits"`
}

type ECSContainerInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSContainerInstancePaginator(filters []essdk.BoolFilter, limit *int64) (ECSContainerInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_containerinstance", filters, limit)
	if err != nil {
		return ECSContainerInstancePaginator{}, err
	}

	p := ECSContainerInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSContainerInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSContainerInstancePaginator) NextPage(ctx context.Context) ([]ECSContainerInstance, error) {
	var response ECSContainerInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSContainerInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSContainerInstanceFilters = map[string]string{
	"agent_connected":        "description.ContainerInstance.AgentConnected",
	"agent_update_status":    "description.ContainerInstance.AgentUpdateStatus",
	"akas":                   "description.ContainerInstance.ContainerInstanceArn",
	"arn":                    "description.ContainerInstance.ContainerInstanceArn",
	"attachments":            "description.ContainerInstance.Attachments",
	"attributes":             "description.ContainerInstance.Attributes",
	"capacity_provider_name": "description.ContainerInstance.CapacityProviderName",
	"ec2_instance_id":        "description.ContainerInstance.Ec2InstanceId",
	"kaytu_account_id":       "metadata.SourceID",
	"pending_tasks_count":    "description.ContainerInstance.PendingTasksCount",
	"registered_at":          "description.ContainerInstance.RegisteredAt",
	"registered_resources":   "description.ContainerInstance.RegisteredResources",
	"remaining_resources":    "description.ContainerInstance.RemainingResources",
	"running_tasks_count":    "description.ContainerInstance.RunningTasksCount",
	"status":                 "description.ContainerInstance.Status",
	"status_reason":          "description.ContainerInstance.StatusReason",
	"title":                  "description.ContainerInstance.ContainerInstanceArn",
	"version":                "description.ContainerInstance.Version",
	"version_info":           "description.ContainerInstance.VersionInfo",
}

func ListECSContainerInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSContainerInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECSContainerInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listECSContainerInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECSContainerInstanceFilters = map[string]string{
	"agent_connected":        "description.ContainerInstance.AgentConnected",
	"agent_update_status":    "description.ContainerInstance.AgentUpdateStatus",
	"akas":                   "description.ContainerInstance.ContainerInstanceArn",
	"arn":                    "description.ContainerInstance.ContainerInstanceArn",
	"attachments":            "description.ContainerInstance.Attachments",
	"attributes":             "description.ContainerInstance.Attributes",
	"capacity_provider_name": "description.ContainerInstance.CapacityProviderName",
	"ec2_instance_id":        "description.ContainerInstance.Ec2InstanceId",
	"kaytu_account_id":       "metadata.SourceID",
	"pending_tasks_count":    "description.ContainerInstance.PendingTasksCount",
	"registered_at":          "description.ContainerInstance.RegisteredAt",
	"registered_resources":   "description.ContainerInstance.RegisteredResources",
	"remaining_resources":    "description.ContainerInstance.RemainingResources",
	"running_tasks_count":    "description.ContainerInstance.RunningTasksCount",
	"status":                 "description.ContainerInstance.Status",
	"status_reason":          "description.ContainerInstance.StatusReason",
	"title":                  "description.ContainerInstance.ContainerInstanceArn",
	"version":                "description.ContainerInstance.Version",
	"version_info":           "description.ContainerInstance.VersionInfo",
}

func GetECSContainerInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSContainerInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECSContainerInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getECSContainerInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECSContainerInstance =============================

// ==========================  START: ECSTaskSet =============================

type ECSTaskSet struct {
	Description   aws.ECSTaskSetDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ECSTaskSetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSTaskSet    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSTaskSetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSTaskSetHit   `json:"hits"`
}

type ECSTaskSetSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ECSTaskSetHits `json:"hits"`
}

type ECSTaskSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSTaskSetPaginator(filters []essdk.BoolFilter, limit *int64) (ECSTaskSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_taskset", filters, limit)
	if err != nil {
		return ECSTaskSetPaginator{}, err
	}

	p := ECSTaskSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSTaskSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSTaskSetPaginator) NextPage(ctx context.Context) ([]ECSTaskSet, error) {
	var response ECSTaskSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSTaskSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSTaskSetFilters = map[string]string{
	"akas":             "description.TaskSet.TaskSetArn",
	"id":               "description.TaskSet.Id",
	"kaytu_account_id": "metadata.SourceID",
	"task_set_arn":     "description.TaskSet.TaskSetArn",
	"title":            "description.TaskSet.Id",
}

func ListECSTaskSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSTaskSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECSTaskSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listECSTaskSetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECSTaskSetFilters = map[string]string{
	"akas":             "description.TaskSet.TaskSetArn",
	"id":               "description.TaskSet.Id",
	"kaytu_account_id": "metadata.SourceID",
	"task_set_arn":     "description.TaskSet.TaskSetArn",
	"title":            "description.TaskSet.Id",
}

func GetECSTaskSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSTaskSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECSTaskSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getECSTaskSetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECSTaskSet =============================

// ==========================  START: ECSTask =============================

type ECSTask struct {
	Description   aws.ECSTaskDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type ECSTaskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSTask       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSTaskHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSTaskHit      `json:"hits"`
}

type ECSTaskSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  ECSTaskHits `json:"hits"`
}

type ECSTaskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSTaskPaginator(filters []essdk.BoolFilter, limit *int64) (ECSTaskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_task", filters, limit)
	if err != nil {
		return ECSTaskPaginator{}, err
	}

	p := ECSTaskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSTaskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSTaskPaginator) NextPage(ctx context.Context) ([]ECSTask, error) {
	var response ECSTaskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSTask
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSTaskFilters = map[string]string{
	"akas":                   "description.Task.TaskArn",
	"attachments":            "description.Task.Attachments",
	"attributes":             "description.Task.Attributes",
	"availability_zone":      "description.Task.AvailabilityZone",
	"capacity_provider_name": "description.Task.CapacityProviderName",
	"cluster_arn":            "description.Task.ClusterArn",
	"connectivity":           "description.Task.Connectivity",
	"connectivity_at":        "description.Task.ConnectivityAt",
	"container_instance_arn": "description.Task.ContainerInstanceArn",
	"containers":             "description.Task.Containers",
	"cpu":                    "description.NO_MATCH_WAS_FOUND",
	"created_at":             "description.Task.CreatedAt",
	"desired_status":         "description.Task.DesiredStatus",
	"enable_execute_command": "description.Task.EnableExecuteCommand",
	"ephemeral_storage":      "description.Task.EphemeralStorage",
	"execution_stopped_at":   "description.Task.ExecutionStoppedAt",
	"group":                  "description.Task.Group",
	"health_status":          "description.Task.HealthStatus",
	"inference_accelerators": "description.Task.InferenceAccelerators",
	"kaytu_account_id":       "metadata.SourceID",
	"last_status":            "description.Task.LastStatus",
	"launch_type":            "description.Task.LaunchType",
	"memory":                 "description.Task.Memory",
	"overrides":              "description.Task.Overrides",
	"platform_version":       "description.Task.PlatformVersion",
	"protection":             "description.TaskProtection",
	"pull_started_at":        "description.Task.PullStartedAt",
	"pull_stopped_at":        "description.Task.PullStoppedAt",
	"service_name":           "description.ServiceName",
	"started_at":             "description.Task.StartedAt",
	"started_by":             "description.Task.StartedBy",
	"stop_code":              "description.Task.StopCode",
	"stopped_at":             "description.Task.StoppedAt",
	"stopped_reason":         "description.Task.StoppedReason",
	"stopping_at":            "description.Task.StoppingAt",
	"tags_src":               "description.Task.Tags",
	"task_arn":               "description.Task.TaskArn",
	"task_definition_arn":    "description.Task.TaskDefinitionArn",
	"version":                "description.Task.Version",
}

func ListECSTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSTask")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECSTaskPaginator(essdk.BuildFilter(d.KeyColumnQuals, listECSTaskFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECSTaskFilters = map[string]string{
	"akas":                   "description.Task.TaskArn",
	"attachments":            "description.Task.Attachments",
	"attributes":             "description.Task.Attributes",
	"availability_zone":      "description.Task.AvailabilityZone",
	"capacity_provider_name": "description.Task.CapacityProviderName",
	"cluster_arn":            "description.Task.ClusterArn",
	"connectivity":           "description.Task.Connectivity",
	"connectivity_at":        "description.Task.ConnectivityAt",
	"container_instance_arn": "description.Task.ContainerInstanceArn",
	"containers":             "description.Task.Containers",
	"cpu":                    "description.NO_MATCH_WAS_FOUND",
	"created_at":             "description.Task.CreatedAt",
	"desired_status":         "description.Task.DesiredStatus",
	"enable_execute_command": "description.Task.EnableExecuteCommand",
	"ephemeral_storage":      "description.Task.EphemeralStorage",
	"execution_stopped_at":   "description.Task.ExecutionStoppedAt",
	"group":                  "description.Task.Group",
	"health_status":          "description.Task.HealthStatus",
	"inference_accelerators": "description.Task.InferenceAccelerators",
	"kaytu_account_id":       "metadata.SourceID",
	"last_status":            "description.Task.LastStatus",
	"launch_type":            "description.Task.LaunchType",
	"memory":                 "description.Task.Memory",
	"overrides":              "description.Task.Overrides",
	"platform_version":       "description.Task.PlatformVersion",
	"protection":             "description.TaskProtection",
	"pull_started_at":        "description.Task.PullStartedAt",
	"pull_stopped_at":        "description.Task.PullStoppedAt",
	"started_at":             "description.Task.StartedAt",
	"started_by":             "description.Task.StartedBy",
	"stop_code":              "description.Task.StopCode",
	"stopped_at":             "description.Task.StoppedAt",
	"stopped_reason":         "description.Task.StoppedReason",
	"stopping_at":            "description.Task.StoppingAt",
	"tags_src":               "description.Task.Tags",
	"task_arn":               "description.Task.TaskArn",
	"task_definition_arn":    "description.Task.TaskDefinitionArn",
	"version":                "description.Task.Version",
}

func GetECSTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSTask")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECSTaskPaginator(essdk.BuildFilter(d.KeyColumnQuals, getECSTaskFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECSTask =============================

// ==========================  START: EFSFileSystem =============================

type EFSFileSystem struct {
	Description   aws.EFSFileSystemDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EFSFileSystemHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EFSFileSystem `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EFSFileSystemHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EFSFileSystemHit `json:"hits"`
}

type EFSFileSystemSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EFSFileSystemHits `json:"hits"`
}

type EFSFileSystemPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEFSFileSystemPaginator(filters []essdk.BoolFilter, limit *int64) (EFSFileSystemPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_efs_filesystem", filters, limit)
	if err != nil {
		return EFSFileSystemPaginator{}, err
	}

	p := EFSFileSystemPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EFSFileSystemPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EFSFileSystemPaginator) NextPage(ctx context.Context) ([]EFSFileSystem, error) {
	var response EFSFileSystemSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EFSFileSystem
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEFSFileSystemFilters = map[string]string{
	"akas":                            "description.FileSystem.FileSystemArn",
	"arn":                             "description.FileSystem.FileSystemArn",
	"automatic_backups":               "description.FileSystem.Tags",
	"creation_time":                   "description.FileSystem.CreationTime",
	"creation_token":                  "description.FileSystem.CreationToken",
	"encrypted":                       "description.FileSystem.Encrypted",
	"file_system_id":                  "description.FileSystem.FileSystemId",
	"kaytu_account_id":                "metadata.SourceID",
	"kms_key_id":                      "description.FileSystem.KmsKeyId",
	"life_cycle_state":                "description.FileSystem.LifeCycleState",
	"name":                            "description.FileSystem.Name",
	"number_of_mount_targets":         "description.FileSystem.NumberOfMountTargets",
	"owner_id":                        "description.FileSystem.OwnerId",
	"performance_mode":                "description.FileSystem.PerformanceMode",
	"policy":                          "description.Policy",
	"policy_std":                      "description.Policy",
	"provisioned_throughput_in_mibps": "description.FileSystem.ProvisionedThroughputInMibps",
	"size_in_bytes":                   "description.FileSystem.SizeInBytes",
	"tags":                            "description.FileSystem.Tags",
	"tags_src":                        "description.FileSystem.Tags",
	"throughput_mode":                 "description.FileSystem.ThroughputMode",
}

func ListEFSFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEFSFileSystem")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEFSFileSystemPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEFSFileSystemFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEFSFileSystemFilters = map[string]string{
	"akas":                            "description.FileSystem.FileSystemArn",
	"arn":                             "description.FileSystem.FileSystemArn",
	"automatic_backups":               "description.FileSystem.Tags",
	"aws_efs_file_system":             "description.FileSystem.FileSystemId",
	"creation_time":                   "description.FileSystem.CreationTime",
	"creation_token":                  "description.FileSystem.CreationToken",
	"encrypted":                       "description.FileSystem.Encrypted",
	"file_system_id":                  "description.FileSystem.FileSystemId",
	"kaytu_account_id":                "metadata.SourceID",
	"kms_key_id":                      "description.FileSystem.KmsKeyId",
	"life_cycle_state":                "description.FileSystem.LifeCycleState",
	"name":                            "description.FileSystem.Name",
	"number_of_mount_targets":         "description.FileSystem.NumberOfMountTargets",
	"owner_id":                        "description.FileSystem.OwnerId",
	"performance_mode":                "description.FileSystem.PerformanceMode",
	"policy":                          "description.Policy",
	"policy_std":                      "description.Policy",
	"provisioned_throughput_in_mibps": "description.FileSystem.ProvisionedThroughputInMibps",
	"size_in_bytes":                   "description.FileSystem.SizeInBytes",
	"tags":                            "description.FileSystem.Tags",
	"tags_src":                        "description.FileSystem.Tags",
	"throughput_mode":                 "description.FileSystem.ThroughputMode",
}

func GetEFSFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEFSFileSystem")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEFSFileSystemPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEFSFileSystemFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EFSFileSystem =============================

// ==========================  START: EFSAccessPoint =============================

type EFSAccessPoint struct {
	Description   aws.EFSAccessPointDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EFSAccessPointHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EFSAccessPoint `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EFSAccessPointHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EFSAccessPointHit `json:"hits"`
}

type EFSAccessPointSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EFSAccessPointHits `json:"hits"`
}

type EFSAccessPointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEFSAccessPointPaginator(filters []essdk.BoolFilter, limit *int64) (EFSAccessPointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_efs_accesspoint", filters, limit)
	if err != nil {
		return EFSAccessPointPaginator{}, err
	}

	p := EFSAccessPointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EFSAccessPointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EFSAccessPointPaginator) NextPage(ctx context.Context) ([]EFSAccessPoint, error) {
	var response EFSAccessPointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EFSAccessPoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEFSAccessPointFilters = map[string]string{
	"access_point_arn": "description.AccessPoint.AccessPointArn",
	"access_point_id":  "description.AccessPoint.AccessPointId",
	"akas":             "description.AccessPoint.AccessPointArn",
	"client_token":     "description.AccessPoint.ClientToken",
	"file_system_id":   "description.AccessPoint.FileSystemId",
	"kaytu_account_id": "metadata.SourceID",
	"life_cycle_state": "description.AccessPoint.LifeCycleState",
	"name":             "description.AccessPoint.Name",
	"owner_id":         "description.AccessPoint.OwnerId",
	"posix_user":       "description.AccessPoint.PosixUser",
	"root_directory":   "description.AccessPoint.RootDirectory",
	"tags_src":         "description.AccessPoint.Tags",
}

func ListEFSAccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEFSAccessPoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEFSAccessPointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEFSAccessPointFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEFSAccessPointFilters = map[string]string{
	"access_point_arn": "description.AccessPoint.AccessPointArn",
	"access_point_id":  "description.AccessPoint.AccessPointId",
	"akas":             "description.AccessPoint.AccessPointArn",
	"client_token":     "description.AccessPoint.ClientToken",
	"file_system_id":   "description.AccessPoint.FileSystemId",
	"kaytu_account_id": "metadata.SourceID",
	"life_cycle_state": "description.AccessPoint.LifeCycleState",
	"name":             "description.AccessPoint.Name",
	"owner_id":         "description.AccessPoint.OwnerId",
	"posix_user":       "description.AccessPoint.PosixUser",
	"root_directory":   "description.AccessPoint.RootDirectory",
	"tags_src":         "description.AccessPoint.Tags",
}

func GetEFSAccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEFSAccessPoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEFSAccessPointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEFSAccessPointFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EFSAccessPoint =============================

// ==========================  START: EFSMountTarget =============================

type EFSMountTarget struct {
	Description   aws.EFSMountTargetDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EFSMountTargetHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EFSMountTarget `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EFSMountTargetHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EFSMountTargetHit `json:"hits"`
}

type EFSMountTargetSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EFSMountTargetHits `json:"hits"`
}

type EFSMountTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEFSMountTargetPaginator(filters []essdk.BoolFilter, limit *int64) (EFSMountTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_efs_mounttarget", filters, limit)
	if err != nil {
		return EFSMountTargetPaginator{}, err
	}

	p := EFSMountTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EFSMountTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EFSMountTargetPaginator) NextPage(ctx context.Context) ([]EFSMountTarget, error) {
	var response EFSMountTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EFSMountTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEFSMountTargetFilters = map[string]string{
	"akas":                   "aRN",
	"availability_zone_id":   "description.MountTarget.AvailabilityZoneId",
	"availability_zone_name": "description.MountTarget.AvailabilityZoneName",
	"file_system_id":         "description.MountTarget.FileSystemId",
	"ip_address":             "description.MountTarget.IpAddress",
	"kaytu_account_id":       "metadata.SourceID",
	"life_cycle_state":       "description.MountTarget.LifeCycleState",
	"mount_target_id":        "description.MountTarget.MountTargetId",
	"network_interface_id":   "description.MountTarget.NetworkInterfaceId",
	"owner_id":               "description.MountTarget.OwnerId",
	"security_groups":        "description.SecurityGroups",
	"subnet_id":              "description.MountTarget.SubnetId",
	"title":                  "description.MountTarget.MountTargetId",
	"vpc_id":                 "description.MountTarget.VpcId",
}

func ListEFSMountTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEFSMountTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEFSMountTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEFSMountTargetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEFSMountTargetFilters = map[string]string{
	"akas":                   "aRN",
	"availability_zone_id":   "description.MountTarget.AvailabilityZoneId",
	"availability_zone_name": "description.MountTarget.AvailabilityZoneName",
	"file_system_id":         "description.MountTarget.FileSystemId",
	"ip_address":             "description.MountTarget.IpAddress",
	"kaytu_account_id":       "metadata.SourceID",
	"life_cycle_state":       "description.MountTarget.LifeCycleState",
	"mount_target_id":        "description.MountTarget.MountTargetId",
	"network_interface_id":   "description.MountTarget.NetworkInterfaceId",
	"owner_id":               "description.MountTarget.OwnerId",
	"security_groups":        "description.SecurityGroups",
	"subnet_id":              "description.MountTarget.SubnetId",
	"title":                  "description.MountTarget.MountTargetId",
	"vpc_id":                 "description.MountTarget.VpcId",
}

func GetEFSMountTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEFSMountTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEFSMountTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEFSMountTargetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EFSMountTarget =============================

// ==========================  START: EKSCluster =============================

type EKSCluster struct {
	Description   aws.EKSClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EKSClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EKSCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EKSClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EKSClusterHit   `json:"hits"`
}

type EKSClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EKSClusterHits `json:"hits"`
}

type EKSClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSClusterPaginator(filters []essdk.BoolFilter, limit *int64) (EKSClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_cluster", filters, limit)
	if err != nil {
		return EKSClusterPaginator{}, err
	}

	p := EKSClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSClusterPaginator) NextPage(ctx context.Context) ([]EKSCluster, error) {
	var response EKSClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSClusterFilters = map[string]string{
	"akas":                      "description.Cluster.Arn",
	"arn":                       "description.Cluster.Arn",
	"certificate_authority":     "description.Cluster.CertificateAuthority",
	"created_at":                "description.Cluster.CreatedAt",
	"encryption_config":         "description.Cluster.EncryptionConfig",
	"endpoint":                  "description.Cluster.Endpoint",
	"identity":                  "description.Cluster.Identity",
	"kaytu_account_id":          "metadata.SourceID",
	"kubernetes_network_config": "description.Cluster.KubernetesNetworkConfig",
	"logging":                   "description.Cluster.Logging",
	"name":                      "description.Cluster.Name",
	"platform_version":          "description.Cluster.PlatformVersion",
	"resources_vpc_config":      "description.Cluster.ResourcesVpcConfig",
	"role_arn":                  "description.Cluster.RoleArn",
	"status":                    "description.Cluster.Status",
	"tags":                      "description.Cluster.Tags",
	"title":                     "description.Cluster.Name",
	"version":                   "description.Cluster.Version",
}

func ListEKSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEKSClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEKSClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEKSClusterFilters = map[string]string{
	"akas":                      "description.Cluster.Arn",
	"arn":                       "description.Cluster.Arn",
	"certificate_authority":     "description.Cluster.CertificateAuthority",
	"created_at":                "description.Cluster.CreatedAt",
	"encryption_config":         "description.Cluster.EncryptionConfig",
	"endpoint":                  "description.Cluster.Endpoint",
	"identity":                  "description.Cluster.Identity",
	"kaytu_account_id":          "metadata.SourceID",
	"kubernetes_network_config": "description.Cluster.KubernetesNetworkConfig",
	"logging":                   "description.Cluster.Logging",
	"name":                      "description.Cluster.Name",
	"platform_version":          "description.Cluster.PlatformVersion",
	"resources_vpc_config":      "description.Cluster.ResourcesVpcConfig",
	"role_arn":                  "description.Cluster.RoleArn",
	"status":                    "description.Cluster.Status",
	"tags":                      "description.Cluster.Tags",
	"title":                     "description.Cluster.Name",
	"version":                   "description.Cluster.Version",
}

func GetEKSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEKSClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEKSClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EKSCluster =============================

// ==========================  START: EKSAddon =============================

type EKSAddon struct {
	Description   aws.EKSAddonDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type EKSAddonHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EKSAddon      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EKSAddonHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EKSAddonHit     `json:"hits"`
}

type EKSAddonSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  EKSAddonHits `json:"hits"`
}

type EKSAddonPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSAddonPaginator(filters []essdk.BoolFilter, limit *int64) (EKSAddonPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_addon", filters, limit)
	if err != nil {
		return EKSAddonPaginator{}, err
	}

	p := EKSAddonPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSAddonPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSAddonPaginator) NextPage(ctx context.Context) ([]EKSAddon, error) {
	var response EKSAddonSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSAddon
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSAddonFilters = map[string]string{
	"addon_name":               "description.Addon.AddonName",
	"addon_version":            "description.Addon.AddonVersion",
	"akas":                     "description.Addon.AddonArn",
	"arn":                      "description.Addon.AddonArn",
	"cluster_name":             "description.Addon.ClusterName",
	"created_at":               "description.Addon.CreatedAt",
	"health_issues":            "description.Addon.Health.Issues",
	"kaytu_account_id":         "metadata.SourceID",
	"modified_at":              "description.Addon.ModifiedAt",
	"service_account_role_arn": "serviceAccountRoleArn",
	"status":                   "description.Addon.Status",
	"tags":                     "description.Addon.Tags",
	"title":                    "description.Addon.AddonName",
}

func ListEKSAddon(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSAddon")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEKSAddonPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEKSAddonFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEKSAddonFilters = map[string]string{
	"addon_name":               "description.Addon.AddonName",
	"addon_version":            "description.Addon.AddonVersion",
	"akas":                     "description.Addon.AddonArn",
	"arn":                      "description.Addon.AddonArn",
	"cluster_name":             "description.Addon.ClusterName",
	"created_at":               "description.Addon.CreatedAt",
	"health_issues":            "description.Addon.Health.Issues",
	"kaytu_account_id":         "metadata.SourceID",
	"modified_at":              "description.Addon.ModifiedAt",
	"service_account_role_arn": "serviceAccountRoleArn",
	"status":                   "description.Addon.Status",
	"tags":                     "description.Addon.Tags",
	"title":                    "description.Addon.AddonName",
}

func GetEKSAddon(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSAddon")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEKSAddonPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEKSAddonFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EKSAddon =============================

// ==========================  START: EKSNodegroup =============================

type EKSNodegroup struct {
	Description   aws.EKSNodegroupDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type EKSNodegroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EKSNodegroup  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EKSNodegroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EKSNodegroupHit `json:"hits"`
}

type EKSNodegroupSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  EKSNodegroupHits `json:"hits"`
}

type EKSNodegroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSNodegroupPaginator(filters []essdk.BoolFilter, limit *int64) (EKSNodegroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_nodegroup", filters, limit)
	if err != nil {
		return EKSNodegroupPaginator{}, err
	}

	p := EKSNodegroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSNodegroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSNodegroupPaginator) NextPage(ctx context.Context) ([]EKSNodegroup, error) {
	var response EKSNodegroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSNodegroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSNodegroupFilters = map[string]string{
	"akas":             "description.Nodegroup.NodegroupArn",
	"ami_type":         "description.Nodegroup.AmiType",
	"arn":              "nodegroupArn",
	"capacity_type":    "description.Nodegroup.CapacityType",
	"cluster_name":     "description.Nodegroup.ClusterName",
	"created_at":       "description.Nodegroup.CreatedAt",
	"disk_size":        "description.Nodegroup.DiskSize",
	"health":           "description.Nodegroup.Health",
	"instance_types":   "description.Nodegroup.InstanceTypes",
	"kaytu_account_id": "metadata.SourceID",
	"labels":           "description.Nodegroup.Labels",
	"launch_template":  "description.Nodegroup.LaunchTemplate",
	"modified_at":      "description.Nodegroup.ModifiedAt",
	"node_role":        "description.Nodegroup.NodeRole",
	"nodegroup_name":   "description.Nodegroup.NodegroupName",
	"release_version":  "description.Nodegroup.ReleaseVersion",
	"remote_access":    "description.Nodegroup.RemoteAccess",
	"resources":        "description.Nodegroup.Resources",
	"scaling_config":   "description.Nodegroup.ScalingConfig",
	"status":           "description.Nodegroup.Status",
	"subnets":          "description.Nodegroup.Subnets",
	"tags":             "description.Nodegroup.Tags",
	"taints":           "description.Nodegroup.Taints",
	"title":            "description.Nodegroup.NodegroupName",
	"update_config":    "description.Nodegroup.UpdateConfig",
	"version":          "description.Nodegroup.Version",
}

func ListEKSNodegroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSNodegroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEKSNodegroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEKSNodegroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEKSNodegroupFilters = map[string]string{
	"akas":             "description.Nodegroup.NodegroupArn",
	"ami_type":         "description.Nodegroup.AmiType",
	"arn":              "nodegroupArn",
	"capacity_type":    "description.Nodegroup.CapacityType",
	"cluster_name":     "description.Nodegroup.ClusterName",
	"created_at":       "description.Nodegroup.CreatedAt",
	"disk_size":        "description.Nodegroup.DiskSize",
	"health":           "description.Nodegroup.Health",
	"instance_types":   "description.Nodegroup.InstanceTypes",
	"kaytu_account_id": "metadata.SourceID",
	"labels":           "description.Nodegroup.Labels",
	"launch_template":  "description.Nodegroup.LaunchTemplate",
	"modified_at":      "description.Nodegroup.ModifiedAt",
	"node_role":        "description.Nodegroup.NodeRole",
	"nodegroup_name":   "description.Nodegroup.NodegroupName",
	"release_version":  "description.Nodegroup.ReleaseVersion",
	"remote_access":    "description.Nodegroup.RemoteAccess",
	"resources":        "description.Nodegroup.Resources",
	"scaling_config":   "description.Nodegroup.ScalingConfig",
	"status":           "description.Nodegroup.Status",
	"subnets":          "description.Nodegroup.Subnets",
	"tags":             "description.Nodegroup.Tags",
	"taints":           "description.Nodegroup.Taints",
	"title":            "description.Nodegroup.NodegroupName",
	"update_config":    "description.Nodegroup.UpdateConfig",
	"version":          "description.Nodegroup.Version",
}

func GetEKSNodegroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSNodegroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEKSNodegroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEKSNodegroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EKSNodegroup =============================

// ==========================  START: EKSAddonVersion =============================

type EKSAddonVersion struct {
	Description   aws.EKSAddonVersionDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type EKSAddonVersionHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EKSAddonVersion `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EKSAddonVersionHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EKSAddonVersionHit `json:"hits"`
}

type EKSAddonVersionSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EKSAddonVersionHits `json:"hits"`
}

type EKSAddonVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSAddonVersionPaginator(filters []essdk.BoolFilter, limit *int64) (EKSAddonVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_addonversion", filters, limit)
	if err != nil {
		return EKSAddonVersionPaginator{}, err
	}

	p := EKSAddonVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSAddonVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSAddonVersionPaginator) NextPage(ctx context.Context) ([]EKSAddonVersion, error) {
	var response EKSAddonVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSAddonVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSAddonVersionFilters = map[string]string{
	"addon_configuration": "description.AddonConfiguration",
	"addon_name":          "description.AddonName",
	"addon_version":       "description.AddonVersion.AddonVersion",
	"akas":                "aRN",
	"architecture":        "description.AddonVersion.Architecture",
	"compatibilities":     "description.AddonVersion.Compatibilities",
	"kaytu_account_id":    "metadata.SourceID",
	"title":               "description.AddonVersion.AddonVersion",
	"type":                "description.AddonType",
}

func ListEKSAddonVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSAddonVersion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEKSAddonVersionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEKSAddonVersionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEKSAddonVersionFilters = map[string]string{
	"addon_configuration": "description.AddonConfiguration",
	"addon_name":          "description.AddonName",
	"addon_version":       "description.AddonVersion.AddonVersion",
	"akas":                "aRN",
	"architecture":        "description.AddonVersion.Architecture",
	"compatibilities":     "description.AddonVersion.Compatibilities",
	"kaytu_account_id":    "metadata.SourceID",
	"title":               "description.AddonVersion.AddonVersion",
	"type":                "description.AddonType",
}

func GetEKSAddonVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSAddonVersion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEKSAddonVersionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEKSAddonVersionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EKSAddonVersion =============================

// ==========================  START: EKSFargateProfile =============================

type EKSFargateProfile struct {
	Description   aws.EKSFargateProfileDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EKSFargateProfileHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EKSFargateProfile `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EKSFargateProfileHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EKSFargateProfileHit `json:"hits"`
}

type EKSFargateProfileSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EKSFargateProfileHits `json:"hits"`
}

type EKSFargateProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSFargateProfilePaginator(filters []essdk.BoolFilter, limit *int64) (EKSFargateProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_fargateprofile", filters, limit)
	if err != nil {
		return EKSFargateProfilePaginator{}, err
	}

	p := EKSFargateProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSFargateProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSFargateProfilePaginator) NextPage(ctx context.Context) ([]EKSFargateProfile, error) {
	var response EKSFargateProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSFargateProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSFargateProfileFilters = map[string]string{
	"akas":                   "description.FargateProfile.FargateProfileArn",
	"cluster_name":           "description.Fargate.ClusterName",
	"created_at":             "description.FargateProfile.CreatedAt",
	"fargate_profile_arn":    "description.FargateProfile.FargateProfileArn",
	"fargate_profile_name":   "description.FargateProfile.FargateProfileName",
	"kaytu_account_id":       "metadata.SourceID",
	"pod_execution_role_arn": "description.FargateProfile.PodExecutionRoleArn",
	"selectors":              "description.FargateProfile.Selectors",
	"status":                 "description.FargateProfile.Status",
	"subnets":                "description.FargateProfile.Subnets",
	"tags":                   "description.FargateProfile.Tags",
	"title":                  "description.FargateProfile.FargateProfileName",
}

func ListEKSFargateProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSFargateProfile")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEKSFargateProfilePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEKSFargateProfileFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEKSFargateProfileFilters = map[string]string{
	"akas":                   "description.FargateProfile.FargateProfileArn",
	"cluster_name":           "description.Fargate.ClusterName",
	"created_at":             "description.FargateProfile.CreatedAt",
	"fargate_profile_arn":    "description.FargateProfile.FargateProfileArn",
	"fargate_profile_name":   "description.Fargate.FargateProfileName",
	"kaytu_account_id":       "metadata.SourceID",
	"pod_execution_role_arn": "description.FargateProfile.PodExecutionRoleArn",
	"selectors":              "description.FargateProfile.Selectors",
	"status":                 "description.FargateProfile.Status",
	"subnets":                "description.FargateProfile.Subnets",
	"tags":                   "description.FargateProfile.Tags",
	"title":                  "description.FargateProfile.FargateProfileName",
}

func GetEKSFargateProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSFargateProfile")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEKSFargateProfilePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEKSFargateProfileFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EKSFargateProfile =============================

// ==========================  START: WAFv2WebACL =============================

type WAFv2WebACL struct {
	Description   aws.WAFv2WebACLDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type WAFv2WebACLHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFv2WebACL   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFv2WebACLHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFv2WebACLHit  `json:"hits"`
}

type WAFv2WebACLSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  WAFv2WebACLHits `json:"hits"`
}

type WAFv2WebACLPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2WebACLPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2WebACLPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_webacl", filters, limit)
	if err != nil {
		return WAFv2WebACLPaginator{}, err
	}

	p := WAFv2WebACLPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2WebACLPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2WebACLPaginator) NextPage(ctx context.Context) ([]WAFv2WebACL, error) {
	var response WAFv2WebACLSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2WebACL
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2WebACLFilters = map[string]string{
	"akas":                        "description.WebACL.ARN",
	"arn":                         "description.WebACL.ARN",
	"capacity":                    "description.WebACL.Capacity",
	"default_action":              "description.WebACL.DefaultAction",
	"description":                 "description.WebACL.Description",
	"id":                          "description.WebACL.Id",
	"kaytu_account_id":            "metadata.SourceID",
	"lock_token":                  "description.LockToken",
	"logging_configuration":       "description.LoggingConfiguration",
	"managed_by_firewall_manager": "description.WebACL.ManagedByFirewallManager",
	"name":                        "description.WebACL.Name",
	"post_process_firewall_manager_rule_groups": "description.WebACL.PostProcessFirewallManagerRuleGroups",
	"pre_process_firewall_manager_rule_groups":  "description.WebACL.PreProcessFirewallManagerRuleGroups",
	"rules":             "description.WebACL.Rules",
	"tags":              "description.TagInfoForResource.TagList",
	"tags_src":          "description.TagInfoForResource.TagList",
	"title":             "description.WebACL.Name",
	"visibility_config": "description.WebACL.VisibilityConfig",
}

func ListWAFv2WebACL(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2WebACL")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFv2WebACLPaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFv2WebACLFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFv2WebACLFilters = map[string]string{
	"akas":                        "description.WebACL.ARN",
	"arn":                         "description.WebACL.ARN",
	"capacity":                    "description.WebACL.Capacity",
	"default_action":              "description.WebACL.DefaultAction",
	"description":                 "description.WebACL.Description",
	"id":                          "description.WebACL.Id",
	"kaytu_account_id":            "metadata.SourceID",
	"lock_token":                  "description.LockToken",
	"logging_configuration":       "description.LoggingConfiguration",
	"managed_by_firewall_manager": "description.WebACL.ManagedByFirewallManager",
	"name":                        "description.WebACL.Name",
	"post_process_firewall_manager_rule_groups": "description.WebACL.PostProcessFirewallManagerRuleGroups",
	"pre_process_firewall_manager_rule_groups":  "description.WebACL.PreProcessFirewallManagerRuleGroups",
	"rules":             "description.WebACL.Rules",
	"scope":             "description.Scope",
	"tags":              "description.TagInfoForResource.TagList",
	"tags_src":          "description.TagInfoForResource.TagList",
	"title":             "description.WebACL.Name",
	"visibility_config": "description.WebACL.VisibilityConfig",
}

func GetWAFv2WebACL(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2WebACL")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFv2WebACLPaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFv2WebACLFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFv2WebACL =============================

// ==========================  START: WAFv2IPSet =============================

type WAFv2IPSet struct {
	Description   aws.WAFv2IPSetDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type WAFv2IPSetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFv2IPSet    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFv2IPSetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFv2IPSetHit   `json:"hits"`
}

type WAFv2IPSetSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  WAFv2IPSetHits `json:"hits"`
}

type WAFv2IPSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2IPSetPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2IPSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_ipset", filters, limit)
	if err != nil {
		return WAFv2IPSetPaginator{}, err
	}

	p := WAFv2IPSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2IPSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2IPSetPaginator) NextPage(ctx context.Context) ([]WAFv2IPSet, error) {
	var response WAFv2IPSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2IPSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2IPSetFilters = map[string]string{
	"account_id":         "metadata.AccountID",
	"addresses":          "description.IPSet.Addresses",
	"akas":               "description.IPSet.ARN",
	"arn":                "description.IPSet.ARN",
	"description":        "description.IPSet.Description",
	"id":                 "description.IPSet.Id",
	"ip_address_version": "description.IPSet.IPAddressVersion",
	"kaytu_account_id":   "metadata.SourceID",
	"lock_token":         "description.IPSetSummary.LockToken",
	"name":               "description.IPSet.Name",
	"partition":          "metadata.Partition",
	"tags":               "description.IPSet.Addresses",
	"tags_src":           "description.IPSet.Addresses",
	"title":              "description.IPSet.Name",
}

func ListWAFv2IPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2IPSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFv2IPSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFv2IPSetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFv2IPSetFilters = map[string]string{
	"account_id":         "metadata.AccountID",
	"addresses":          "description.IPSet.Addresses",
	"akas":               "description.IPSet.ARN",
	"arn":                "description.IPSet.ARN",
	"description":        "description.IPSet.Description",
	"id":                 "description.IPSetSummary.Id",
	"ip_address_version": "description.IPSet.IPAddressVersion",
	"kaytu_account_id":   "metadata.SourceID",
	"lock_token":         "description.IPSetSummary.LockToken",
	"name":               "description.IPSetSummary.Name",
	"partition":          "metadata.Partition",
	"scope":              "description.IPSetSummary.Scope",
	"tags":               "description.IPSet.Addresses",
	"tags_src":           "description.IPSet.Addresses",
	"title":              "description.IPSet.Name",
}

func GetWAFv2IPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2IPSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFv2IPSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFv2IPSetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFv2IPSet =============================

// ==========================  START: WAFv2RegexPatternSet =============================

type WAFv2RegexPatternSet struct {
	Description   aws.WAFv2RegexPatternSetDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type WAFv2RegexPatternSetHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  WAFv2RegexPatternSet `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type WAFv2RegexPatternSetHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []WAFv2RegexPatternSetHit `json:"hits"`
}

type WAFv2RegexPatternSetSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  WAFv2RegexPatternSetHits `json:"hits"`
}

type WAFv2RegexPatternSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2RegexPatternSetPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2RegexPatternSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_regexpatternset", filters, limit)
	if err != nil {
		return WAFv2RegexPatternSetPaginator{}, err
	}

	p := WAFv2RegexPatternSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2RegexPatternSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2RegexPatternSetPaginator) NextPage(ctx context.Context) ([]WAFv2RegexPatternSet, error) {
	var response WAFv2RegexPatternSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2RegexPatternSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2RegexPatternSetFilters = map[string]string{
	"account_id":          "metadata.AccountID",
	"akas":                "description.RegexPatternSet.ARN",
	"arn":                 "description.RegexPatternSet.ARN",
	"description":         "description.RegexPatternSet.Description",
	"id":                  "id",
	"kaytu_account_id":    "metadata.SourceID",
	"lock_token":          "description.RegexPatternSetSummary.LockToken",
	"name":                "description.RegexPatternSet.Name",
	"partition":           "metadata.Partition",
	"region":              "description.RegexPatternSet",
	"regular_expressions": "description.RegexPatternSet.RegularExpressionList",
	"tags":                "description.Tags.TagInfoForResource.TagList",
	"tags_src":            "description.Tags.TagInfoForResource.TagList",
	"title":               "description.RegexPatternSet.Name",
}

func ListWAFv2RegexPatternSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2RegexPatternSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFv2RegexPatternSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFv2RegexPatternSetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFv2RegexPatternSetFilters = map[string]string{
	"account_id":          "metadata.AccountID",
	"akas":                "description.RegexPatternSet.ARN",
	"arn":                 "description.RegexPatternSet.ARN",
	"description":         "description.RegexPatternSet.Description",
	"id":                  "description.IPSetSummary.Id",
	"kaytu_account_id":    "metadata.SourceID",
	"lock_token":          "description.RegexPatternSetSummary.LockToken",
	"name":                "description.IPSetSummary.Name",
	"partition":           "metadata.Partition",
	"region":              "description.RegexPatternSet",
	"regular_expressions": "description.RegexPatternSet.RegularExpressionList",
	"scope":               "description.IPSetSummary.Scope",
	"tags":                "description.Tags.TagInfoForResource.TagList",
	"tags_src":            "description.Tags.TagInfoForResource.TagList",
	"title":               "description.RegexPatternSet.Name",
}

func GetWAFv2RegexPatternSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2RegexPatternSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFv2RegexPatternSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFv2RegexPatternSetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFv2RegexPatternSet =============================

// ==========================  START: WAFv2RuleGroup =============================

type WAFv2RuleGroup struct {
	Description   aws.WAFv2RuleGroupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type WAFv2RuleGroupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  WAFv2RuleGroup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type WAFv2RuleGroupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []WAFv2RuleGroupHit `json:"hits"`
}

type WAFv2RuleGroupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  WAFv2RuleGroupHits `json:"hits"`
}

type WAFv2RuleGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2RuleGroupPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2RuleGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_rulegroup", filters, limit)
	if err != nil {
		return WAFv2RuleGroupPaginator{}, err
	}

	p := WAFv2RuleGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2RuleGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2RuleGroupPaginator) NextPage(ctx context.Context) ([]WAFv2RuleGroup, error) {
	var response WAFv2RuleGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2RuleGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2RuleGroupFilters = map[string]string{
	"account_id":        "metadata.AccountID",
	"akas":              "description.RuleGroup.ARN",
	"arn":               "description.RuleGroup.ARN",
	"capacity":          "description.RuleGroup.Capacity",
	"description":       "description.RuleGroup.Description",
	"id":                "description.RuleGroup.Id",
	"kaytu_account_id":  "metadata.SourceID",
	"lock_token":        "description.RuleGroupSummary.LockToken",
	"name":              "description.RuleGroup.Name",
	"partition":         "metadata.Partition",
	"rules":             "description.RuleGroup.Rules",
	"tags":              "description.Tags",
	"tags_src":          "description.Tags.TagInfoForResource.TagList",
	"title":             "description.RuleGroup.Name",
	"visibility_config": "description.RuleGroup.VisibilityConfig",
}

func ListWAFv2RuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2RuleGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFv2RuleGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFv2RuleGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFv2RuleGroupFilters = map[string]string{
	"account_id":        "metadata.AccountID",
	"akas":              "description.RuleGroup.ARN",
	"arn":               "description.RuleGroup.ARN",
	"capacity":          "description.RuleGroup.Capacity",
	"description":       "description.RuleGroup.Description",
	"id":                "description.RuleGroup.Id",
	"kaytu_account_id":  "metadata.SourceID",
	"lock_token":        "description.RuleGroupSummary.LockToken",
	"name":              "description.RuleGroup.Name",
	"partition":         "metadata.Partition",
	"rules":             "description.RuleGroup.Rules",
	"scope":             "description.Tags",
	"tags":              "description.Tags",
	"tags_src":          "description.Tags.TagInfoForResource.TagList",
	"title":             "description.RuleGroup.Name",
	"visibility_config": "description.RuleGroup.VisibilityConfig",
}

func GetWAFv2RuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2RuleGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFv2RuleGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFv2RuleGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFv2RuleGroup =============================

// ==========================  START: KMSKey =============================

type KMSKey struct {
	Description   aws.KMSKeyDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type KMSKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KMSKey        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KMSKeyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KMSKeyHit       `json:"hits"`
}

type KMSKeySearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  KMSKeyHits `json:"hits"`
}

type KMSKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKMSKeyPaginator(filters []essdk.BoolFilter, limit *int64) (KMSKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kms_key", filters, limit)
	if err != nil {
		return KMSKeyPaginator{}, err
	}

	p := KMSKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KMSKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KMSKeyPaginator) NextPage(ctx context.Context) ([]KMSKey, error) {
	var response KMSKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KMSKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKMSKeyFilters = map[string]string{
	"akas":                     "description.Metadata.Arn",
	"aliases":                  "description.Aliases",
	"arn":                      "description.Metadata.Arn",
	"aws_account_id":           "description.Metadata.AWSAccountId",
	"creation_date":            "description.Metadata.CreationDate",
	"customer_master_key_spec": "description.Metadata.CustomerMasterKeySpec",
	"deletion_date":            "description.Metadata.DeletionDate",
	"description":              "description.Metadata.Description",
	"enabled":                  "description.Metadata.Enabled",
	"id":                       "description.Metadata.KeyId",
	"kaytu_account_id":         "metadata.SourceID",
	"key_manager":              "description.Metadata.KeyManager",
	"key_rotation_enabled":     "description.KeyRotationEnabled",
	"key_state":                "description.Metadata.KeyState",
	"key_usage":                "description.Metadata.KeyUsage",
	"origin":                   "description.Metadata.Origin",
	"policy":                   "description.Policy",
	"policy_std":               "description.Policy",
	"tags":                     "description.Tags",
	"tags_src":                 "description.Tags",
	"title":                    "description.Metadata.KeyId",
	"valid_to":                 "description.Metadata.ValidTo",
}

func ListKMSKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKMSKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKMSKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKMSKeyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKMSKeyFilters = map[string]string{
	"akas":                     "description.Metadata.Arn",
	"aliases":                  "description.Aliases",
	"arn":                      "description.Metadata.Arn",
	"aws_account_id":           "description.Metadata.AWSAccountId",
	"creation_date":            "description.Metadata.CreationDate",
	"customer_master_key_spec": "description.Metadata.CustomerMasterKeySpec",
	"deletion_date":            "description.Metadata.DeletionDate",
	"description":              "description.Metadata.Description",
	"enabled":                  "description.Metadata.Enabled",
	"id":                       "description.Metadata.KeyId",
	"kaytu_account_id":         "metadata.SourceID",
	"key_manager":              "description.Metadata.KeyManager",
	"key_rotation_enabled":     "description.KeyRotationEnabled",
	"key_state":                "description.Metadata.KeyState",
	"key_usage":                "description.Metadata.KeyUsage",
	"origin":                   "description.Metadata.Origin",
	"policy":                   "description.Policy",
	"policy_std":               "description.Policy",
	"tags":                     "description.Tags",
	"tags_src":                 "description.Tags",
	"title":                    "description.Metadata.KeyId",
	"valid_to":                 "description.Metadata.ValidTo",
}

func GetKMSKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKMSKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKMSKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKMSKeyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KMSKey =============================

// ==========================  START: KMSAlias =============================

type KMSAlias struct {
	Description   aws.KMSAliasDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type KMSAliasHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KMSAlias      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KMSAliasHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KMSAliasHit     `json:"hits"`
}

type KMSAliasSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  KMSAliasHits `json:"hits"`
}

type KMSAliasPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKMSAliasPaginator(filters []essdk.BoolFilter, limit *int64) (KMSAliasPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kms_alias", filters, limit)
	if err != nil {
		return KMSAliasPaginator{}, err
	}

	p := KMSAliasPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KMSAliasPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KMSAliasPaginator) NextPage(ctx context.Context) ([]KMSAlias, error) {
	var response KMSAliasSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KMSAlias
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKMSAliasFilters = map[string]string{
	"akas":              "description.Alias.AliasArn",
	"alias_name":        "description.Alias.AliasName",
	"arn":               "description.Alias.AliasArn",
	"creation_date":     "description.Alias.CreationDate",
	"kaytu_account_id":  "metadata.SourceID",
	"last_updated_date": "description.Alias.LastUpdatedDate",
	"target_key_id":     "description.Alias.TargetKeyId",
	"title":             "description.Alias.AliasName",
}

func ListKMSAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKMSAlias")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKMSAliasPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKMSAliasFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKMSAliasFilters = map[string]string{
	"akas":              "description.Alias.AliasArn",
	"alias_name":        "description.Alias.AliasName",
	"arn":               "description.Alias.AliasArn",
	"creation_date":     "description.Alias.CreationDate",
	"kaytu_account_id":  "metadata.SourceID",
	"last_updated_date": "description.Alias.LastUpdatedDate",
	"target_key_id":     "description.Alias.TargetKeyId",
	"title":             "description.Alias.AliasName",
}

func GetKMSAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKMSAlias")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKMSAliasPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKMSAliasFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KMSAlias =============================

// ==========================  START: LambdaFunction =============================

type LambdaFunction struct {
	Description   aws.LambdaFunctionDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type LambdaFunctionHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  LambdaFunction `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type LambdaFunctionHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []LambdaFunctionHit `json:"hits"`
}

type LambdaFunctionSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  LambdaFunctionHits `json:"hits"`
}

type LambdaFunctionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaFunctionPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaFunctionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_function", filters, limit)
	if err != nil {
		return LambdaFunctionPaginator{}, err
	}

	p := LambdaFunctionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaFunctionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaFunctionPaginator) NextPage(ctx context.Context) ([]LambdaFunction, error) {
	var response LambdaFunctionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaFunction
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaFunctionFilters = map[string]string{
	"akas":                           "description.Function.Configuration.FunctionArn",
	"arn":                            "description.Function.Configuration.FunctionArn",
	"code_sha_256":                   "description.Function.Configuration.CodeSha256",
	"code_size":                      "description.Function.Configuration.CodeSize",
	"dead_letter_config_target_arn":  "description.Function.Configuration.DeadLetterConfig.TargetArn",
	"description":                    "description.Function.Configuration.Description",
	"handler":                        "description.Function.Configuration.Handler",
	"kaytu_account_id":               "metadata.SourceID",
	"kms_key_arn":                    "description.Function.Configuration.KMSKeyArn",
	"last_modified":                  "description.Function.Configuration.LastModified",
	"last_update_status":             "description.Function.Configuration.LastUpdateStatus",
	"last_update_status_reason":      "description.Function.Configuration.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.Function.Configuration.LastUpdateStatusReasonCode",
	"master_arn":                     "description.Function.Configuration.MasterArn",
	"memory_size":                    "description.Function.Configuration.MemorySize",
	"name":                           "description.Function.Configuration.FunctionName",
	"package_type":                   "description.Function.Configuration.PackageType",
	"policy":                         "description.Policy",
	"policy_std":                     "description.Policy",
	"reserved_concurrent_executions": "description.Function.Concurrency.ReservedConcurrentExecutions",
	"revision_id":                    "description.Policy.RevisionId",
	"role":                           "description.Function.Configuration.Role",
	"runtime":                        "description.Function.Configuration.Runtime",
	"state":                          "description.Function.Configuration.State",
	"state_reason":                   "description.Function.Configuration.StateReason",
	"state_reason_code":              "description.Function.Configuration.StateReasonCode",
	"tags":                           "description.Function.Tags",
	"timeout":                        "description.Function.Configuration.Timeout",
	"title":                          "description.Function.Configuration.FunctionName",
	"version":                        "description.Function.Configuration.Version",
	"vpc_id":                         "description.Function.Configuration.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.Function.Configuration.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.Function.Configuration.VpcConfig.SubnetIds",
}

func ListLambdaFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaFunction")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLambdaFunctionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLambdaFunctionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLambdaFunctionFilters = map[string]string{
	"akas":                           "description.Function.Configuration.FunctionArn",
	"arn":                            "description.Function.Configuration.FunctionArn",
	"code_sha_256":                   "description.Function.Configuration.CodeSha256",
	"code_size":                      "description.Function.Configuration.CodeSize",
	"dead_letter_config_target_arn":  "description.Function.Configuration.DeadLetterConfig.TargetArn",
	"description":                    "description.Function.Configuration.Description",
	"handler":                        "description.Function.Configuration.Handler",
	"kaytu_account_id":               "metadata.SourceID",
	"kms_key_arn":                    "description.Function.Configuration.KMSKeyArn",
	"last_modified":                  "description.Function.Configuration.LastModified",
	"last_update_status":             "description.Function.Configuration.LastUpdateStatus",
	"last_update_status_reason":      "description.Function.Configuration.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.Function.Configuration.LastUpdateStatusReasonCode",
	"master_arn":                     "description.Function.Configuration.MasterArn",
	"memory_size":                    "description.Function.Configuration.MemorySize",
	"name":                           "description.Function.Configuration.FunctionName",
	"package_type":                   "description.Function.Configuration.PackageType",
	"policy":                         "description.Policy",
	"policy_std":                     "description.Policy",
	"reserved_concurrent_executions": "description.Function.Concurrency.ReservedConcurrentExecutions",
	"revision_id":                    "description.Policy.RevisionId",
	"role":                           "description.Function.Configuration.Role",
	"runtime":                        "description.Function.Configuration.Runtime",
	"state":                          "description.Function.Configuration.State",
	"state_reason":                   "description.Function.Configuration.StateReason",
	"state_reason_code":              "description.Function.Configuration.StateReasonCode",
	"tags":                           "description.Function.Tags",
	"timeout":                        "description.Function.Configuration.Timeout",
	"title":                          "description.Function.Configuration.FunctionName",
	"version":                        "description.Function.Configuration.Version",
	"vpc_id":                         "description.Function.Configuration.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.Function.Configuration.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.Function.Configuration.VpcConfig.SubnetIds",
}

func GetLambdaFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaFunction")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLambdaFunctionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLambdaFunctionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LambdaFunction =============================

// ==========================  START: LambdaFunctionVersion =============================

type LambdaFunctionVersion struct {
	Description   aws.LambdaFunctionVersionDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type LambdaFunctionVersionHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  LambdaFunctionVersion `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type LambdaFunctionVersionHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []LambdaFunctionVersionHit `json:"hits"`
}

type LambdaFunctionVersionSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  LambdaFunctionVersionHits `json:"hits"`
}

type LambdaFunctionVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaFunctionVersionPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaFunctionVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_functionversion", filters, limit)
	if err != nil {
		return LambdaFunctionVersionPaginator{}, err
	}

	p := LambdaFunctionVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaFunctionVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaFunctionVersionPaginator) NextPage(ctx context.Context) ([]LambdaFunctionVersion, error) {
	var response LambdaFunctionVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaFunctionVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaFunctionVersionFilters = map[string]string{
	"akas":                           "description.FunctionVersion.FunctionArn",
	"arn":                            "description.FunctionVersion.FunctionArn",
	"code_sha_256":                   "description.FunctionVersion.CodeSha256",
	"code_size":                      "description.FunctionVersion.CodeSize",
	"description":                    "description.FunctionVersion.Description",
	"environment_variables":          "description.FunctionVersion.Environment.Variables",
	"function_name":                  "description.FunctionVersion.FunctionName",
	"handler":                        "description.FunctionVersion.Handler",
	"kaytu_account_id":               "metadata.SourceID",
	"last_modified":                  "description.FunctionVersion.LastModified",
	"last_update_status":             "description.FunctionVersion.LastUpdateStatus",
	"last_update_status_reason":      "description.FunctionVersion.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.FunctionVersion.LastUpdateStatusReasonCode",
	"master_arn":                     "description.FunctionVersion.MasterArn",
	"memory_size":                    "description.FunctionVersion.MemorySize",
	"policy":                         "description.Policy",
	"policy_std":                     "description.Policy",
	"revision_id":                    "description.Policy.RevisionId",
	"runtime":                        "description.FunctionVersion.Runtime",
	"state":                          "description.FunctionVersion.State",
	"timeout":                        "description.FunctionVersion.Timeout",
	"title":                          "description.FunctionVersion",
	"version":                        "description.FunctionVersion.Version",
	"vpc_id":                         "description.FunctionVersion.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.FunctionVersion.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.FunctionVersion.VpcConfig.SubnetIds",
}

func ListLambdaFunctionVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaFunctionVersion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLambdaFunctionVersionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLambdaFunctionVersionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLambdaFunctionVersionFilters = map[string]string{
	"akas":                           "description.FunctionVersion.FunctionArn",
	"arn":                            "description.FunctionVersion.FunctionArn",
	"code_sha_256":                   "description.FunctionVersion.CodeSha256",
	"code_size":                      "description.FunctionVersion.CodeSize",
	"description":                    "description.FunctionVersion.Description",
	"environment_variables":          "description.FunctionVersion.Environment.Variables",
	"function_name":                  "description.FunctionVersion.FunctionName",
	"handler":                        "description.FunctionVersion.Handler",
	"kaytu_account_id":               "metadata.SourceID",
	"last_modified":                  "description.FunctionVersion.LastModified",
	"last_update_status":             "description.FunctionVersion.LastUpdateStatus",
	"last_update_status_reason":      "description.FunctionVersion.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.FunctionVersion.LastUpdateStatusReasonCode",
	"master_arn":                     "description.FunctionVersion.MasterArn",
	"memory_size":                    "description.FunctionVersion.MemorySize",
	"policy":                         "description.Policy",
	"policy_std":                     "description.Policy",
	"revision_id":                    "description.Policy.RevisionId",
	"runtime":                        "description.FunctionVersion.Runtime",
	"state":                          "description.FunctionVersion.State",
	"timeout":                        "description.FunctionVersion.Timeout",
	"title":                          "description.FunctionVersion",
	"version":                        "description.FunctionVersion.Version",
	"vpc_id":                         "description.FunctionVersion.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.FunctionVersion.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.FunctionVersion.VpcConfig.SubnetIds",
}

func GetLambdaFunctionVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaFunctionVersion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLambdaFunctionVersionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLambdaFunctionVersionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LambdaFunctionVersion =============================

// ==========================  START: LambdaAlias =============================

type LambdaAlias struct {
	Description   aws.LambdaAliasDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type LambdaAliasHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LambdaAlias   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LambdaAliasHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LambdaAliasHit  `json:"hits"`
}

type LambdaAliasSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  LambdaAliasHits `json:"hits"`
}

type LambdaAliasPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaAliasPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaAliasPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_alias", filters, limit)
	if err != nil {
		return LambdaAliasPaginator{}, err
	}

	p := LambdaAliasPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaAliasPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaAliasPaginator) NextPage(ctx context.Context) ([]LambdaAlias, error) {
	var response LambdaAliasSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaAlias
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaAliasFilters = map[string]string{
	"akas":             "description.Alias.AliasArn",
	"alias_arn":        "description.Alias.AliasArn",
	"description":      "description.Alias.Description",
	"function_name":    "description.FunctionName",
	"function_version": "description.Alias.FunctionVersion",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Alias.Name",
	"policy":           "description.Policy",
	"policy_std":       "description.Policy",
	"revision_id":      "description.Alias.RevisionId",
	"title":            "description.Alias.Name",
	"url_config":       "description.UrlConfig",
}

func ListLambdaAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaAlias")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLambdaAliasPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLambdaAliasFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLambdaAliasFilters = map[string]string{
	"akas":             "description.Alias.AliasArn",
	"alias_arn":        "description.Alias.AliasArn",
	"description":      "description.Alias.Description",
	"function_name":    "description.FunctionName",
	"function_version": "description.Alias.FunctionVersion",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Alias.Name",
	"policy":           "description.Policy",
	"policy_std":       "description.Policy",
	"region":           "description.Alias.AliasName",
	"revision_id":      "description.Alias.RevisionId",
	"title":            "description.Alias.Name",
	"url_config":       "description.UrlConfig",
}

func GetLambdaAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaAlias")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLambdaAliasPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLambdaAliasFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LambdaAlias =============================

// ==========================  START: LambdaLayer =============================

type LambdaLayer struct {
	Description   aws.LambdaLayerDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type LambdaLayerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LambdaLayer   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LambdaLayerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LambdaLayerHit  `json:"hits"`
}

type LambdaLayerSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  LambdaLayerHits `json:"hits"`
}

type LambdaLayerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaLayerPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaLayerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_lambdalayer", filters, limit)
	if err != nil {
		return LambdaLayerPaginator{}, err
	}

	p := LambdaLayerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaLayerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaLayerPaginator) NextPage(ctx context.Context) ([]LambdaLayer, error) {
	var response LambdaLayerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaLayer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaLayerFilters = map[string]string{
	"akas":                     "description.Layer.LayerArn",
	"compatible_architectures": "description.Layer.LatestMatchingVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.Layer.LatestMatchingVersion.CompatibleRuntimes",
	"created_date":             "description.Layer.LatestMatchingVersion.CreatedDate",
	"description":              "description.Layer.LatestMatchingVersion.Description",
	"kaytu_account_id":         "metadata.SourceID",
	"layer_arn":                "description.Layer.LayerArn",
	"layer_name":               "description.Layer.LayerName",
	"layer_version_arn":        "description.Layer.LatestMatchingVersion.LayerVersionArn",
	"license_info":             "description.Layer.LatestMatchingVersion.LicenseInfo",
	"title":                    "description.Layer.LayerName",
	"version":                  "description.Layer.LatestMatchingVersion.Version",
}

func ListLambdaLayer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaLayer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLambdaLayerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLambdaLayerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLambdaLayerFilters = map[string]string{
	"akas":                     "description.Layer.LayerArn",
	"compatible_architectures": "description.Layer.LatestMatchingVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.Layer.LatestMatchingVersion.CompatibleRuntimes",
	"created_date":             "description.Layer.LatestMatchingVersion.CreatedDate",
	"description":              "description.Layer.LatestMatchingVersion.Description",
	"kaytu_account_id":         "metadata.SourceID",
	"layer_arn":                "description.Layer.LayerArn",
	"layer_name":               "description.Layer.LayerName",
	"layer_version_arn":        "description.Layer.LatestMatchingVersion.LayerVersionArn",
	"license_info":             "description.Layer.LatestMatchingVersion.LicenseInfo",
	"title":                    "description.Layer.LayerName",
	"version":                  "description.Layer.LatestMatchingVersion.Version",
}

func GetLambdaLayer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaLayer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLambdaLayerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLambdaLayerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LambdaLayer =============================

// ==========================  START: LambdaLayerVersion =============================

type LambdaLayerVersion struct {
	Description   aws.LambdaLayerVersionDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type LambdaLayerVersionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  LambdaLayerVersion `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type LambdaLayerVersionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []LambdaLayerVersionHit `json:"hits"`
}

type LambdaLayerVersionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  LambdaLayerVersionHits `json:"hits"`
}

type LambdaLayerVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaLayerVersionPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaLayerVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_layerversion", filters, limit)
	if err != nil {
		return LambdaLayerVersionPaginator{}, err
	}

	p := LambdaLayerVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaLayerVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaLayerVersionPaginator) NextPage(ctx context.Context) ([]LambdaLayerVersion, error) {
	var response LambdaLayerVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaLayerVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaLayerVersionFilters = map[string]string{
	"akas":                     "description.LayerVersion.LayerVersionArn",
	"compatible_architectures": "description.LayerVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.LayerVersion.CompatibleRuntimes",
	"content":                  "description.LayerVersion.Content",
	"created_date":             "description.LayerVersion.CreatedDate",
	"description":              "description.LayerVersion.Description",
	"kaytu_account_id":         "metadata.SourceID",
	"layer_arn":                "description.LayerVersion.LayerArn",
	"layer_name":               "description.LayerName",
	"layer_version_arn":        "description.LayerVersion.LayerVersionArn",
	"license_info":             "description.LayerVersion.LicenseInfo",
	"policy":                   "description.Policy",
	"policy_std":               "description.Policy",
	"revision_id":              "description.Policy.RevisionId",
	"title":                    "description.LayerName",
	"version":                  "description.LayerVersion.Version",
}

func ListLambdaLayerVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaLayerVersion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLambdaLayerVersionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLambdaLayerVersionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLambdaLayerVersionFilters = map[string]string{
	"akas":                     "description.LayerVersion.LayerVersionArn",
	"compatible_architectures": "description.LayerVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.LayerVersion.CompatibleRuntimes",
	"content":                  "description.LayerVersion.Content",
	"created_date":             "description.LayerVersion.CreatedDate",
	"description":              "description.LayerVersion.Description",
	"kaytu_account_id":         "metadata.SourceID",
	"layer_arn":                "description.LayerVersion.LayerArn",
	"layer_name":               "description.LayerName",
	"layer_version_arn":        "description.LayerVersion.LayerVersionArn",
	"license_info":             "description.LayerVersion.LicenseInfo",
	"policy":                   "description.Policy",
	"policy_std":               "description.Policy",
	"revision_id":              "description.Policy.RevisionId",
	"title":                    "description.LayerName",
	"version":                  "description.LayerVersion.Version",
}

func GetLambdaLayerVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaLayerVersion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLambdaLayerVersionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLambdaLayerVersionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LambdaLayerVersion =============================

// ==========================  START: S3AccessPoint =============================

type S3AccessPoint struct {
	Description   aws.S3AccessPointDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type S3AccessPointHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  S3AccessPoint `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type S3AccessPointHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []S3AccessPointHit `json:"hits"`
}

type S3AccessPointSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  S3AccessPointHits `json:"hits"`
}

type S3AccessPointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3AccessPointPaginator(filters []essdk.BoolFilter, limit *int64) (S3AccessPointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_accesspoint", filters, limit)
	if err != nil {
		return S3AccessPointPaginator{}, err
	}

	p := S3AccessPointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3AccessPointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3AccessPointPaginator) NextPage(ctx context.Context) ([]S3AccessPoint, error) {
	var response S3AccessPointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3AccessPoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3AccessPointFilters = map[string]string{
	"access_point_policy_is_public": "description.PolicyStatus.IsPublic",
	"block_public_acls":             "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":           "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_name":                   "description.AccessPoint.Bucket",
	"creation_date":                 "description.AccessPoint.CreationDate",
	"ignore_public_acls":            "description.AccessPoint.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.AccessPoint.Name",
	"network_origin":                "description.AccessPoint.NetworkOrigin",
	"policy":                        "description.Policy",
	"policy_std":                    "description.Policy",
	"restrict_public_buckets":       "description.AccessPoint.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"title":                         "description.AccessPoint.Name",
	"vpc_id":                        "description.AccessPoint.VpcConfiguration.VpcId",
}

func ListS3AccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3AccessPoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewS3AccessPointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listS3AccessPointFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getS3AccessPointFilters = map[string]string{
	"access_point_policy_is_public": "description.PolicyStatus.IsPublic",
	"block_public_acls":             "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":           "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_name":                   "description.AccessPoint.Bucket",
	"creation_date":                 "description.AccessPoint.CreationDate",
	"ignore_public_acls":            "description.AccessPoint.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.AccessPoint.Name",
	"network_origin":                "description.AccessPoint.NetworkOrigin",
	"policy":                        "description.Policy",
	"policy_std":                    "description.Policy",
	"region":                        "metadata.region",
	"restrict_public_buckets":       "description.AccessPoint.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"title":                         "description.AccessPoint.Name",
	"vpc_id":                        "description.AccessPoint.VpcConfiguration.VpcId",
}

func GetS3AccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3AccessPoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewS3AccessPointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getS3AccessPointFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: S3AccessPoint =============================

// ==========================  START: CostExplorerByAccountMonthly =============================

type CostExplorerByAccountMonthly struct {
	Description   aws.CostExplorerByAccountMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type CostExplorerByAccountMonthlyHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  CostExplorerByAccountMonthly `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type CostExplorerByAccountMonthlyHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []CostExplorerByAccountMonthlyHit `json:"hits"`
}

type CostExplorerByAccountMonthlySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  CostExplorerByAccountMonthlyHits `json:"hits"`
}

type CostExplorerByAccountMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByAccountMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByAccountMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byaccountmonthly", filters, limit)
	if err != nil {
		return CostExplorerByAccountMonthlyPaginator{}, err
	}

	p := CostExplorerByAccountMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByAccountMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByAccountMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByAccountMonthly, error) {
	var response CostExplorerByAccountMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByAccountMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByAccountMonthlyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func ListCostExplorerByAccountMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByAccountMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByAccountMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByAccountMonthlyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByAccountMonthlyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func GetCostExplorerByAccountMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByAccountMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByAccountMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByAccountMonthlyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByAccountMonthly =============================

// ==========================  START: CostExplorerByServiceMonthly =============================

type CostExplorerByServiceMonthly struct {
	Description   aws.CostExplorerByServiceMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type CostExplorerByServiceMonthlyHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  CostExplorerByServiceMonthly `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type CostExplorerByServiceMonthlyHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []CostExplorerByServiceMonthlyHit `json:"hits"`
}

type CostExplorerByServiceMonthlySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  CostExplorerByServiceMonthlyHits `json:"hits"`
}

type CostExplorerByServiceMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byservicemonthly", filters, limit)
	if err != nil {
		return CostExplorerByServiceMonthlyPaginator{}, err
	}

	p := CostExplorerByServiceMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceMonthly, error) {
	var response CostExplorerByServiceMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceMonthlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "description.Dimension1",
}

func ListCostExplorerByServiceMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByServiceMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByServiceMonthlyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByServiceMonthlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "description.Dimension1",
}

func GetCostExplorerByServiceMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByServiceMonthlyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceMonthly =============================

// ==========================  START: CostExplorerByRecordTypeMonthly =============================

type CostExplorerByRecordTypeMonthly struct {
	Description   aws.CostExplorerByRecordTypeMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CostExplorerByRecordTypeMonthlyHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CostExplorerByRecordTypeMonthly `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CostExplorerByRecordTypeMonthlyHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CostExplorerByRecordTypeMonthlyHit `json:"hits"`
}

type CostExplorerByRecordTypeMonthlySearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CostExplorerByRecordTypeMonthlyHits `json:"hits"`
}

type CostExplorerByRecordTypeMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByRecordTypeMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByRecordTypeMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byrecordtypemonthly", filters, limit)
	if err != nil {
		return CostExplorerByRecordTypeMonthlyPaginator{}, err
	}

	p := CostExplorerByRecordTypeMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByRecordTypeMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByRecordTypeMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByRecordTypeMonthly, error) {
	var response CostExplorerByRecordTypeMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByRecordTypeMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByRecordTypeMonthlyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func ListCostExplorerByRecordTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByRecordTypeMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByRecordTypeMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByRecordTypeMonthlyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByRecordTypeMonthlyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func GetCostExplorerByRecordTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByRecordTypeMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByRecordTypeMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByRecordTypeMonthlyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByRecordTypeMonthly =============================

// ==========================  START: CostExplorerByServiceUsageTypeMonthly =============================

type CostExplorerByServiceUsageTypeMonthly struct {
	Description   aws.CostExplorerByServiceUsageTypeMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                         `json:"metadata"`
	ResourceJobID int                                                  `json:"resource_job_id"`
	SourceJobID   int                                                  `json:"source_job_id"`
	ResourceType  string                                               `json:"resource_type"`
	SourceType    string                                               `json:"source_type"`
	ID            string                                               `json:"id"`
	ARN           string                                               `json:"arn"`
	SourceID      string                                               `json:"source_id"`
}

type CostExplorerByServiceUsageTypeMonthlyHit struct {
	ID      string                                `json:"_id"`
	Score   float64                               `json:"_score"`
	Index   string                                `json:"_index"`
	Type    string                                `json:"_type"`
	Version int64                                 `json:"_version,omitempty"`
	Source  CostExplorerByServiceUsageTypeMonthly `json:"_source"`
	Sort    []interface{}                         `json:"sort"`
}

type CostExplorerByServiceUsageTypeMonthlyHits struct {
	Total essdk.SearchTotal                          `json:"total"`
	Hits  []CostExplorerByServiceUsageTypeMonthlyHit `json:"hits"`
}

type CostExplorerByServiceUsageTypeMonthlySearchResponse struct {
	PitID string                                    `json:"pit_id"`
	Hits  CostExplorerByServiceUsageTypeMonthlyHits `json:"hits"`
}

type CostExplorerByServiceUsageTypeMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceUsageTypeMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceUsageTypeMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byusagetypemonthly", filters, limit)
	if err != nil {
		return CostExplorerByServiceUsageTypeMonthlyPaginator{}, err
	}

	p := CostExplorerByServiceUsageTypeMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceUsageTypeMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceUsageTypeMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceUsageTypeMonthly, error) {
	var response CostExplorerByServiceUsageTypeMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceUsageTypeMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceUsageTypeMonthlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "dimension1",
	"usage_type":       "dimension2",
}

func ListCostExplorerByServiceUsageTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceUsageTypeMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByServiceUsageTypeMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByServiceUsageTypeMonthlyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByServiceUsageTypeMonthlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "dimension1",
	"usage_type":       "dimension2",
}

func GetCostExplorerByServiceUsageTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceUsageTypeMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceUsageTypeMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByServiceUsageTypeMonthlyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceUsageTypeMonthly =============================

// ==========================  START: CostExplorerForcastMonthly =============================

type CostExplorerForcastMonthly struct {
	Description   aws.CostExplorerForcastMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CostExplorerForcastMonthlyHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CostExplorerForcastMonthly `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CostExplorerForcastMonthlyHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CostExplorerForcastMonthlyHit `json:"hits"`
}

type CostExplorerForcastMonthlySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CostExplorerForcastMonthlyHits `json:"hits"`
}

type CostExplorerForcastMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerForcastMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerForcastMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_forcastmonthly", filters, limit)
	if err != nil {
		return CostExplorerForcastMonthlyPaginator{}, err
	}

	p := CostExplorerForcastMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerForcastMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerForcastMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerForcastMonthly, error) {
	var response CostExplorerForcastMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerForcastMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerForcastMonthlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"mean_value":       "description.MeanValue",
	"period_end":       "description.PeriodEnd",
	"period_start":     "description.PeriodStart",
}

func ListCostExplorerForcastMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerForcastMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerForcastMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerForcastMonthlyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerForcastMonthlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"mean_value":       "description.MeanValue",
	"period_end":       "description.PeriodEnd",
	"period_start":     "description.PeriodStart",
}

func GetCostExplorerForcastMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerForcastMonthly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerForcastMonthlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerForcastMonthlyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerForcastMonthly =============================

// ==========================  START: CostExplorerByAccountDaily =============================

type CostExplorerByAccountDaily struct {
	Description   aws.CostExplorerByAccountDailyDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CostExplorerByAccountDailyHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CostExplorerByAccountDaily `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CostExplorerByAccountDailyHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CostExplorerByAccountDailyHit `json:"hits"`
}

type CostExplorerByAccountDailySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CostExplorerByAccountDailyHits `json:"hits"`
}

type CostExplorerByAccountDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByAccountDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByAccountDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byaccountdaily", filters, limit)
	if err != nil {
		return CostExplorerByAccountDailyPaginator{}, err
	}

	p := CostExplorerByAccountDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByAccountDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByAccountDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByAccountDaily, error) {
	var response CostExplorerByAccountDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByAccountDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByAccountDailyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func ListCostExplorerByAccountDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByAccountDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByAccountDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByAccountDailyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByAccountDailyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func GetCostExplorerByAccountDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByAccountDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByAccountDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByAccountDailyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByAccountDaily =============================

// ==========================  START: CostExplorerByServiceDaily =============================

type CostExplorerByServiceDaily struct {
	Description   aws.CostExplorerByServiceDailyDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CostExplorerByServiceDailyHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CostExplorerByServiceDaily `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CostExplorerByServiceDailyHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CostExplorerByServiceDailyHit `json:"hits"`
}

type CostExplorerByServiceDailySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CostExplorerByServiceDailyHits `json:"hits"`
}

type CostExplorerByServiceDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byservicedaily", filters, limit)
	if err != nil {
		return CostExplorerByServiceDailyPaginator{}, err
	}

	p := CostExplorerByServiceDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceDaily, error) {
	var response CostExplorerByServiceDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "description.Dimension1",
}

func ListCostExplorerByServiceDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByServiceDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByServiceDailyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByServiceDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "description.Dimension1",
}

func GetCostExplorerByServiceDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByServiceDailyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceDaily =============================

// ==========================  START: CostExplorerByRecordTypeDaily =============================

type CostExplorerByRecordTypeDaily struct {
	Description   aws.CostExplorerByRecordTypeDailyDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CostExplorerByRecordTypeDailyHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CostExplorerByRecordTypeDaily `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CostExplorerByRecordTypeDailyHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CostExplorerByRecordTypeDailyHit `json:"hits"`
}

type CostExplorerByRecordTypeDailySearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CostExplorerByRecordTypeDailyHits `json:"hits"`
}

type CostExplorerByRecordTypeDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByRecordTypeDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByRecordTypeDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byrecordtypedaily", filters, limit)
	if err != nil {
		return CostExplorerByRecordTypeDailyPaginator{}, err
	}

	p := CostExplorerByRecordTypeDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByRecordTypeDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByRecordTypeDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByRecordTypeDaily, error) {
	var response CostExplorerByRecordTypeDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByRecordTypeDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByRecordTypeDailyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func ListCostExplorerByRecordTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByRecordTypeDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByRecordTypeDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByRecordTypeDailyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByRecordTypeDailyFilters = map[string]string{
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func GetCostExplorerByRecordTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByRecordTypeDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByRecordTypeDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByRecordTypeDailyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByRecordTypeDaily =============================

// ==========================  START: CostExplorerByServiceUsageTypeDaily =============================

type CostExplorerByServiceUsageTypeDaily struct {
	Description   aws.CostExplorerByServiceUsageTypeDailyDescription `json:"description"`
	Metadata      aws.Metadata                                       `json:"metadata"`
	ResourceJobID int                                                `json:"resource_job_id"`
	SourceJobID   int                                                `json:"source_job_id"`
	ResourceType  string                                             `json:"resource_type"`
	SourceType    string                                             `json:"source_type"`
	ID            string                                             `json:"id"`
	ARN           string                                             `json:"arn"`
	SourceID      string                                             `json:"source_id"`
}

type CostExplorerByServiceUsageTypeDailyHit struct {
	ID      string                              `json:"_id"`
	Score   float64                             `json:"_score"`
	Index   string                              `json:"_index"`
	Type    string                              `json:"_type"`
	Version int64                               `json:"_version,omitempty"`
	Source  CostExplorerByServiceUsageTypeDaily `json:"_source"`
	Sort    []interface{}                       `json:"sort"`
}

type CostExplorerByServiceUsageTypeDailyHits struct {
	Total essdk.SearchTotal                        `json:"total"`
	Hits  []CostExplorerByServiceUsageTypeDailyHit `json:"hits"`
}

type CostExplorerByServiceUsageTypeDailySearchResponse struct {
	PitID string                                  `json:"pit_id"`
	Hits  CostExplorerByServiceUsageTypeDailyHits `json:"hits"`
}

type CostExplorerByServiceUsageTypeDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceUsageTypeDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceUsageTypeDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byusagetypedaily", filters, limit)
	if err != nil {
		return CostExplorerByServiceUsageTypeDailyPaginator{}, err
	}

	p := CostExplorerByServiceUsageTypeDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceUsageTypeDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceUsageTypeDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceUsageTypeDaily, error) {
	var response CostExplorerByServiceUsageTypeDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceUsageTypeDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceUsageTypeDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "dimension1",
	"usage_type":       "dimension2",
}

func ListCostExplorerByServiceUsageTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceUsageTypeDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerByServiceUsageTypeDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerByServiceUsageTypeDailyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerByServiceUsageTypeDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"service":          "dimension1",
	"usage_type":       "dimension2",
}

func GetCostExplorerByServiceUsageTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceUsageTypeDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceUsageTypeDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerByServiceUsageTypeDailyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceUsageTypeDaily =============================

// ==========================  START: CostExplorerForcastDaily =============================

type CostExplorerForcastDaily struct {
	Description   aws.CostExplorerForcastDailyDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type CostExplorerForcastDailyHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  CostExplorerForcastDaily `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type CostExplorerForcastDailyHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []CostExplorerForcastDailyHit `json:"hits"`
}

type CostExplorerForcastDailySearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  CostExplorerForcastDailyHits `json:"hits"`
}

type CostExplorerForcastDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerForcastDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerForcastDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_forcastdaily", filters, limit)
	if err != nil {
		return CostExplorerForcastDailyPaginator{}, err
	}

	p := CostExplorerForcastDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerForcastDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerForcastDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerForcastDaily, error) {
	var response CostExplorerForcastDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerForcastDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerForcastDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"mean_value":       "description.MeanValue",
	"period_end":       "description.PeriodEnd",
	"period_start":     "description.PeriodStart",
}

func ListCostExplorerForcastDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerForcastDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostExplorerForcastDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostExplorerForcastDailyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostExplorerForcastDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"mean_value":       "description.MeanValue",
	"period_end":       "description.PeriodEnd",
	"period_start":     "description.PeriodStart",
}

func GetCostExplorerForcastDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerForcastDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostExplorerForcastDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostExplorerForcastDailyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostExplorerForcastDaily =============================

// ==========================  START: ECRRepository =============================

type ECRRepository struct {
	Description   aws.ECRRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type ECRRepositoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECRRepository `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECRRepositoryHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []ECRRepositoryHit `json:"hits"`
}

type ECRRepositorySearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  ECRRepositoryHits `json:"hits"`
}

type ECRRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (ECRRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_repository", filters, limit)
	if err != nil {
		return ECRRepositoryPaginator{}, err
	}

	p := ECRRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRRepositoryPaginator) NextPage(ctx context.Context) ([]ECRRepository, error) {
	var response ECRRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRRepositoryFilters = map[string]string{
	"akas":                         "description.Repository.RepositoryArn",
	"arn":                          "description.Repository.RepositoryArn",
	"created_at":                   "description.Repository.CreatedAt",
	"image_details":                "description.ImageDetails",
	"image_scanning_configuration": "description.Repository.ImageScanningConfiguration",
	"image_tag_mutability":         "description.Repository.ImageTagMutability",
	"kaytu_account_id":             "metadata.SourceID",
	"last_evaluated_at":            "description.LifecyclePolicy.LastEvaluatedAt",
	"lifecycle_policy":             "description.LifecyclePolicy.LifecyclePolicyText",
	"policy":                       "description.Policy.PolicyText",
	"policy_std":                   "description.Policy.PolicyText",
	"registry_id":                  "description.Repository.RegistryId",
	"repository_name":              "description.Repository.RepositoryName",
	"repository_uri":               "description.Repository.RepositoryUri",
	"tags":                         "description.Tags",
	"tags_src":                     "description.Tags",
	"title":                        "description.Repository.RepositoryName",
}

func ListECRRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECRRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listECRRepositoryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECRRepositoryFilters = map[string]string{
	"akas":                         "description.Repository.RepositoryArn",
	"arn":                          "description.Repository.RepositoryArn",
	"created_at":                   "description.Repository.CreatedAt",
	"image_details":                "description.ImageDetails",
	"image_scanning_configuration": "description.Repository.ImageScanningConfiguration",
	"image_tag_mutability":         "description.Repository.ImageTagMutability",
	"kaytu_account_id":             "metadata.SourceID",
	"last_evaluated_at":            "description.LifecyclePolicy.LastEvaluatedAt",
	"lifecycle_policy":             "description.LifecyclePolicy.LifecyclePolicyText",
	"policy":                       "description.Policy.PolicyText",
	"policy_std":                   "description.Policy.PolicyText",
	"registry_id":                  "description.Repository.RegistryId",
	"repository_name":              "description.Repository.RepositoryName",
	"repository_uri":               "description.Repository.RepositoryUri",
	"tags":                         "description.Tags",
	"tags_src":                     "description.Tags",
	"title":                        "description.Repository.RepositoryName",
}

func GetECRRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECRRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getECRRepositoryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECRRepository =============================

// ==========================  START: ECRImage =============================

type ECRImage struct {
	Description   aws.ECRImageDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type ECRImageHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECRImage      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECRImageHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECRImageHit     `json:"hits"`
}

type ECRImageSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ECRImageHits `json:"hits"`
}

type ECRImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRImagePaginator(filters []essdk.BoolFilter, limit *int64) (ECRImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_image", filters, limit)
	if err != nil {
		return ECRImagePaginator{}, err
	}

	p := ECRImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRImagePaginator) NextPage(ctx context.Context) ([]ECRImage, error) {
	var response ECRImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRImage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRImageFilters = map[string]string{
	"artifact_media_type":         "description.Image.ArtifactMediaType",
	"image_digest":                "description.Image.ImageDigest",
	"image_manifest_media_type":   "description.Image.ImageManifestMediaType",
	"image_pushed_at":             "description.Image.ImagePushedAt",
	"image_scan_findings_summary": "description.Image.ImageScanFindingsSummary",
	"image_scan_status":           "description.Image.ImageScanStatus",
	"image_size_in_bytes":         "description.Image.ImageSizeInBytes",
	"image_tags":                  "description.Image.ImageTags",
	"kaytu_account_id":            "metadata.SourceID",
	"last_recorded_pull_time":     "description.Image.LastRecordedPullTime",
	"registry_id":                 "description.Image.RegistryId",
	"repository_name":             "description.Image.RepositoryName",
}

func ListECRImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRImage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECRImagePaginator(essdk.BuildFilter(d.KeyColumnQuals, listECRImageFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECRImageFilters = map[string]string{
	"artifact_media_type":         "description.Image.ArtifactMediaType",
	"image_digest":                "description.Image.ImageDigest",
	"image_manifest_media_type":   "description.Image.ImageManifestMediaType",
	"image_pushed_at":             "description.Image.ImagePushedAt",
	"image_scan_findings_summary": "description.Image.ImageScanFindingsSummary",
	"image_scan_status":           "description.Image.ImageScanStatus",
	"image_size_in_bytes":         "description.Image.ImageSizeInBytes",
	"image_tags":                  "description.Image.ImageTags",
	"kaytu_account_id":            "metadata.SourceID",
	"last_recorded_pull_time":     "description.Image.LastRecordedPullTime",
	"registry_id":                 "description.Image.RegistryId",
	"repository_name":             "description.Image.RepositoryName",
}

func GetECRImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRImage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECRImagePaginator(essdk.BuildFilter(d.KeyColumnQuals, getECRImageFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECRImage =============================

// ==========================  START: ECRPublicRepository =============================

type ECRPublicRepository struct {
	Description   aws.ECRPublicRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type ECRPublicRepositoryHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ECRPublicRepository `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ECRPublicRepositoryHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ECRPublicRepositoryHit `json:"hits"`
}

type ECRPublicRepositorySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ECRPublicRepositoryHits `json:"hits"`
}

type ECRPublicRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRPublicRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (ECRPublicRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_publicrepository", filters, limit)
	if err != nil {
		return ECRPublicRepositoryPaginator{}, err
	}

	p := ECRPublicRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRPublicRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRPublicRepositoryPaginator) NextPage(ctx context.Context) ([]ECRPublicRepository, error) {
	var response ECRPublicRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRPublicRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRPublicRepositoryFilters = map[string]string{
	"akas":             "description.PublicRepository.RepositoryArn",
	"arn":              "description.PublicRepository.RepositoryArn",
	"created_at":       "description.PublicRepository.CreatedAt",
	"image_details":    "description.ImageDetails",
	"kaytu_account_id": "metadata.SourceID",
	"policy":           "description.Policy.PolicyText",
	"policy_std":       "description.Policy.PolicyText",
	"registry_id":      "description.PublicRepository.RegistryId",
	"repository_name":  "description.PublicRepository.RepositoryName",
	"repository_uri":   "description.PublicRepository.RepositoryUri",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.PublicRepository.RepositoryName",
}

func ListECRPublicRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRPublicRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECRPublicRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listECRPublicRepositoryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECRPublicRepositoryFilters = map[string]string{
	"akas":             "description.PublicRepository.RepositoryArn",
	"arn":              "description.PublicRepository.RepositoryArn",
	"created_at":       "description.PublicRepository.CreatedAt",
	"image_details":    "description.ImageDetails",
	"kaytu_account_id": "metadata.SourceID",
	"policy":           "description.Policy.PolicyText",
	"policy_std":       "description.Policy.PolicyText",
	"registry_id":      "description.PublicRepository.RegistryId",
	"repository_name":  "description.PublicRepository.RepositoryName",
	"repository_uri":   "description.PublicRepository.RepositoryUri",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.PublicRepository.RepositoryName",
}

func GetECRPublicRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRPublicRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECRPublicRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getECRPublicRepositoryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECRPublicRepository =============================

// ==========================  START: ECRPublicRegistry =============================

type ECRPublicRegistry struct {
	Description   aws.ECRPublicRegistryDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ECRPublicRegistryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ECRPublicRegistry `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ECRPublicRegistryHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ECRPublicRegistryHit `json:"hits"`
}

type ECRPublicRegistrySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ECRPublicRegistryHits `json:"hits"`
}

type ECRPublicRegistryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRPublicRegistryPaginator(filters []essdk.BoolFilter, limit *int64) (ECRPublicRegistryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_publicregistry", filters, limit)
	if err != nil {
		return ECRPublicRegistryPaginator{}, err
	}

	p := ECRPublicRegistryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRPublicRegistryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRPublicRegistryPaginator) NextPage(ctx context.Context) ([]ECRPublicRegistry, error) {
	var response ECRPublicRegistrySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRPublicRegistry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRPublicRegistryFilters = map[string]string{
	"akas":             "description.PublicRegistry.RegistryArn",
	"kaytu_account_id": "metadata.SourceID",
	"registry_arn":     "description.PublicRegistry.RegistryArn",
	"registry_id":      "description.PublicRegistry.RegistryId",
	"title":            "description.PublicRegistry.RegistryId",
}

func ListECRPublicRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRPublicRegistry")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewECRPublicRegistryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listECRPublicRegistryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getECRPublicRegistryFilters = map[string]string{
	"akas":             "description.PublicRegistry.RegistryArn",
	"kaytu_account_id": "metadata.SourceID",
	"registry_arn":     "description.PublicRegistry.RegistryArn",
	"registry_id":      "description.PublicRegistry.RegistryId",
	"title":            "description.PublicRegistry.RegistryId",
}

func GetECRPublicRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRPublicRegistry")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewECRPublicRegistryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getECRPublicRegistryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ECRPublicRegistry =============================

// ==========================  START: EventBridgeBus =============================

type EventBridgeBus struct {
	Description   aws.EventBridgeBusDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EventBridgeBusHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EventBridgeBus `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EventBridgeBusHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EventBridgeBusHit `json:"hits"`
}

type EventBridgeBusSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EventBridgeBusHits `json:"hits"`
}

type EventBridgeBusPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventBridgeBusPaginator(filters []essdk.BoolFilter, limit *int64) (EventBridgeBusPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eventbridge_eventbus", filters, limit)
	if err != nil {
		return EventBridgeBusPaginator{}, err
	}

	p := EventBridgeBusPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventBridgeBusPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventBridgeBusPaginator) NextPage(ctx context.Context) ([]EventBridgeBus, error) {
	var response EventBridgeBusSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventBridgeBus
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventBridgeBusFilters = map[string]string{
	"akas":             "description.Bus.Arn",
	"arn":              "description.Bus.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Bus.Name",
	"policy":           "description.Bus.Policy",
	"policy_std":       "description.Bus.Policy",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.Bus.Name",
}

func ListEventBridgeBus(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventBridgeBus")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEventBridgeBusPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEventBridgeBusFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEventBridgeBusFilters = map[string]string{
	"akas":             "description.Bus.Arn",
	"arn":              "description.Bus.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Bus.Name",
	"policy":           "description.Bus.Policy",
	"policy_std":       "description.Bus.Policy",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.Bus.Name",
}

func GetEventBridgeBus(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventBridgeBus")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEventBridgeBusPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEventBridgeBusFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EventBridgeBus =============================

// ==========================  START: EventBridgeRule =============================

type EventBridgeRule struct {
	Description   aws.EventBridgeRuleDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type EventBridgeRuleHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EventBridgeRule `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EventBridgeRuleHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EventBridgeRuleHit `json:"hits"`
}

type EventBridgeRuleSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EventBridgeRuleHits `json:"hits"`
}

type EventBridgeRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventBridgeRulePaginator(filters []essdk.BoolFilter, limit *int64) (EventBridgeRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eventbridge_eventrule", filters, limit)
	if err != nil {
		return EventBridgeRulePaginator{}, err
	}

	p := EventBridgeRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventBridgeRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventBridgeRulePaginator) NextPage(ctx context.Context) ([]EventBridgeRule, error) {
	var response EventBridgeRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventBridgeRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventBridgeRuleFilters = map[string]string{
	"akas":             "description.Rule.Arn",
	"arn":              "description.Rule.Arn",
	"created_by":       "description.Rule.CreatedBy",
	"description":      "description.Rule.Description",
	"event_bus_name":   "description.Rule.EventBusName",
	"event_pattern":    "description.Rule.EventPattern",
	"kaytu_account_id": "metadata.SourceID",
	"managed_by":       "description.Rule.ManagedBy",
	"name":             "description.Rule.Name",
	"name_prefix":      "description.Rule.Name",
	"state":            "description.Rule.State",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"targets":          "description.Targets",
	"title":            "description.Rule.Name",
}

func ListEventBridgeRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventBridgeRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEventBridgeRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEventBridgeRuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEventBridgeRuleFilters = map[string]string{
	"akas":             "description.Rule.Arn",
	"arn":              "description.Rule.Arn",
	"created_by":       "description.Rule.CreatedBy",
	"description":      "description.Rule.Description",
	"event_bus_name":   "description.Rule.EventBusName",
	"event_pattern":    "description.Rule.EventPattern",
	"kaytu_account_id": "metadata.SourceID",
	"managed_by":       "description.Rule.ManagedBy",
	"name":             "description.Rule.Name",
	"name_prefix":      "description.Rule.ScheduleExpression",
	"state":            "description.Rule.State",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"targets":          "description.Targets",
	"title":            "description.Rule.Name",
}

func GetEventBridgeRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventBridgeRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEventBridgeRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEventBridgeRuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EventBridgeRule =============================

// ==========================  START: AppStreamApplication =============================

type AppStreamApplication struct {
	Description   aws.AppStreamApplicationDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AppStreamApplicationHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AppStreamApplication `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AppStreamApplicationHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AppStreamApplicationHit `json:"hits"`
}

type AppStreamApplicationSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AppStreamApplicationHits `json:"hits"`
}

type AppStreamApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppStreamApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (AppStreamApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appstream_application", filters, limit)
	if err != nil {
		return AppStreamApplicationPaginator{}, err
	}

	p := AppStreamApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppStreamApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppStreamApplicationPaginator) NextPage(ctx context.Context) ([]AppStreamApplication, error) {
	var response AppStreamApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppStreamApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppStreamApplicationFilters = map[string]string{
	"akas":             "description.Application.Arn",
	"arn":              "description.Application.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Application.Name",
	"tags":             "description.Tags",
	"title":            "description.Application.Name",
}

func ListAppStreamApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppStreamApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppStreamApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppStreamApplicationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppStreamApplicationFilters = map[string]string{
	"akas":             "description.Application.Arn",
	"arn":              "description.Application.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Application.Name",
	"tags":             "description.Tags",
	"title":            "description.Application.Name",
}

func GetAppStreamApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppStreamApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppStreamApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppStreamApplicationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppStreamApplication =============================

// ==========================  START: AppStreamStack =============================

type AppStreamStack struct {
	Description   aws.AppStreamStackDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type AppStreamStackHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AppStreamStack `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AppStreamStackHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AppStreamStackHit `json:"hits"`
}

type AppStreamStackSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AppStreamStackHits `json:"hits"`
}

type AppStreamStackPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppStreamStackPaginator(filters []essdk.BoolFilter, limit *int64) (AppStreamStackPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appstream_stack", filters, limit)
	if err != nil {
		return AppStreamStackPaginator{}, err
	}

	p := AppStreamStackPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppStreamStackPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppStreamStackPaginator) NextPage(ctx context.Context) ([]AppStreamStack, error) {
	var response AppStreamStackSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppStreamStack
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppStreamStackFilters = map[string]string{
	"akas":             "description.Stack.Arn",
	"arn":              "description.Stack.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Stack.Name",
	"tags":             "description.Tags",
	"title":            "description.Stack.Name",
}

func ListAppStreamStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppStreamStack")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppStreamStackPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppStreamStackFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppStreamStackFilters = map[string]string{
	"akas":             "description.Stack.Arn",
	"arn":              "description.Stack.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Stack.Name",
	"tags":             "description.Tags",
	"title":            "description.Stack.Name",
}

func GetAppStreamStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppStreamStack")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppStreamStackPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppStreamStackFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppStreamStack =============================

// ==========================  START: AppStreamFleet =============================

type AppStreamFleet struct {
	Description   aws.AppStreamFleetDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type AppStreamFleetHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AppStreamFleet `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AppStreamFleetHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AppStreamFleetHit `json:"hits"`
}

type AppStreamFleetSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AppStreamFleetHits `json:"hits"`
}

type AppStreamFleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppStreamFleetPaginator(filters []essdk.BoolFilter, limit *int64) (AppStreamFleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appstream_fleet", filters, limit)
	if err != nil {
		return AppStreamFleetPaginator{}, err
	}

	p := AppStreamFleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppStreamFleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppStreamFleetPaginator) NextPage(ctx context.Context) ([]AppStreamFleet, error) {
	var response AppStreamFleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppStreamFleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppStreamFleetFilters = map[string]string{
	"akas":             "description.Fleet.Arn",
	"arn":              "description.Fleet.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Fleet.Name",
	"tags":             "description.Tags",
	"title":            "description.Fleet.Name",
}

func ListAppStreamFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppStreamFleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppStreamFleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppStreamFleetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppStreamFleetFilters = map[string]string{
	"akas":             "description.Fleet.Arn",
	"arn":              "description.Fleet.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Fleet.Name",
	"tags":             "description.Tags",
	"title":            "description.Fleet.Name",
}

func GetAppStreamFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppStreamFleet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppStreamFleetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppStreamFleetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppStreamFleet =============================

// ==========================  START: KinesisStream =============================

type KinesisStream struct {
	Description   aws.KinesisStreamDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type KinesisStreamHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KinesisStream `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KinesisStreamHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []KinesisStreamHit `json:"hits"`
}

type KinesisStreamSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  KinesisStreamHits `json:"hits"`
}

type KinesisStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisStreamPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesis_stream", filters, limit)
	if err != nil {
		return KinesisStreamPaginator{}, err
	}

	p := KinesisStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisStreamPaginator) NextPage(ctx context.Context) ([]KinesisStream, error) {
	var response KinesisStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisStreamFilters = map[string]string{
	"akas":                      "description.Stream.StreamARN",
	"consumer_count":            "description.DescriptionSummary.ConsumerCount",
	"encryption_type":           "description.Stream.EncryptionType",
	"enhanced_monitoring":       "description.Stream.EnhancedMonitoring",
	"has_more_shards":           "description.Stream.HasMoreShards",
	"kaytu_account_id":          "metadata.SourceID",
	"key_id":                    "description.Stream.KeyId",
	"open_shard_count":          "description.DescriptionSummary.OpenShardCount",
	"retention_period_hours":    "description.Stream.RetentionPeriodHours",
	"shards":                    "description.Stream.Shards",
	"stream_arn":                "description.Stream.StreamARN",
	"stream_creation_timestamp": "description.Stream.StreamCreationTimestamp",
	"stream_name":               "description.Stream.StreamName",
	"stream_status":             "description.Stream.StreamStatus",
	"tags":                      "description.Tags",
	"tags_src":                  "description.Tags",
	"title":                     "description.Stream.StreamName",
}

func ListKinesisStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKinesisStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKinesisStreamFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKinesisStreamFilters = map[string]string{
	"akas":                      "description.Stream.StreamARN",
	"consumer_count":            "description.DescriptionSummary.ConsumerCount",
	"encryption_type":           "description.Stream.EncryptionType",
	"enhanced_monitoring":       "description.Stream.EnhancedMonitoring",
	"has_more_shards":           "description.Stream.HasMoreShards",
	"kaytu_account_id":          "metadata.SourceID",
	"key_id":                    "description.Stream.KeyId",
	"open_shard_count":          "description.DescriptionSummary.OpenShardCount",
	"retention_period_hours":    "description.Stream.RetentionPeriodHours",
	"shards":                    "description.Stream.Shards",
	"stream_arn":                "description.Stream.StreamARN",
	"stream_creation_timestamp": "description.Stream.StreamCreationTimestamp",
	"stream_name":               "description.Stream.StreamName",
	"stream_status":             "description.Stream.StreamStatus",
	"tags":                      "description.Tags",
	"tags_src":                  "description.Tags",
	"title":                     "description.Stream.StreamName",
}

func GetKinesisStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKinesisStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKinesisStreamFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KinesisStream =============================

// ==========================  START: KinesisVideoStream =============================

type KinesisVideoStream struct {
	Description   aws.KinesisVideoStreamDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type KinesisVideoStreamHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  KinesisVideoStream `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type KinesisVideoStreamHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []KinesisVideoStreamHit `json:"hits"`
}

type KinesisVideoStreamSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  KinesisVideoStreamHits `json:"hits"`
}

type KinesisVideoStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisVideoStreamPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisVideoStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesisvideo_stream", filters, limit)
	if err != nil {
		return KinesisVideoStreamPaginator{}, err
	}

	p := KinesisVideoStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisVideoStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisVideoStreamPaginator) NextPage(ctx context.Context) ([]KinesisVideoStream, error) {
	var response KinesisVideoStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisVideoStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisVideoStreamFilters = map[string]string{
	"akas":                    "description.Stream.StreamARN",
	"creation_time":           "description.Stream.CreationTime",
	"data_retention_in_hours": "description.Stream.DataRetentionInHours",
	"device_name":             "description.Stream.DeviceName",
	"kaytu_account_id":        "metadata.SourceID",
	"kms_key_id":              "description.Stream.KmsKeyId",
	"media_type":              "description.Stream.MediaType",
	"status":                  "description.Stream.Status",
	"stream_arn":              "description.Stream.StreamARN",
	"stream_name":             "description.Stream.StreamName",
	"tags":                    "description.Tags",
	"title":                   "description.Stream.StreamName",
	"version":                 "description.Stream.Version",
}

func ListKinesisVideoStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisVideoStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKinesisVideoStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKinesisVideoStreamFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKinesisVideoStreamFilters = map[string]string{
	"akas":                    "description.Stream.StreamARN",
	"creation_time":           "description.Stream.CreationTime",
	"data_retention_in_hours": "description.Stream.DataRetentionInHours",
	"device_name":             "description.Stream.DeviceName",
	"kaytu_account_id":        "metadata.SourceID",
	"kms_key_id":              "description.Stream.KmsKeyId",
	"media_type":              "description.Stream.MediaType",
	"status":                  "description.Stream.Status",
	"stream_arn":              "description.Stream.StreamARN",
	"stream_name":             "description.Stream.StreamName",
	"tags":                    "description.Tags",
	"title":                   "description.Stream.StreamName",
	"version":                 "description.Stream.Version",
}

func GetKinesisVideoStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisVideoStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKinesisVideoStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKinesisVideoStreamFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KinesisVideoStream =============================

// ==========================  START: KinesisConsumer =============================

type KinesisConsumer struct {
	Description   aws.KinesisConsumerDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type KinesisConsumerHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  KinesisConsumer `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type KinesisConsumerHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []KinesisConsumerHit `json:"hits"`
}

type KinesisConsumerSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  KinesisConsumerHits `json:"hits"`
}

type KinesisConsumerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisConsumerPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisConsumerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesis_consumer", filters, limit)
	if err != nil {
		return KinesisConsumerPaginator{}, err
	}

	p := KinesisConsumerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisConsumerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisConsumerPaginator) NextPage(ctx context.Context) ([]KinesisConsumer, error) {
	var response KinesisConsumerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisConsumer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisConsumerFilters = map[string]string{
	"akas":                        "description.Consumer.ConsumerARN",
	"consumer_arn":                "description.Consumer.ConsumerARN",
	"consumer_creation_timestamp": "description.Consumer.ConsumerCreationTimestamp",
	"consumer_name":               "description.Consumer.ConsumerName",
	"consumer_status":             "description.Consumer.ConsumerStatus",
	"kaytu_account_id":            "metadata.SourceID",
	"stream_arn":                  "description.StreamARN",
	"title":                       "description.Consumer.ConsumerName",
}

func ListKinesisConsumer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisConsumer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKinesisConsumerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKinesisConsumerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKinesisConsumerFilters = map[string]string{
	"akas":                        "description.Consumer.ConsumerARN",
	"consumer_arn":                "description.Consumer.ConsumerARN",
	"consumer_creation_timestamp": "description.Consumer.ConsumerCreationTimestamp",
	"consumer_name":               "description.Consumer.ConsumerName",
	"consumer_status":             "description.Consumer.ConsumerStatus",
	"kaytu_account_id":            "metadata.SourceID",
	"stream_arn":                  "description.StreamARN",
	"title":                       "description.Consumer.ConsumerName",
}

func GetKinesisConsumer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisConsumer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKinesisConsumerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKinesisConsumerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KinesisConsumer =============================

// ==========================  START: KinesisAnalyticsV2Application =============================

type KinesisAnalyticsV2Application struct {
	Description   aws.KinesisAnalyticsV2ApplicationDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type KinesisAnalyticsV2ApplicationHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  KinesisAnalyticsV2Application `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type KinesisAnalyticsV2ApplicationHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []KinesisAnalyticsV2ApplicationHit `json:"hits"`
}

type KinesisAnalyticsV2ApplicationSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  KinesisAnalyticsV2ApplicationHits `json:"hits"`
}

type KinesisAnalyticsV2ApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisAnalyticsV2ApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisAnalyticsV2ApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesisanalyticsv2_application", filters, limit)
	if err != nil {
		return KinesisAnalyticsV2ApplicationPaginator{}, err
	}

	p := KinesisAnalyticsV2ApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisAnalyticsV2ApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisAnalyticsV2ApplicationPaginator) NextPage(ctx context.Context) ([]KinesisAnalyticsV2Application, error) {
	var response KinesisAnalyticsV2ApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisAnalyticsV2Application
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisAnalyticsV2ApplicationFilters = map[string]string{
	"akas":                                    "description.Application.ApplicationARN",
	"application_arn":                         "description.Application.ApplicationARN",
	"application_configuration_description":   "description.Application.ApplicationConfigurationDescription",
	"application_description":                 "description.Application.ApplicationDescription",
	"application_name":                        "description.Application.ApplicationName",
	"application_status":                      "description.Application.ApplicationStatus",
	"application_version_id":                  "description.Application.ApplicationVersionId",
	"cloud_watch_logging_option_descriptions": "description.Application.CloudWatchLoggingOptionDescriptions",
	"create_timestamp":                        "description.Application.CreateTimestamp",
	"kaytu_account_id":                        "metadata.SourceID",
	"last_update_timestamp":                   "description.Application.LastUpdateTimestamp",
	"runtime_environment":                     "description.Application.RuntimeEnvironment",
	"service_execution_role":                  "description.Application.ServiceExecutionRole",
	"tags":                                    "description.Tags",
	"tags_src":                                "description.Tags",
	"title":                                   "description.Application.ApplicationName",
}

func ListKinesisAnalyticsV2Application(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisAnalyticsV2Application")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKinesisAnalyticsV2ApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKinesisAnalyticsV2ApplicationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKinesisAnalyticsV2ApplicationFilters = map[string]string{
	"akas":                                    "description.Application.ApplicationARN",
	"application_arn":                         "description.Application.ApplicationARN",
	"application_configuration_description":   "description.Application.ApplicationConfigurationDescription",
	"application_description":                 "description.Application.ApplicationDescription",
	"application_name":                        "description.Application.ApplicationName",
	"application_status":                      "description.Application.ApplicationStatus",
	"application_version_id":                  "description.Application.ApplicationVersionId",
	"cloud_watch_logging_option_descriptions": "description.Application.CloudWatchLoggingOptionDescriptions",
	"create_timestamp":                        "description.Application.CreateTimestamp",
	"kaytu_account_id":                        "metadata.SourceID",
	"last_update_timestamp":                   "description.Application.LastUpdateTimestamp",
	"runtime_environment":                     "description.Application.RuntimeEnvironment",
	"service_execution_role":                  "description.Application.ServiceExecutionRole",
	"tags":                                    "description.Tags",
	"tags_src":                                "description.Tags",
	"title":                                   "description.Application.ApplicationName",
}

func GetKinesisAnalyticsV2Application(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisAnalyticsV2Application")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKinesisAnalyticsV2ApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKinesisAnalyticsV2ApplicationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KinesisAnalyticsV2Application =============================

// ==========================  START: GlacierVault =============================

type GlacierVault struct {
	Description   aws.GlacierVaultDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type GlacierVaultHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GlacierVault  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GlacierVaultHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GlacierVaultHit `json:"hits"`
}

type GlacierVaultSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  GlacierVaultHits `json:"hits"`
}

type GlacierVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlacierVaultPaginator(filters []essdk.BoolFilter, limit *int64) (GlacierVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glacier_vault", filters, limit)
	if err != nil {
		return GlacierVaultPaginator{}, err
	}

	p := GlacierVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlacierVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlacierVaultPaginator) NextPage(ctx context.Context) ([]GlacierVault, error) {
	var response GlacierVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlacierVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlacierVaultFilters = map[string]string{
	"akas":                  "description.Vault.VaultARN",
	"creation_date":         "description.Vault.CreationDate",
	"kaytu_account_id":      "metadata.SourceID",
	"last_inventory_date":   "description.Vault.LastInventoryDate",
	"number_of_archives":    "description.Vault.NumberOfArchives",
	"policy":                "description.AccessPolicy.Policy",
	"policy_std":            "description.AccessPolicy.Policy",
	"size_in_bytes":         "description.Vault.SizeInBytes",
	"tags":                  "description.Tags",
	"tags_src":              "description.Tags",
	"title":                 "description.Vault.VaultName",
	"vault_arn":             "description.Vault.VaultARN",
	"vault_lock_policy":     "description.LockPolicy.Policy",
	"vault_lock_policy_std": "description.LockPolicy.Policy",
	"vault_name":            "description.Vault.VaultName",
}

func ListGlacierVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlacierVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlacierVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlacierVaultFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlacierVaultFilters = map[string]string{
	"akas":                  "description.Vault.VaultARN",
	"creation_date":         "description.Vault.CreationDate",
	"kaytu_account_id":      "metadata.SourceID",
	"last_inventory_date":   "description.Vault.LastInventoryDate",
	"number_of_archives":    "description.Vault.NumberOfArchives",
	"policy":                "description.AccessPolicy.Policy",
	"policy_std":            "description.AccessPolicy.Policy",
	"size_in_bytes":         "description.Vault.SizeInBytes",
	"tags":                  "description.Tags",
	"tags_src":              "description.Tags",
	"title":                 "description.Vault.VaultName",
	"vault_arn":             "description.Vault.VaultARN",
	"vault_lock_policy":     "description.LockPolicy.Policy",
	"vault_lock_policy_std": "description.LockPolicy.Policy",
	"vault_name":            "description.Vault.VaultName",
}

func GetGlacierVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlacierVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlacierVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlacierVaultFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlacierVault =============================

// ==========================  START: WorkspacesWorkspace =============================

type WorkspacesWorkspace struct {
	Description   aws.WorkspacesWorkspaceDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type WorkspacesWorkspaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  WorkspacesWorkspace `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type WorkspacesWorkspaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []WorkspacesWorkspaceHit `json:"hits"`
}

type WorkspacesWorkspaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  WorkspacesWorkspaceHits `json:"hits"`
}

type WorkspacesWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkspacesWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (WorkspacesWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_workspaces_workspace", filters, limit)
	if err != nil {
		return WorkspacesWorkspacePaginator{}, err
	}

	p := WorkspacesWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkspacesWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkspacesWorkspacePaginator) NextPage(ctx context.Context) ([]WorkspacesWorkspace, error) {
	var response WorkspacesWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkspacesWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkspacesWorkspaceFilters = map[string]string{
	"bundle_id":                      "description.Workspace.BundleId",
	"directory_id":                   "description.Workspace.DirectoryId",
	"error_code":                     "description.Workspace.ErrorCode",
	"error_message":                  "description.Workspace.ErrorMessage",
	"ip_address":                     "description.Workspace.IpAddress",
	"kaytu_account_id":               "metadata.SourceID",
	"modification_states":            "description.Workspace.ModificationStates",
	"name":                           "description.Workspace.ComputerName",
	"root_volume_encryption_enabled": "description.Workspace.RootVolumeEncryptionEnabled",
	"state":                          "description.Workspace.State",
	"subnet_id":                      "description.Workspace.SubnetId",
	"tags_src":                       "description.Tags",
	"title":                          "description.Workspace.ComputerName",
	"user_name":                      "description.Workspace.UserName",
	"user_volume_encryption_enabled": "description.Workspace.UserVolumeEncryptionEnabled",
	"volume_encryption_key":          "description.Workspace.VolumeEncryptionKey",
	"workspace_id":                   "description.Workspace.WorkspaceId",
	"workspace_properties":           "description.Workspace.WorkspaceProperties",
}

func ListWorkspacesWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkspacesWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWorkspacesWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listWorkspacesWorkspaceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWorkspacesWorkspaceFilters = map[string]string{
	"bundle_id":                      "description.Workspace.BundleId",
	"directory_id":                   "description.Workspace.DirectoryId",
	"error_code":                     "description.Workspace.ErrorCode",
	"error_message":                  "description.Workspace.ErrorMessage",
	"ip_address":                     "description.Workspace.IpAddress",
	"kaytu_account_id":               "metadata.SourceID",
	"modification_states":            "description.Workspace.ModificationStates",
	"name":                           "description.Workspace.ComputerName",
	"root_volume_encryption_enabled": "description.Workspace.RootVolumeEncryptionEnabled",
	"state":                          "description.Workspace.State",
	"subnet_id":                      "description.Workspace.SubnetId",
	"tags_src":                       "description.Tags",
	"title":                          "description.Workspace.ComputerName",
	"user_name":                      "description.Workspace.UserName",
	"user_volume_encryption_enabled": "description.Workspace.UserVolumeEncryptionEnabled",
	"volume_encryption_key":          "description.Workspace.VolumeEncryptionKey",
	"workspace_id":                   "description.Workspace.WorkspaceId",
	"workspace_properties":           "description.Workspace.WorkspaceProperties",
}

func GetWorkspacesWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkspacesWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWorkspacesWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getWorkspacesWorkspaceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WorkspacesWorkspace =============================

// ==========================  START: WorkspacesBundle =============================

type WorkspacesBundle struct {
	Description   aws.WorkspacesBundleDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type WorkspacesBundleHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  WorkspacesBundle `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type WorkspacesBundleHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []WorkspacesBundleHit `json:"hits"`
}

type WorkspacesBundleSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  WorkspacesBundleHits `json:"hits"`
}

type WorkspacesBundlePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkspacesBundlePaginator(filters []essdk.BoolFilter, limit *int64) (WorkspacesBundlePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_workspaces_bundle", filters, limit)
	if err != nil {
		return WorkspacesBundlePaginator{}, err
	}

	p := WorkspacesBundlePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkspacesBundlePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkspacesBundlePaginator) NextPage(ctx context.Context) ([]WorkspacesBundle, error) {
	var response WorkspacesBundleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkspacesBundle
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkspacesBundleFilters = map[string]string{
	"bundle_id":        "description.Bundle.BundleId",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Bundle.Name",
	"title":            "description.Bundle.Name",
}

func ListWorkspacesBundle(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkspacesBundle")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWorkspacesBundlePaginator(essdk.BuildFilter(d.KeyColumnQuals, listWorkspacesBundleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWorkspacesBundleFilters = map[string]string{
	"bundle_id":        "description.Bundle.BundleId",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Bundle.Name",
	"title":            "description.Bundle.Name",
}

func GetWorkspacesBundle(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkspacesBundle")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWorkspacesBundlePaginator(essdk.BuildFilter(d.KeyColumnQuals, getWorkspacesBundleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WorkspacesBundle =============================

// ==========================  START: KeyspacesKeyspace =============================

type KeyspacesKeyspace struct {
	Description   aws.KeyspacesKeyspaceDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type KeyspacesKeyspaceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  KeyspacesKeyspace `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type KeyspacesKeyspaceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []KeyspacesKeyspaceHit `json:"hits"`
}

type KeyspacesKeyspaceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  KeyspacesKeyspaceHits `json:"hits"`
}

type KeyspacesKeyspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyspacesKeyspacePaginator(filters []essdk.BoolFilter, limit *int64) (KeyspacesKeyspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_keyspaces_keyspace", filters, limit)
	if err != nil {
		return KeyspacesKeyspacePaginator{}, err
	}

	p := KeyspacesKeyspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyspacesKeyspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyspacesKeyspacePaginator) NextPage(ctx context.Context) ([]KeyspacesKeyspace, error) {
	var response KeyspacesKeyspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyspacesKeyspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyspacesKeyspaceFilters = map[string]string{
	"akas":             "description.Keyspace.ResourceArn",
	"kaytu_account_id": "metadata.SourceID",
	"keyspace_name":    "description.Keyspace.KeyspaceName",
	"resource_arn":     "description.Keyspace.ResourceArn",
	"title":            "description.Keyspace.KeyspaceName",
}

func ListKeyspacesKeyspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyspacesKeyspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKeyspacesKeyspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listKeyspacesKeyspaceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyspacesKeyspaceFilters = map[string]string{
	"akas":             "description.Keyspace.ResourceArn",
	"kaytu_account_id": "metadata.SourceID",
	"keyspace_name":    "description.Keyspace.KeyspaceName",
	"resource_arn":     "description.Keyspace.ResourceArn",
	"title":            "description.Keyspace.KeyspaceName",
}

func GetKeyspacesKeyspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyspacesKeyspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKeyspacesKeyspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getKeyspacesKeyspaceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyspacesKeyspace =============================

// ==========================  START: KeyspacesTable =============================

type KeyspacesTable struct {
	Description   aws.KeyspacesTableDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type KeyspacesTableHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  KeyspacesTable `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type KeyspacesTableHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []KeyspacesTableHit `json:"hits"`
}

type KeyspacesTableSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  KeyspacesTableHits `json:"hits"`
}

type KeyspacesTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyspacesTablePaginator(filters []essdk.BoolFilter, limit *int64) (KeyspacesTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_keyspaces_table", filters, limit)
	if err != nil {
		return KeyspacesTablePaginator{}, err
	}

	p := KeyspacesTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyspacesTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyspacesTablePaginator) NextPage(ctx context.Context) ([]KeyspacesTable, error) {
	var response KeyspacesTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyspacesTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyspacesTableFilters = map[string]string{
	"akas":             "description.Table.ResourceArn",
	"kaytu_account_id": "metadata.SourceID",
	"resource_arn":     "description.Table.ResourceArn",
	"table_name":       "description.Table.TableName",
	"title":            "description.Table.TableName",
}

func ListKeyspacesTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyspacesTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKeyspacesTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, listKeyspacesTableFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyspacesTableFilters = map[string]string{
	"akas":             "description.Table.ResourceArn",
	"kaytu_account_id": "metadata.SourceID",
	"resource_arn":     "description.Table.ResourceArn",
	"table_name":       "description.Table.TableName",
	"title":            "description.Table.TableName",
}

func GetKeyspacesTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyspacesTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKeyspacesTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, getKeyspacesTableFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyspacesTable =============================

// ==========================  START: GrafanaWorkspace =============================

type GrafanaWorkspace struct {
	Description   aws.GrafanaWorkspaceDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type GrafanaWorkspaceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  GrafanaWorkspace `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type GrafanaWorkspaceHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []GrafanaWorkspaceHit `json:"hits"`
}

type GrafanaWorkspaceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  GrafanaWorkspaceHits `json:"hits"`
}

type GrafanaWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGrafanaWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (GrafanaWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_grafana_workspace", filters, limit)
	if err != nil {
		return GrafanaWorkspacePaginator{}, err
	}

	p := GrafanaWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GrafanaWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GrafanaWorkspacePaginator) NextPage(ctx context.Context) ([]GrafanaWorkspace, error) {
	var response GrafanaWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GrafanaWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGrafanaWorkspaceFilters = map[string]string{
	"id":               "description.Workspace.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Workspace.Name",
	"tags":             "description.Workspace.Tags",
	"title":            "description.Workspace.Name",
}

func ListGrafanaWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGrafanaWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGrafanaWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listGrafanaWorkspaceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGrafanaWorkspaceFilters = map[string]string{
	"id":               "description.Workspace.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Workspace.Name",
	"tags":             "description.Workspace.Tags",
	"title":            "description.Workspace.Name",
}

func GetGrafanaWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGrafanaWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGrafanaWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getGrafanaWorkspaceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GrafanaWorkspace =============================

// ==========================  START: AMPWorkspace =============================

type AMPWorkspace struct {
	Description   aws.AMPWorkspaceDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type AMPWorkspaceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AMPWorkspace  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AMPWorkspaceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AMPWorkspaceHit `json:"hits"`
}

type AMPWorkspaceSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  AMPWorkspaceHits `json:"hits"`
}

type AMPWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAMPWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (AMPWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_amp_workspace", filters, limit)
	if err != nil {
		return AMPWorkspacePaginator{}, err
	}

	p := AMPWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AMPWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AMPWorkspacePaginator) NextPage(ctx context.Context) ([]AMPWorkspace, error) {
	var response AMPWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AMPWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAMPWorkspaceFilters = map[string]string{
	"akas":             "description.Workspace.Arn",
	"arn":              "description.Workspace.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"tags":             "description.Workspace.Tags",
	"title":            "description.Workspace.WorkspaceId",
	"workspace_id":     "description.Workspace.WorkspaceId",
}

func ListAMPWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAMPWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAMPWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listAMPWorkspaceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAMPWorkspaceFilters = map[string]string{
	"akas":             "description.Workspace.Arn",
	"arn":              "description.Workspace.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"tags":             "description.Workspace.Tags",
	"title":            "description.Workspace.WorkspaceId",
	"workspace_id":     "description.Workspace.WorkspaceId",
}

func GetAMPWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAMPWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAMPWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getAMPWorkspaceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AMPWorkspace =============================

// ==========================  START: KafkaCluster =============================

type KafkaCluster struct {
	Description   aws.KafkaClusterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type KafkaClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KafkaCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KafkaClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KafkaClusterHit `json:"hits"`
}

type KafkaClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  KafkaClusterHits `json:"hits"`
}

type KafkaClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKafkaClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KafkaClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kafka_cluster", filters, limit)
	if err != nil {
		return KafkaClusterPaginator{}, err
	}

	p := KafkaClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KafkaClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KafkaClusterPaginator) NextPage(ctx context.Context) ([]KafkaCluster, error) {
	var response KafkaClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KafkaCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKafkaClusterFilters = map[string]string{
	"akas":             "description.Cluster.ClusterArn",
	"arn":              "description.Cluster.ClusterArn",
	"cluster_name":     "description.Cluster.ClusterName",
	"kaytu_account_id": "metadata.SourceID",
	"tags":             "description.Cluster.Tags",
	"title":            "description.Cluster.ClusterName",
}

func ListKafkaCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKafkaCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKafkaClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKafkaClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKafkaClusterFilters = map[string]string{
	"akas":             "description.Cluster.ClusterArn",
	"arn":              "description.Cluster.ClusterArn",
	"cluster_name":     "description.Cluster.ClusterName",
	"kaytu_account_id": "metadata.SourceID",
	"tags":             "description.Cluster.Tags",
	"title":            "description.Cluster.ClusterName",
}

func GetKafkaCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKafkaCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKafkaClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKafkaClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KafkaCluster =============================

// ==========================  START: MWAAEnvironment =============================

type MWAAEnvironment struct {
	Description   aws.MWAAEnvironmentDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type MWAAEnvironmentHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  MWAAEnvironment `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type MWAAEnvironmentHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []MWAAEnvironmentHit `json:"hits"`
}

type MWAAEnvironmentSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  MWAAEnvironmentHits `json:"hits"`
}

type MWAAEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMWAAEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (MWAAEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mwaa_environment", filters, limit)
	if err != nil {
		return MWAAEnvironmentPaginator{}, err
	}

	p := MWAAEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MWAAEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MWAAEnvironmentPaginator) NextPage(ctx context.Context) ([]MWAAEnvironment, error) {
	var response MWAAEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MWAAEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMWAAEnvironmentFilters = map[string]string{
	"akas":             "description.Environment.Arn",
	"arn":              "description.Environment.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Environment.Name",
	"tags":             "description.Environment.Tags",
	"title":            "description.Environment.Name",
}

func ListMWAAEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMWAAEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMWAAEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMWAAEnvironmentFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMWAAEnvironmentFilters = map[string]string{
	"akas":             "description.Environment.Arn",
	"arn":              "description.Environment.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Environment.Name",
	"tags":             "description.Environment.Tags",
	"title":            "description.Environment.Name",
}

func GetMWAAEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMWAAEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMWAAEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMWAAEnvironmentFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MWAAEnvironment =============================

// ==========================  START: MemoryDbCluster =============================

type MemoryDbCluster struct {
	Description   aws.MemoryDbClusterDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type MemoryDbClusterHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  MemoryDbCluster `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type MemoryDbClusterHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []MemoryDbClusterHit `json:"hits"`
}

type MemoryDbClusterSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  MemoryDbClusterHits `json:"hits"`
}

type MemoryDbClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMemoryDbClusterPaginator(filters []essdk.BoolFilter, limit *int64) (MemoryDbClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_memorydb_cluster", filters, limit)
	if err != nil {
		return MemoryDbClusterPaginator{}, err
	}

	p := MemoryDbClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MemoryDbClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MemoryDbClusterPaginator) NextPage(ctx context.Context) ([]MemoryDbCluster, error) {
	var response MemoryDbClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MemoryDbCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMemoryDbClusterFilters = map[string]string{
	"akas":             "description.Cluster.ARN",
	"arn":              "description.Cluster.ARN",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Cluster.Name",
	"title":            "description.Cluster.Name",
}

func ListMemoryDbCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMemoryDbCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMemoryDbClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMemoryDbClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMemoryDbClusterFilters = map[string]string{
	"akas":             "description.Cluster.ARN",
	"arn":              "description.Cluster.ARN",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Cluster.Name",
	"title":            "description.Cluster.Name",
}

func GetMemoryDbCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMemoryDbCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMemoryDbClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMemoryDbClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MemoryDbCluster =============================

// ==========================  START: MQBroker =============================

type MQBroker struct {
	Description   aws.MQBrokerDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type MQBrokerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MQBroker      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MQBrokerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []MQBrokerHit     `json:"hits"`
}

type MQBrokerSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  MQBrokerHits `json:"hits"`
}

type MQBrokerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMQBrokerPaginator(filters []essdk.BoolFilter, limit *int64) (MQBrokerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mq_broker", filters, limit)
	if err != nil {
		return MQBrokerPaginator{}, err
	}

	p := MQBrokerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MQBrokerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MQBrokerPaginator) NextPage(ctx context.Context) ([]MQBroker, error) {
	var response MQBrokerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MQBroker
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMQBrokerFilters = map[string]string{
	"akas":             "description.Broker.BrokerArn",
	"broker_arn":       "description.Broker.BrokerArn",
	"broker_id":        "description.Broker.BrokerId",
	"broker_name":      "description.Broker.BrokerName",
	"kaytu_account_id": "metadata.SourceID",
	"tags":             "description.Tags",
	"title":            "description.Broker.BrokerName",
}

func ListMQBroker(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMQBroker")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMQBrokerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMQBrokerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMQBrokerFilters = map[string]string{
	"akas":             "description.Broker.BrokerArn",
	"broker_arn":       "description.Broker.BrokerArn",
	"broker_id":        "description.Broker.BrokerId",
	"broker_name":      "description.Broker.BrokerName",
	"kaytu_account_id": "metadata.SourceID",
	"tags":             "description.Tags",
	"title":            "description.Broker.BrokerName",
}

func GetMQBroker(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMQBroker")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMQBrokerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMQBrokerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MQBroker =============================

// ==========================  START: NeptuneDatabase =============================

type NeptuneDatabase struct {
	Description   aws.NeptuneDatabaseDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type NeptuneDatabaseHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  NeptuneDatabase `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type NeptuneDatabaseHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []NeptuneDatabaseHit `json:"hits"`
}

type NeptuneDatabaseSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  NeptuneDatabaseHits `json:"hits"`
}

type NeptuneDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNeptuneDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (NeptuneDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_neptune_database", filters, limit)
	if err != nil {
		return NeptuneDatabasePaginator{}, err
	}

	p := NeptuneDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NeptuneDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NeptuneDatabasePaginator) NextPage(ctx context.Context) ([]NeptuneDatabase, error) {
	var response NeptuneDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NeptuneDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNeptuneDatabaseFilters = map[string]string{
	"akas":                   "description.Database.DBInstanceArn",
	"db_instance_arn":        "description.Database.DBInstanceArn",
	"db_instance_identifier": "description.Database.DBInstanceIdentifier",
	"db_name":                "description.Database.DBName",
	"kaytu_account_id":       "metadata.SourceID",
	"title":                  "description.Database.DBName",
}

func ListNeptuneDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNeptuneDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNeptuneDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, listNeptuneDatabaseFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNeptuneDatabaseFilters = map[string]string{
	"akas":                   "description.Database.DBInstanceArn",
	"db_instance_arn":        "description.Database.DBInstanceArn",
	"db_instance_identifier": "description.Database.DBInstanceIdentifier",
	"db_name":                "description.Database.DBName",
	"kaytu_account_id":       "metadata.SourceID",
	"title":                  "description.Database.DBName",
}

func GetNeptuneDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNeptuneDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNeptuneDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, getNeptuneDatabaseFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NeptuneDatabase =============================

// ==========================  START: NeptuneDatabaseCluster =============================

type NeptuneDatabaseCluster struct {
	Description   aws.NeptuneDatabaseClusterDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type NeptuneDatabaseClusterHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  NeptuneDatabaseCluster `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type NeptuneDatabaseClusterHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []NeptuneDatabaseClusterHit `json:"hits"`
}

type NeptuneDatabaseClusterSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  NeptuneDatabaseClusterHits `json:"hits"`
}

type NeptuneDatabaseClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNeptuneDatabaseClusterPaginator(filters []essdk.BoolFilter, limit *int64) (NeptuneDatabaseClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_neptune_dbcluster", filters, limit)
	if err != nil {
		return NeptuneDatabaseClusterPaginator{}, err
	}

	p := NeptuneDatabaseClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NeptuneDatabaseClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NeptuneDatabaseClusterPaginator) NextPage(ctx context.Context) ([]NeptuneDatabaseCluster, error) {
	var response NeptuneDatabaseClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NeptuneDatabaseCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNeptuneDatabaseClusterFilters = map[string]string{
	"akas":                                "description.Cluster.DBClusterArn",
	"allocated_storage":                   "description.Cluster.AllocatedStorage",
	"arn":                                 "description.Cluster.DBClusterArn",
	"associated_roles":                    "description.Cluster.AssociatedRoles",
	"automatic_restart_time":              "description.Cluster.AutomaticRestartTime",
	"availability_zones":                  "description.Cluster.AvailabilityZones",
	"backup_retention_period":             "description.Cluster.BackupRetentionPeriod",
	"clone_group_id":                      "description.Cluster.CloneGroupId",
	"cluster_create_time":                 "description.Cluster.ClusterCreateTime",
	"copy_tags_to_snapshot":               "description.Cluster.CopyTagsToSnapshot",
	"cross_account_clone":                 "description.Cluster.CrossAccountClone",
	"database_name":                       "description.Cluster.DatabaseName",
	"db_cluster_identifier":               "description.Cluster.DBClusterIdentifier",
	"db_cluster_members":                  "description.Cluster.DBClusterMembers",
	"db_cluster_parameter_group":          "description.Cluster.DBClusterParameterGroup",
	"db_cluster_resource_id":              "description.Cluster.DbClusterResourceId",
	"db_subnet_group":                     "description.Cluster.DBSubnetGroup",
	"deletion_protection":                 "description.Cluster.DeletionProtection",
	"earliest_restorable_time":            "description.Cluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.Cluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.Cluster.Endpoint",
	"engine":                              "description.Cluster.Engine",
	"engine_version":                      "description.Cluster.EngineVersion",
	"hosted_zone_id":                      "description.Cluster.HostedZoneId",
	"iam_database_authentication_enabled": "description.Cluster.IAMDatabaseAuthenticationEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.Cluster.KmsKeyId",
	"latest_restorable_time":              "description.Cluster.LatestRestorableTime",
	"multi_az":                            "description.Cluster.MultiAZ",
	"percent_progress":                    "description.Cluster.PercentProgress",
	"port":                                "description.Cluster.Port",
	"preferred_backup_window":             "description.Cluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.Cluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.Cluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.Cluster.ReaderEndpoint",
	"status":                              "description.Cluster.Status",
	"storage_encrypted":                   "description.Cluster.StorageEncrypted",
	"tags":                                "description.Tags",
	"tags_src":                            "description.Tags",
	"title":                               "description.Cluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.Cluster.VpcSecurityGroups",
}

func ListNeptuneDatabaseCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNeptuneDatabaseCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNeptuneDatabaseClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNeptuneDatabaseClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNeptuneDatabaseClusterFilters = map[string]string{
	"akas":                                "description.Cluster.DBClusterArn",
	"allocated_storage":                   "description.Cluster.AllocatedStorage",
	"arn":                                 "description.Cluster.DBClusterArn",
	"associated_roles":                    "description.Cluster.AssociatedRoles",
	"automatic_restart_time":              "description.Cluster.AutomaticRestartTime",
	"availability_zones":                  "description.Cluster.AvailabilityZones",
	"backup_retention_period":             "description.Cluster.BackupRetentionPeriod",
	"clone_group_id":                      "description.Cluster.CloneGroupId",
	"cluster_create_time":                 "description.Cluster.ClusterCreateTime",
	"copy_tags_to_snapshot":               "description.Cluster.CopyTagsToSnapshot",
	"cross_account_clone":                 "description.Cluster.CrossAccountClone",
	"database_name":                       "description.Cluster.DatabaseName",
	"db_cluster_identifier":               "description.Cluster.DBClusterIdentifier",
	"db_cluster_members":                  "description.Cluster.DBClusterMembers",
	"db_cluster_parameter_group":          "description.Cluster.DBClusterParameterGroup",
	"db_cluster_resource_id":              "description.Cluster.DbClusterResourceId",
	"db_instance_identifier":              "description.Database.DBInstanceIdentifier",
	"db_subnet_group":                     "description.Cluster.DBSubnetGroup",
	"deletion_protection":                 "description.Cluster.DeletionProtection",
	"earliest_restorable_time":            "description.Cluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.Cluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.Cluster.Endpoint",
	"engine":                              "description.Cluster.Engine",
	"engine_version":                      "description.Cluster.EngineVersion",
	"hosted_zone_id":                      "description.Cluster.HostedZoneId",
	"iam_database_authentication_enabled": "description.Cluster.IAMDatabaseAuthenticationEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"kms_key_id":                          "description.Cluster.KmsKeyId",
	"latest_restorable_time":              "description.Cluster.LatestRestorableTime",
	"multi_az":                            "description.Cluster.MultiAZ",
	"percent_progress":                    "description.Cluster.PercentProgress",
	"port":                                "description.Cluster.Port",
	"preferred_backup_window":             "description.Cluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.Cluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.Cluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.Cluster.ReaderEndpoint",
	"status":                              "description.Cluster.Status",
	"storage_encrypted":                   "description.Cluster.StorageEncrypted",
	"tags":                                "description.Tags",
	"tags_src":                            "description.Tags",
	"title":                               "description.Cluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.Cluster.VpcSecurityGroups",
}

func GetNeptuneDatabaseCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNeptuneDatabaseCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNeptuneDatabaseClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNeptuneDatabaseClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NeptuneDatabaseCluster =============================

// ==========================  START: OpenSearchDomain =============================

type OpenSearchDomain struct {
	Description   aws.OpenSearchDomainDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type OpenSearchDomainHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  OpenSearchDomain `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type OpenSearchDomainHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []OpenSearchDomainHit `json:"hits"`
}

type OpenSearchDomainSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  OpenSearchDomainHits `json:"hits"`
}

type OpenSearchDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOpenSearchDomainPaginator(filters []essdk.BoolFilter, limit *int64) (OpenSearchDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_opensearch_domain", filters, limit)
	if err != nil {
		return OpenSearchDomainPaginator{}, err
	}

	p := OpenSearchDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OpenSearchDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OpenSearchDomainPaginator) NextPage(ctx context.Context) ([]OpenSearchDomain, error) {
	var response OpenSearchDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OpenSearchDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOpenSearchDomainFilters = map[string]string{
	"akas":             "description.Domain.ARN",
	"arn":              "description.Domain.ARN",
	"domain_id":        "description.Domain.DomainId",
	"domain_name":      "description.Domain.DomainName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Domain.DomainName",
}

func ListOpenSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOpenSearchDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewOpenSearchDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, listOpenSearchDomainFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getOpenSearchDomainFilters = map[string]string{
	"akas":             "description.Domain.ARN",
	"arn":              "description.Domain.ARN",
	"domain_id":        "description.Domain.DomainId",
	"domain_name":      "description.Domain.DomainName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Domain.DomainName",
}

func GetOpenSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOpenSearchDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewOpenSearchDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, getOpenSearchDomainFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: OpenSearchDomain =============================

// ==========================  START: SESConfigurationSet =============================

type SESConfigurationSet struct {
	Description   aws.SESConfigurationSetDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type SESConfigurationSetHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  SESConfigurationSet `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type SESConfigurationSetHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []SESConfigurationSetHit `json:"hits"`
}

type SESConfigurationSetSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  SESConfigurationSetHits `json:"hits"`
}

type SESConfigurationSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSESConfigurationSetPaginator(filters []essdk.BoolFilter, limit *int64) (SESConfigurationSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ses_configurationset", filters, limit)
	if err != nil {
		return SESConfigurationSetPaginator{}, err
	}

	p := SESConfigurationSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SESConfigurationSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SESConfigurationSetPaginator) NextPage(ctx context.Context) ([]SESConfigurationSet, error) {
	var response SESConfigurationSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SESConfigurationSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSESConfigurationSetFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ConfigurationSet.Name",
	"title":            "description.ConfigurationSet.Name",
}

func ListSESConfigurationSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSESConfigurationSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSESConfigurationSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSESConfigurationSetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSESConfigurationSetFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ConfigurationSet.Name",
	"title":            "description.ConfigurationSet.Name",
}

func GetSESConfigurationSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSESConfigurationSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSESConfigurationSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSESConfigurationSetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SESConfigurationSet =============================

// ==========================  START: SESIdentity =============================

type SESIdentity struct {
	Description   aws.SESIdentityDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type SESIdentityHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SESIdentity   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SESIdentityHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SESIdentityHit  `json:"hits"`
}

type SESIdentitySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SESIdentityHits `json:"hits"`
}

type SESIdentityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSESIdentityPaginator(filters []essdk.BoolFilter, limit *int64) (SESIdentityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ses_identity", filters, limit)
	if err != nil {
		return SESIdentityPaginator{}, err
	}

	p := SESIdentityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SESIdentityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SESIdentityPaginator) NextPage(ctx context.Context) ([]SESIdentity, error) {
	var response SESIdentitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SESIdentity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSESIdentityFilters = map[string]string{
	"identity_name":    "description.Identity.Name",
	"identity_type":    "description.Identity.IdentityType",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Identity.Name",
}

func ListSESIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSESIdentity")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSESIdentityPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSESIdentityFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSESIdentityFilters = map[string]string{
	"identity_name":    "description.Identity.IdentityName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Identity.Name",
}

func GetSESIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSESIdentity")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSESIdentityPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSESIdentityFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SESIdentity =============================

// ==========================  START: CloudFormationStack =============================

type CloudFormationStack struct {
	Description   aws.CloudFormationStackDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type CloudFormationStackHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  CloudFormationStack `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type CloudFormationStackHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []CloudFormationStackHit `json:"hits"`
}

type CloudFormationStackSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  CloudFormationStackHits `json:"hits"`
}

type CloudFormationStackPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFormationStackPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFormationStackPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudformation_stack", filters, limit)
	if err != nil {
		return CloudFormationStackPaginator{}, err
	}

	p := CloudFormationStackPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFormationStackPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFormationStackPaginator) NextPage(ctx context.Context) ([]CloudFormationStack, error) {
	var response CloudFormationStackSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFormationStack
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFormationStackFilters = map[string]string{
	"akas":                          "description.Stack.StackId",
	"capabilities":                  "description.Stack.Capabilities",
	"creation_time":                 "description.Stack.CreationTime",
	"description":                   "description.Stack.Description",
	"disable_rollback":              "description.Stack.DisableRollback",
	"enable_termination_protection": "description.Stack.EnableTerminationProtection",
	"id":                            "description.Stack.StackId",
	"kaytu_account_id":              "metadata.SourceID",
	"last_updated_time":             "description.Stack.LastUpdatedTime",
	"name":                          "description.Stack.StackName",
	"notification_arns":             "description.Stack.NotificationARNs",
	"outputs":                       "description.Stack.Outputs",
	"parameters":                    "description.Stack.Parameters",
	"parent_id":                     "description.Stack.ParentId",
	"resources":                     "description.StackResources",
	"role_arn":                      "description.Stack.RoleARN",
	"rollback_configuration":        "description.Stack.RollbackConfiguration",
	"root_id":                       "description.Stack.RootId",
	"stack_drift_status":            "description.Stack.DriftInformation.StackDriftStatus",
	"status":                        "description.Stack.StackStatus",
	"tags_src":                      "description.Stack.Tags",
	"template_body":                 "description.StackTemplate.TemplateBody",
	"template_body_json":            "description.StackTemplate.TemplateBody",
	"title":                         "description.Stack.StackName",
}

func ListCloudFormationStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFormationStack")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFormationStackPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFormationStackFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFormationStackFilters = map[string]string{
	"akas":                          "description.Stack.StackId",
	"capabilities":                  "description.Stack.Capabilities",
	"creation_time":                 "description.Stack.CreationTime",
	"description":                   "description.Stack.Description",
	"disable_rollback":              "description.Stack.DisableRollback",
	"enable_termination_protection": "description.Stack.EnableTerminationProtection",
	"id":                            "description.Stack.StackId",
	"kaytu_account_id":              "metadata.SourceID",
	"last_updated_time":             "description.Stack.LastUpdatedTime",
	"name":                          "description.Stack.StackName",
	"notification_arns":             "description.Stack.NotificationARNs",
	"outputs":                       "description.Stack.Outputs",
	"parameters":                    "description.Stack.Parameters",
	"parent_id":                     "description.Stack.ParentId",
	"resources":                     "description.StackResources",
	"role_arn":                      "description.Stack.RoleARN",
	"rollback_configuration":        "description.Stack.RollbackConfiguration",
	"root_id":                       "description.Stack.RootId",
	"stack_drift_status":            "description.Stack.DriftInformation.StackDriftStatus",
	"status":                        "description.Stack.StackStatus",
	"tags_src":                      "description.Stack.Tags",
	"template_body":                 "description.StackTemplate.TemplateBody",
	"template_body_json":            "description.StackTemplate.TemplateBody",
	"title":                         "description.Stack.StackName",
}

func GetCloudFormationStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFormationStack")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFormationStackPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFormationStackFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFormationStack =============================

// ==========================  START: CloudFormationStackSet =============================

type CloudFormationStackSet struct {
	Description   aws.CloudFormationStackSetDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CloudFormationStackSetHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CloudFormationStackSet `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CloudFormationStackSetHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CloudFormationStackSetHit `json:"hits"`
}

type CloudFormationStackSetSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CloudFormationStackSetHits `json:"hits"`
}

type CloudFormationStackSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFormationStackSetPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFormationStackSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudformation_stackset", filters, limit)
	if err != nil {
		return CloudFormationStackSetPaginator{}, err
	}

	p := CloudFormationStackSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFormationStackSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFormationStackSetPaginator) NextPage(ctx context.Context) ([]CloudFormationStackSet, error) {
	var response CloudFormationStackSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFormationStackSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFormationStackSetFilters = map[string]string{
	"akas":             "description.StackSet.StackSetARN",
	"arn":              "description.StackSet.StackSetARN",
	"id":               "description.StackSet.StackSetId",
	"kaytu_account_id": "metadata.SourceID",
	"stack_set_name":   "description.StackSet.StackSetName",
	"title":            "description.StackSet.StackSetName",
}

func ListCloudFormationStackSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFormationStackSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudFormationStackSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudFormationStackSetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudFormationStackSetFilters = map[string]string{
	"akas":             "description.StackSet.StackSetARN",
	"arn":              "description.StackSet.StackSetARN",
	"id":               "description.StackSet.StackSetId",
	"kaytu_account_id": "metadata.SourceID",
	"stack_set_name":   "description.StackSet.StackSetName",
	"title":            "description.StackSet.StackSetName",
}

func GetCloudFormationStackSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFormationStackSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudFormationStackSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudFormationStackSetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudFormationStackSet =============================

// ==========================  START: CodeCommitRepository =============================

type CodeCommitRepository struct {
	Description   aws.CodeCommitRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type CodeCommitRepositoryHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  CodeCommitRepository `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type CodeCommitRepositoryHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []CodeCommitRepositoryHit `json:"hits"`
}

type CodeCommitRepositorySearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  CodeCommitRepositoryHits `json:"hits"`
}

type CodeCommitRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeCommitRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (CodeCommitRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codecommit_repository", filters, limit)
	if err != nil {
		return CodeCommitRepositoryPaginator{}, err
	}

	p := CodeCommitRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeCommitRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeCommitRepositoryPaginator) NextPage(ctx context.Context) ([]CodeCommitRepository, error) {
	var response CodeCommitRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeCommitRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeCommitRepositoryFilters = map[string]string{
	"akas":               "description.Repository.Arn",
	"arn":                "description.Repository.Arn",
	"clone_url_http":     "description.Repository.CloneUrlHttp",
	"clone_url_ssh":      "description.Repository.CloneUrlSsh",
	"creation_date":      "description.Repository.CreationDate",
	"default_branch":     "description.Repository.DefaultBranch",
	"description":        "description.Repository.RepositoryDescription",
	"kaytu_account_id":   "metadata.SourceID",
	"last_modified_date": "description.Repository.LastModifiedDate",
	"repository_id":      "description.Repository.RepositoryId",
	"repository_name":    "description.Repository.RepositoryName",
	"tags":               "description.Tags",
	"title":              "description.Repository.RepositoryName",
}

func ListCodeCommitRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeCommitRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeCommitRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeCommitRepositoryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeCommitRepositoryFilters = map[string]string{
	"akas":               "description.Repository.Arn",
	"arn":                "description.Repository.Arn",
	"clone_url_http":     "description.Repository.CloneUrlHttp",
	"clone_url_ssh":      "description.Repository.CloneUrlSsh",
	"creation_date":      "description.Repository.CreationDate",
	"default_branch":     "description.Repository.DefaultBranch",
	"description":        "description.Repository.RepositoryDescription",
	"kaytu_account_id":   "metadata.SourceID",
	"last_modified_date": "description.Repository.LastModifiedDate",
	"repository_id":      "description.Repository.RepositoryId",
	"repository_name":    "description.Repository.RepositoryName",
	"tags":               "description.Tags",
	"title":              "description.Repository.RepositoryName",
}

func GetCodeCommitRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeCommitRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeCommitRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeCommitRepositoryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeCommitRepository =============================

// ==========================  START: CodePipelinePipeline =============================

type CodePipelinePipeline struct {
	Description   aws.CodePipelinePipelineDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type CodePipelinePipelineHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  CodePipelinePipeline `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type CodePipelinePipelineHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []CodePipelinePipelineHit `json:"hits"`
}

type CodePipelinePipelineSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  CodePipelinePipelineHits `json:"hits"`
}

type CodePipelinePipelinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodePipelinePipelinePaginator(filters []essdk.BoolFilter, limit *int64) (CodePipelinePipelinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codepipeline_pipeline", filters, limit)
	if err != nil {
		return CodePipelinePipelinePaginator{}, err
	}

	p := CodePipelinePipelinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodePipelinePipelinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodePipelinePipelinePaginator) NextPage(ctx context.Context) ([]CodePipelinePipeline, error) {
	var response CodePipelinePipelineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodePipelinePipeline
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodePipelinePipelineFilters = map[string]string{
	"akas":             "description.Metadata.PipelineArn",
	"arn":              "description.Metadata.PipelineArn",
	"artifact_stores":  "description.Pipeline.ArtifactStores",
	"created_at":       "description.Metadata.Created",
	"encryption_key":   "description.Pipeline.ArtifactStore.EncryptionKey",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Pipeline.Name",
	"role_arn":         "description.Pipeline.RoleArn",
	"stages":           "description.Pipeline.Stages",
	"tags_src":         "description.Tags",
	"title":            "description.Pipeline.Name",
	"updated_at":       "description.Metadata.Updated",
	"version":          "description.Pipeline.Version",
}

func ListCodePipelinePipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodePipelinePipeline")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodePipelinePipelinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodePipelinePipelineFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodePipelinePipelineFilters = map[string]string{
	"akas":             "description.Metadata.PipelineArn",
	"arn":              "description.Metadata.PipelineArn",
	"artifact_stores":  "description.Pipeline.ArtifactStores",
	"created_at":       "description.Metadata.Created",
	"encryption_key":   "description.Pipeline.ArtifactStore.EncryptionKey",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Pipeline.Name",
	"role_arn":         "description.Pipeline.RoleArn",
	"stages":           "description.Pipeline.Stages",
	"tags_src":         "description.Tags",
	"title":            "description.Pipeline.Name",
	"updated_at":       "description.Metadata.Updated",
	"version":          "description.Pipeline.Version",
}

func GetCodePipelinePipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodePipelinePipeline")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodePipelinePipelinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodePipelinePipelineFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodePipelinePipeline =============================

// ==========================  START: DirectoryServiceDirectory =============================

type DirectoryServiceDirectory struct {
	Description   aws.DirectoryServiceDirectoryDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type DirectoryServiceDirectoryHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  DirectoryServiceDirectory `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type DirectoryServiceDirectoryHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []DirectoryServiceDirectoryHit `json:"hits"`
}

type DirectoryServiceDirectorySearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  DirectoryServiceDirectoryHits `json:"hits"`
}

type DirectoryServiceDirectoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectoryServiceDirectoryPaginator(filters []essdk.BoolFilter, limit *int64) (DirectoryServiceDirectoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directoryservice_directory", filters, limit)
	if err != nil {
		return DirectoryServiceDirectoryPaginator{}, err
	}

	p := DirectoryServiceDirectoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectoryServiceDirectoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectoryServiceDirectoryPaginator) NextPage(ctx context.Context) ([]DirectoryServiceDirectory, error) {
	var response DirectoryServiceDirectorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectoryServiceDirectory
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectoryServiceDirectoryFilters = map[string]string{
	"access_url":                           "description.Directory.AccessUrl",
	"alias":                                "description.Directory.Alias",
	"connect_settings":                     "description.Directory.ConnectSettings",
	"description":                          "description.Directory.Description",
	"desired_number_of_domain_controllers": "description.Directory.DesiredNumberOfDomainControllers",
	"directory_id":                         "description.Directory.DirectoryId",
	"dns_ip_addrs":                         "description.Directory.DnsIpAddrs",
	"edition":                              "description.Directory.Edition",
	"kaytu_account_id":                     "metadata.SourceID",
	"launch_time":                          "description.Directory.LaunchTime",
	"name":                                 "description.Directory.Name",
	"owner_directory_description":          "description.Directory.OwnerDirectoryDescription",
	"radius_settings":                      "description.Directory.RadiusSettings",
	"radius_status":                        "description.Directory.RadiusStatus",
	"regions_info":                         "description.Directory.RegionsInfo",
	"share_method":                         "description.Directory.ShareMethod",
	"share_notes":                          "description.Directory.ShareNotes",
	"share_status":                         "description.Directory.ShareStatus",
	"short_name":                           "description.Directory.ShortName",
	"size":                                 "description.Directory.Size",
	"sso_enabled":                          "description.Directory.SsoEnabled",
	"stage":                                "description.Directory.Stage",
	"stage_last_updated_date_time":         "description.Directory.StageLastUpdatedDateTime",
	"stage_reason":                         "description.Directory.StageReason",
	"tags_src":                             "description.Tags",
	"title":                                "description.Directory.Name",
	"type":                                 "description.Directory.Type",
	"vpc_settings":                         "description.Directory.VpcSettings",
}

func ListDirectoryServiceDirectory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectoryServiceDirectory")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDirectoryServiceDirectoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDirectoryServiceDirectoryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDirectoryServiceDirectoryFilters = map[string]string{
	"access_url":                           "description.Directory.AccessUrl",
	"alias":                                "description.Directory.Alias",
	"connect_settings":                     "description.Directory.ConnectSettings",
	"description":                          "description.Directory.Description",
	"desired_number_of_domain_controllers": "description.Directory.DesiredNumberOfDomainControllers",
	"directory_id":                         "description.Directory.DirectoryId",
	"dns_ip_addrs":                         "description.Directory.DnsIpAddrs",
	"edition":                              "description.Directory.Edition",
	"kaytu_account_id":                     "metadata.SourceID",
	"launch_time":                          "description.Directory.LaunchTime",
	"name":                                 "description.Directory.DirectoryId",
	"owner_directory_description":          "description.Directory.OwnerDirectoryDescription",
	"radius_settings":                      "description.Directory.RadiusSettings",
	"radius_status":                        "description.Directory.RadiusStatus",
	"regions_info":                         "description.Directory.RegionsInfo",
	"share_method":                         "description.Directory.ShareMethod",
	"share_notes":                          "description.Directory.ShareNotes",
	"share_status":                         "description.Directory.ShareStatus",
	"short_name":                           "description.Directory.ShortName",
	"size":                                 "description.Directory.Size",
	"sso_enabled":                          "description.Directory.SsoEnabled",
	"stage":                                "description.Directory.Stage",
	"stage_last_updated_date_time":         "description.Directory.StageLastUpdatedDateTime",
	"stage_reason":                         "description.Directory.StageReason",
	"tags_src":                             "description.Tags",
	"title":                                "description.Directory.Name",
	"type":                                 "description.Directory.Type",
	"vpc_settings":                         "description.Directory.VpcSettings",
}

func GetDirectoryServiceDirectory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectoryServiceDirectory")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDirectoryServiceDirectoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDirectoryServiceDirectoryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DirectoryServiceDirectory =============================

// ==========================  START: WAFRule =============================

type WAFRule struct {
	Description   aws.WAFRuleDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type WAFRuleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFRule       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFRuleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFRuleHit      `json:"hits"`
}

type WAFRuleSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  WAFRuleHits `json:"hits"`
}

type WAFRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRulePaginator(filters []essdk.BoolFilter, limit *int64) (WAFRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_waf_rule", filters, limit)
	if err != nil {
		return WAFRulePaginator{}, err
	}

	p := WAFRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRulePaginator) NextPage(ctx context.Context) ([]WAFRule, error) {
	var response WAFRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRuleFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"metric_name":      "description.Rule.MetricName",
	"name":             "description.Rule.Name",
	"predicates":       "description.Rule.Predicates",
	"rule_id":          "description.Rule.RuleId",
	"tags_src":         "description.Tags",
	"title":            "description.Rule.Name",
}

func ListWAFRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFRuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFRuleFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"metric_name":      "description.Rule.MetricName",
	"name":             "description.Rule.Name",
	"predicates":       "description.Rule.Predicates",
	"rule_id":          "description.Rule.RuleId",
	"tags_src":         "description.Tags",
	"title":            "description.Rule.Name",
}

func GetWAFRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFRuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFRule =============================

// ==========================  START: WAFRegionalRule =============================

type WAFRegionalRule struct {
	Description   aws.WAFRegionalRuleDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type WAFRegionalRuleHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  WAFRegionalRule `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type WAFRegionalRuleHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []WAFRegionalRuleHit `json:"hits"`
}

type WAFRegionalRuleSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  WAFRegionalRuleHits `json:"hits"`
}

type WAFRegionalRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRegionalRulePaginator(filters []essdk.BoolFilter, limit *int64) (WAFRegionalRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafregional_rule", filters, limit)
	if err != nil {
		return WAFRegionalRulePaginator{}, err
	}

	p := WAFRegionalRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRegionalRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRegionalRulePaginator) NextPage(ctx context.Context) ([]WAFRegionalRule, error) {
	var response WAFRegionalRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRegionalRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRegionalRuleFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Rule.Name",
	"rule_id":          "description.Rule.RuleId",
	"title":            "description.Rule.Name",
}

func ListWAFRegionalRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRegionalRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFRegionalRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFRegionalRuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFRegionalRuleFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Rule.Name",
	"rule_id":          "description.Rule.RuleId",
	"title":            "description.Rule.Name",
}

func GetWAFRegionalRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRegionalRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFRegionalRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFRegionalRuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFRegionalRule =============================

// ==========================  START: WAFRateBasedRule =============================

type WAFRateBasedRule struct {
	Description   aws.WAFRateBasedRuleDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type WAFRateBasedRuleHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  WAFRateBasedRule `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type WAFRateBasedRuleHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []WAFRateBasedRuleHit `json:"hits"`
}

type WAFRateBasedRuleSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  WAFRateBasedRuleHits `json:"hits"`
}

type WAFRateBasedRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRateBasedRulePaginator(filters []essdk.BoolFilter, limit *int64) (WAFRateBasedRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_waf_ratebasedrule", filters, limit)
	if err != nil {
		return WAFRateBasedRulePaginator{}, err
	}

	p := WAFRateBasedRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRateBasedRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRateBasedRulePaginator) NextPage(ctx context.Context) ([]WAFRateBasedRule, error) {
	var response WAFRateBasedRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRateBasedRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRateBasedRuleFilters = map[string]string{
	"akas":             "description.ARN",
	"kaytu_account_id": "metadata.SourceID",
	"metric_name":      "description.Rule.MetricName",
	"name":             "description.Rule.Name",
	"predicates":       "description.Rule.MatchPredicates",
	"rate_key":         "description.Rule.RateKey",
	"rate_limit":       "description.Rule.RateLimit",
	"rule_id":          "description.Rule.RuleId",
	"tags_src":         "description.Tags.TagList",
	"title":            "description.Rule.Name",
}

func ListWAFRateBasedRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRateBasedRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFRateBasedRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFRateBasedRuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFRateBasedRuleFilters = map[string]string{
	"akas":             "description.ARN",
	"kaytu_account_id": "metadata.SourceID",
	"metric_name":      "description.Rule.MetricName",
	"name":             "description.Rule.Name",
	"predicates":       "description.Rule.MatchPredicates",
	"rate_key":         "description.Rule.RateKey",
	"rate_limit":       "description.Rule.RateLimit",
	"rule_id":          "description.Rule.RuleId",
	"tags_src":         "description.Tags.TagList",
	"title":            "description.Rule.Name",
}

func GetWAFRateBasedRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRateBasedRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFRateBasedRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFRateBasedRuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFRateBasedRule =============================

// ==========================  START: WAFWebAcl =============================

type WAFWebAcl struct {
	Description   aws.WAFWebAclDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type WAFWebAclHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFWebAcl     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFWebAclHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFWebAclHit    `json:"hits"`
}

type WAFWebAclSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  WAFWebAclHits `json:"hits"`
}

type WAFWebAclPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFWebAclPaginator(filters []essdk.BoolFilter, limit *int64) (WAFWebAclPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_waf_webacl", filters, limit)
	if err != nil {
		return WAFWebAclPaginator{}, err
	}

	p := WAFWebAclPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFWebAclPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFWebAclPaginator) NextPage(ctx context.Context) ([]WAFWebAcl, error) {
	var response WAFWebAclSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFWebAcl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFWebAclFilters = map[string]string{
	"akas":                  "description.WebACL.WebACLArn",
	"arn":                   "description.WebACL.WebACLArn",
	"default_action":        "description.WebACL.DefaultAction.Type",
	"kaytu_account_id":      "metadata.SourceID",
	"logging_configuration": "description.LoggingConfiguration",
	"metric_name":           "description.WebACL.MetricName",
	"name":                  "description.WebACL.Name",
	"rules":                 "description.WebACL.Rules",
	"tags":                  "description.Tags.TagList",
	"tags_src":              "description.Tags.TagList",
	"title":                 "description.WebACL.Name",
	"web_acl_id":            "description.WebACL.WebACLId",
}

func ListWAFWebAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFWebAcl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWAFWebAclPaginator(essdk.BuildFilter(d.KeyColumnQuals, listWAFWebAclFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWAFWebAclFilters = map[string]string{
	"akas":                  "description.WebACL.WebACLArn",
	"arn":                   "description.WebACL.WebACLArn",
	"default_action":        "description.WebACL.DefaultAction.Type",
	"kaytu_account_id":      "metadata.SourceID",
	"logging_configuration": "description.LoggingConfiguration",
	"metric_name":           "description.WebACL.MetricName",
	"name":                  "description.WebACL.Name",
	"rules":                 "description.WebACL.Rules",
	"tags":                  "description.Tags.TagList",
	"tags_src":              "description.Tags.TagList",
	"title":                 "description.WebACL.Name",
	"web_acl_id":            "description.WebACL.WebACLId",
}

func GetWAFWebAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFWebAcl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWAFWebAclPaginator(essdk.BuildFilter(d.KeyColumnQuals, getWAFWebAclFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WAFWebAcl =============================

// ==========================  START: WellArchitectedWorkload =============================

type WellArchitectedWorkload struct {
	Description   aws.WellArchitectedWorkloadDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type WellArchitectedWorkloadHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  WellArchitectedWorkload `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type WellArchitectedWorkloadHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []WellArchitectedWorkloadHit `json:"hits"`
}

type WellArchitectedWorkloadSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  WellArchitectedWorkloadHits `json:"hits"`
}

type WellArchitectedWorkloadPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedWorkloadPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedWorkloadPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_workload", filters, limit)
	if err != nil {
		return WellArchitectedWorkloadPaginator{}, err
	}

	p := WellArchitectedWorkloadPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedWorkloadPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedWorkloadPaginator) NextPage(ctx context.Context) ([]WellArchitectedWorkload, error) {
	var response WellArchitectedWorkloadSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedWorkload
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedWorkloadFilters = map[string]string{
	"account_ids":                         "description.Workload.AccountIds",
	"akas":                                "description.Workload.WorkloadArn",
	"architectural_design":                "description.Workload.ArchitecturalDesign",
	"aws_regions":                         "description.Workload.AwsRegions",
	"description":                         "description.Workload.Description",
	"environment":                         "description.Workload.Environment",
	"improvement_status":                  "description.Workload.ImprovementStatus",
	"industry":                            "description.Workload.Industry",
	"industry_type":                       "description.Workload.IndustryType",
	"is_review_owner_update_acknowledged": "description.Workload.IsReviewOwnerUpdateAcknowledged",
	"kaytu_account_id":                    "metadata.SourceID",
	"lenses":                              "description.Workload.Lenses",
	"non_aws_regions":                     "description.Workload.NonAwsRegions",
	"notes":                               "description.Workload.Notes",
	"owner":                               "description.Workload.Owner",
	"pillar_priorities":                   "description.Workload.PillarPriorities",
	"review_owner":                        "description.Workload.ReviewOwner",
	"review_restriction_date":             "description.Workload.ReviewRestrictionDate",
	"risk_counts":                         "description.Workload.RiskCounts",
	"share_invitation_id":                 "description.Workload.ShareInvitationId",
	"tags":                                "description.Workload.Tags",
	"title":                               "description.Workload.WorkloadName",
	"updated_at":                          "description.Workload.UpdatedAt",
	"workload_arn":                        "description.Workload.WorkloadArn",
	"workload_id":                         "description.Workload.WorkloadId",
	"workload_name":                       "description.Workload.WorkloadName",
}

func ListWellArchitectedWorkload(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedWorkload")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWellArchitectedWorkloadPaginator(essdk.BuildFilter(d.KeyColumnQuals, listWellArchitectedWorkloadFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWellArchitectedWorkloadFilters = map[string]string{
	"account_ids":                         "description.Workload.AccountIds",
	"akas":                                "description.Workload.WorkloadArn",
	"architectural_design":                "description.Workload.ArchitecturalDesign",
	"aws_regions":                         "description.Workload.AwsRegions",
	"description":                         "description.Workload.Description",
	"environment":                         "description.Workload.Environment",
	"improvement_status":                  "description.Workload.ImprovementStatus",
	"industry":                            "description.Workload.Industry",
	"industry_type":                       "description.Workload.IndustryType",
	"is_review_owner_update_acknowledged": "description.Workload.IsReviewOwnerUpdateAcknowledged",
	"kaytu_account_id":                    "metadata.SourceID",
	"lenses":                              "description.Workload.Lenses",
	"non_aws_regions":                     "description.Workload.NonAwsRegions",
	"notes":                               "description.Workload.Notes",
	"owner":                               "description.Workload.Owner",
	"pillar_priorities":                   "description.Workload.PillarPriorities",
	"review_owner":                        "description.Workload.ReviewOwner",
	"review_restriction_date":             "description.Workload.ReviewRestrictionDate",
	"risk_counts":                         "description.Workload.RiskCounts",
	"share_invitation_id":                 "description.Workload.ShareInvitationId",
	"tags":                                "description.Workload.Tags",
	"title":                               "description.Workload.WorkloadName",
	"updated_at":                          "description.Workload.UpdatedAt",
	"workload_arn":                        "description.Workload.WorkloadArn",
	"workload_id":                         "description.Workload.WorkloadId",
	"workload_name":                       "description.Workload.WorkloadName",
}

func GetWellArchitectedWorkload(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedWorkload")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedWorkloadPaginator(essdk.BuildFilter(d.KeyColumnQuals, getWellArchitectedWorkloadFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WellArchitectedWorkload =============================

// ==========================  START: Route53HostedZone =============================

type Route53HostedZone struct {
	Description   aws.Route53HostedZoneDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type Route53HostedZoneHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  Route53HostedZone `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type Route53HostedZoneHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []Route53HostedZoneHit `json:"hits"`
}

type Route53HostedZoneSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  Route53HostedZoneHits `json:"hits"`
}

type Route53HostedZonePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53HostedZonePaginator(filters []essdk.BoolFilter, limit *int64) (Route53HostedZonePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_hostedzone", filters, limit)
	if err != nil {
		return Route53HostedZonePaginator{}, err
	}

	p := Route53HostedZonePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53HostedZonePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53HostedZonePaginator) NextPage(ctx context.Context) ([]Route53HostedZone, error) {
	var response Route53HostedZoneSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53HostedZone
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53HostedZoneFilters = map[string]string{
	"caller_reference":           "description.HostedZone.CallerReference",
	"comment":                    "description.HostedZone.Config.Comment",
	"dnssec_key_signing_keys":    "description.DNSSec.KeySigningKeys",
	"dnssec_status":              "description.DNSSec.Status",
	"id":                         "description.ID",
	"kaytu_account_id":           "metadata.SourceID",
	"linked_service_description": "description.HostedZone.LinkedService.Description",
	"linked_service_principal":   "description.HostedZone.LinkedService.ServicePrincipal",
	"name":                       "description.HostedZone.Name",
	"private_zone":               "description.HostedZone.Config.PrivateZone",
	"query_logging_configs":      "description.QueryLoggingConfigs",
	"resource_record_set_count":  "description.HostedZone.ResourceRecordSetCount",
	"tags_src":                   "description.Tags",
	"title":                      "description.HostedZone.Name",
}

func ListRoute53HostedZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53HostedZone")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53HostedZonePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53HostedZoneFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53HostedZoneFilters = map[string]string{
	"caller_reference":           "description.HostedZone.CallerReference",
	"comment":                    "description.HostedZone.Config.Comment",
	"dnssec_key_signing_keys":    "description.DNSSec.KeySigningKeys",
	"dnssec_status":              "description.DNSSec.Status",
	"id":                         "description.ID",
	"kaytu_account_id":           "metadata.SourceID",
	"linked_service_description": "description.HostedZone.LinkedService.Description",
	"linked_service_principal":   "description.HostedZone.LinkedService.ServicePrincipal",
	"name":                       "description.HostedZone.Name",
	"private_zone":               "description.HostedZone.Config.PrivateZone",
	"query_logging_configs":      "description.QueryLoggingConfigs",
	"resource_record_set_count":  "description.HostedZone.ResourceRecordSetCount",
	"tags_src":                   "description.Tags",
	"title":                      "description.HostedZone.Name",
}

func GetRoute53HostedZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53HostedZone")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53HostedZonePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53HostedZoneFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53HostedZone =============================

// ==========================  START: Route53HealthCheck =============================

type Route53HealthCheck struct {
	Description   aws.Route53HealthCheckDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type Route53HealthCheckHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  Route53HealthCheck `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type Route53HealthCheckHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []Route53HealthCheckHit `json:"hits"`
}

type Route53HealthCheckSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  Route53HealthCheckHits `json:"hits"`
}

type Route53HealthCheckPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53HealthCheckPaginator(filters []essdk.BoolFilter, limit *int64) (Route53HealthCheckPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_healthcheck", filters, limit)
	if err != nil {
		return Route53HealthCheckPaginator{}, err
	}

	p := Route53HealthCheckPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53HealthCheckPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53HealthCheckPaginator) NextPage(ctx context.Context) ([]Route53HealthCheck, error) {
	var response Route53HealthCheckSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53HealthCheck
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53HealthCheckFilters = map[string]string{
	"caller_reference":                "description.HealthCheck.CallerReference",
	"cloud_watch_alarm_configuration": "description.HealthCheck.CloudWatchAlarmConfiguration",
	"health_check_config":             "description.HealthCheck.HealthCheckConfig",
	"health_check_status":             "description.Status.HealthCheckObservations",
	"health_check_version":            "description.HealthCheck.HealthCheckVersion",
	"id":                              "description.HealthCheck.Id",
	"kaytu_account_id":                "metadata.SourceID",
	"linked_service_description":      "description.HealthCheck.LinkedService.Description",
	"linked_service_principal":        "description.HealthCheck.LinkedService.ServicePrincipal",
	"tags":                            "description.Tags.ResourceTagSet.Tags",
	"tags_src":                        "description.Tags.ResourceTagSet.Tags",
	"title":                           "description.HealthCheck.Id",
}

func ListRoute53HealthCheck(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53HealthCheck")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53HealthCheckPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53HealthCheckFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53HealthCheckFilters = map[string]string{
	"caller_reference":                "description.HealthCheck.CallerReference",
	"cloud_watch_alarm_configuration": "description.HealthCheck.CloudWatchAlarmConfiguration",
	"health_check_config":             "description.HealthCheck.HealthCheckConfig",
	"health_check_status":             "description.Status.HealthCheckObservations",
	"health_check_version":            "description.HealthCheck.HealthCheckVersion",
	"id":                              "description.HealthCheck.Id",
	"kaytu_account_id":                "metadata.SourceID",
	"linked_service_description":      "description.HealthCheck.LinkedService.Description",
	"linked_service_principal":        "description.HealthCheck.LinkedService.ServicePrincipal",
	"tags":                            "description.Tags.ResourceTagSet.Tags",
	"tags_src":                        "description.Tags.ResourceTagSet.Tags",
	"title":                           "description.HealthCheck.Id",
}

func GetRoute53HealthCheck(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53HealthCheck")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53HealthCheckPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53HealthCheckFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53HealthCheck =============================

// ==========================  START: Route53ResolverResolverRule =============================

type Route53ResolverResolverRule struct {
	Description   aws.Route53ResolverResolverRuleDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type Route53ResolverResolverRuleHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  Route53ResolverResolverRule `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type Route53ResolverResolverRuleHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []Route53ResolverResolverRuleHit `json:"hits"`
}

type Route53ResolverResolverRuleSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  Route53ResolverResolverRuleHits `json:"hits"`
}

type Route53ResolverResolverRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53ResolverResolverRulePaginator(filters []essdk.BoolFilter, limit *int64) (Route53ResolverResolverRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53resolver_resolverrule", filters, limit)
	if err != nil {
		return Route53ResolverResolverRulePaginator{}, err
	}

	p := Route53ResolverResolverRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53ResolverResolverRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53ResolverResolverRulePaginator) NextPage(ctx context.Context) ([]Route53ResolverResolverRule, error) {
	var response Route53ResolverResolverRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53ResolverResolverRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53ResolverResolverRuleFilters = map[string]string{
	"akas":                       "description.ResolverRole.Arn",
	"arn":                        "description.ResolverRole.Arn",
	"creation_time":              "description.ResolverRole.CreationTime",
	"creator_request_id":         "description.ResolverRole.CreatorRequestId",
	"domain_name":                "description.ResolverRole.DomainName",
	"id":                         "description.ResolverRole.Id",
	"kaytu_account_id":           "metadata.SourceID",
	"modification_time":          "description.ResolverRole.ModificationTime",
	"name":                       "description.ResolverRole.Name",
	"owner_id":                   "description.ResolverRole.OwnerId",
	"resolver_endpoint_id":       "description.ResolverRole.ResolverEndpointId",
	"resolver_rule_associations": "description.RuleAssociations.ResolverRuleAssociations",
	"rule_type":                  "description.ResolverRole.RuleType",
	"share_status":               "description.ResolverRole.ShareStatus",
	"status":                     "description.ResolverRole.Status",
	"status_message":             "description.ResolverRole.StatusMessage",
	"tags":                       "description.Tags",
	"tags_src":                   "description.Tags",
	"target_ips":                 "description.ResolverRole.TargetIps",
	"title":                      "description.ResolverRole.Name",
}

func ListRoute53ResolverResolverRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53ResolverResolverRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53ResolverResolverRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53ResolverResolverRuleFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53ResolverResolverRuleFilters = map[string]string{
	"akas":                       "description.ResolverRole.Arn",
	"arn":                        "description.ResolverRole.Arn",
	"creation_time":              "description.ResolverRole.CreationTime",
	"creator_request_id":         "description.ResolverRole.CreatorRequestId",
	"domain_name":                "description.ResolverRole.DomainName",
	"id":                         "description.ResolverRole.Id",
	"kaytu_account_id":           "metadata.SourceID",
	"modification_time":          "description.ResolverRole.ModificationTime",
	"name":                       "description.ResolverRole.Name",
	"owner_id":                   "description.ResolverRole.OwnerId",
	"resolver_endpoint_id":       "description.ResolverRole.ResolverEndpointId",
	"resolver_rule_associations": "description.RuleAssociations.ResolverRuleAssociations",
	"rule_type":                  "description.ResolverRole.RuleType",
	"share_status":               "description.ResolverRole.ShareStatus",
	"status":                     "description.ResolverRole.Status",
	"status_message":             "description.ResolverRole.StatusMessage",
	"tags":                       "description.Tags",
	"tags_src":                   "description.Tags",
	"target_ips":                 "description.ResolverRole.TargetIps",
	"title":                      "description.ResolverRole.Name",
}

func GetRoute53ResolverResolverRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53ResolverResolverRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53ResolverResolverRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53ResolverResolverRuleFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53ResolverResolverRule =============================

// ==========================  START: Route53ResolverEndpoint =============================

type Route53ResolverEndpoint struct {
	Description   aws.Route53ResolverEndpointDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type Route53ResolverEndpointHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  Route53ResolverEndpoint `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type Route53ResolverEndpointHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []Route53ResolverEndpointHit `json:"hits"`
}

type Route53ResolverEndpointSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  Route53ResolverEndpointHits `json:"hits"`
}

type Route53ResolverEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53ResolverEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (Route53ResolverEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53resolver_resolverendpoint", filters, limit)
	if err != nil {
		return Route53ResolverEndpointPaginator{}, err
	}

	p := Route53ResolverEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53ResolverEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53ResolverEndpointPaginator) NextPage(ctx context.Context) ([]Route53ResolverEndpoint, error) {
	var response Route53ResolverEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53ResolverEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53ResolverEndpointFilters = map[string]string{
	"akas":               "description.ResolverEndpoint.Arn",
	"arn":                "description.ResolverEndpoint.Arn",
	"creation_time":      "description.ResolverEndpoint.CreationTime",
	"creator_request_id": "description.ResolverEndpoint.CreatorRequestId",
	"direction":          "description.ResolverEndpoint.Direction",
	"host_vpc_id":        "description.ResolverEndpoint.HostVPCId",
	"id":                 "description.ResolverEndpoint.Id",
	"ip_address_count":   "description.ResolverEndpoint.IpAddressCount",
	"ip_addresses":       "description.IpAddresses",
	"kaytu_account_id":   "metadata.SourceID",
	"modification_time":  "description.ResolverEndpoint.ModificationTime",
	"name":               "description.ResolverEndpoint.Name",
	"security_group_ids": "description.ResolverEndpoint.SecurityGroupIds",
	"status":             "description.ResolverEndpoint.Status",
	"status_message":     "description.ResolverEndpoint.StatusMessage",
	"tags":               "description.Tags",
	"tags_src":           "description.Tags",
	"title":              "description.ResolverEndpoint.Name",
}

func ListRoute53ResolverEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53ResolverEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53ResolverEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53ResolverEndpointFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53ResolverEndpointFilters = map[string]string{
	"akas":               "description.ResolverEndpoint.Arn",
	"arn":                "description.ResolverEndpoint.Arn",
	"creation_time":      "description.ResolverEndpoint.CreationTime",
	"creator_request_id": "description.ResolverEndpoint.CreatorRequestId",
	"direction":          "description.ResolverEndpoint.Direction",
	"host_vpc_id":        "description.ResolverEndpoint.HostVPCId",
	"id":                 "description.ResolverEndpoint.Id",
	"ip_address_count":   "description.ResolverEndpoint.IpAddressCount",
	"ip_addresses":       "description.IpAddresses",
	"kaytu_account_id":   "metadata.SourceID",
	"modification_time":  "description.ResolverEndpoint.ModificationTime",
	"name":               "description.ResolverEndpoint.Name",
	"security_group_ids": "description.ResolverEndpoint.SecurityGroupIds",
	"status":             "description.ResolverEndpoint.Status",
	"status_message":     "description.ResolverEndpoint.StatusMessage",
	"tags":               "description.Tags",
	"tags_src":           "description.Tags",
	"title":              "description.ResolverEndpoint.Name",
}

func GetRoute53ResolverEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53ResolverEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53ResolverEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53ResolverEndpointFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53ResolverEndpoint =============================

// ==========================  START: Route53Domain =============================

type Route53Domain struct {
	Description   aws.Route53DomainDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type Route53DomainHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Route53Domain `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type Route53DomainHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []Route53DomainHit `json:"hits"`
}

type Route53DomainSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  Route53DomainHits `json:"hits"`
}

type Route53DomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53DomainPaginator(filters []essdk.BoolFilter, limit *int64) (Route53DomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53domains_domain", filters, limit)
	if err != nil {
		return Route53DomainPaginator{}, err
	}

	p := Route53DomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53DomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53DomainPaginator) NextPage(ctx context.Context) ([]Route53Domain, error) {
	var response Route53DomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53Domain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53DomainFilters = map[string]string{
	"abuse_contact_email": "description.Domain.AbuseContactEmail",
	"abuse_contact_phone": "description.Domain.AbuseContactPhone",
	"admin_contact":       "description.Domain.AdminContact",
	"admin_privacy":       "description.Domain.AdminPrivacy",
	"akas":                "aRN",
	"arn":                 "aRN",
	"auto_renew":          "description.Domain.AutoRenew",
	"creation_date":       "description.Domain.CreationDate",
	"domain_name":         "description.Domain.DomainName",
	"expiration_date":     "description.Domain.ExpirationDate",
	"kaytu_account_id":    "metadata.SourceID",
	"nameservers":         "description.Domain.Nameservers",
	"registrant_contact":  "description.Domain.RegistrantContact",
	"registrant_privacy":  "description.Domain.RegistrantPrivacy",
	"registrar_name":      "description.Domain.RegistrarName",
	"registrar_url":       "description.Domain.RegistrarUrl",
	"registry_domain_id":  "description.Domain.RegistryDomainId",
	"reseller":            "description.Domain.Reseller",
	"status_list":         "description.Domain.StatusList",
	"tags":                "description.Tags",
	"tags_src":            "description.Tags",
	"tech_contact":        "description.Domain.TechContact",
	"tech_privacy":        "description.Domain.TechPrivacy",
	"title":               "description.Domain.DomainName",
	"transfer_lock":       "description.DomainSummary.TransferLock",
	"updated_date":        "description.Domain.UpdatedDate",
	"who_is_server":       "description.Domain.WhoIsServer",
}

func ListRoute53Domain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53Domain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53DomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53DomainFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53DomainFilters = map[string]string{
	"abuse_contact_email": "description.Domain.AbuseContactEmail",
	"abuse_contact_phone": "description.Domain.AbuseContactPhone",
	"admin_contact":       "description.Domain.AdminContact",
	"admin_privacy":       "description.Domain.AdminPrivacy",
	"akas":                "aRN",
	"arn":                 "aRN",
	"auto_renew":          "description.Domain.AutoRenew",
	"creation_date":       "description.Domain.CreationDate",
	"domain_name":         "description.Domain.DomainName",
	"expiration_date":     "description.Domain.ExpirationDate",
	"kaytu_account_id":    "metadata.SourceID",
	"nameservers":         "description.Domain.Nameservers",
	"registrant_contact":  "description.Domain.RegistrantContact",
	"registrant_privacy":  "description.Domain.RegistrantPrivacy",
	"registrar_name":      "description.Domain.RegistrarName",
	"registrar_url":       "description.Domain.RegistrarUrl",
	"registry_domain_id":  "description.Domain.RegistryDomainId",
	"reseller":            "description.Domain.Reseller",
	"status_list":         "description.Domain.StatusList",
	"tags":                "description.Tags",
	"tags_src":            "description.Tags",
	"tech_contact":        "description.Domain.TechContact",
	"tech_privacy":        "description.Domain.TechPrivacy",
	"title":               "description.Domain.DomainName",
	"transfer_lock":       "description.DomainSummary.TransferLock",
	"updated_date":        "description.Domain.UpdatedDate",
	"who_is_server":       "description.Domain.WhoIsServer",
}

func GetRoute53Domain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53Domain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53DomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53DomainFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53Domain =============================

// ==========================  START: Route53Record =============================

type Route53Record struct {
	Description   aws.Route53RecordDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type Route53RecordHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Route53Record `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type Route53RecordHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []Route53RecordHit `json:"hits"`
}

type Route53RecordSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  Route53RecordHits `json:"hits"`
}

type Route53RecordPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53RecordPaginator(filters []essdk.BoolFilter, limit *int64) (Route53RecordPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_record", filters, limit)
	if err != nil {
		return Route53RecordPaginator{}, err
	}

	p := Route53RecordPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53RecordPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53RecordPaginator) NextPage(ctx context.Context) ([]Route53Record, error) {
	var response Route53RecordSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53Record
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53RecordFilters = map[string]string{
	"akas":                       "aRN",
	"alias_target":               "description.Record.AliasTarget",
	"failover":                   "description.Record.Failover",
	"geo_location":               "description.Record.GeoLocation",
	"health_check_id":            "description.Record.HealthCheckId",
	"kaytu_account_id":           "metadata.SourceID",
	"latency_region":             "description.Record.Region",
	"multi_value_answer":         "description.Record.MultiValueAnswer",
	"name":                       "description.Record.Name",
	"set_identifier":             "description.Record.SetIdentifier",
	"title":                      "description.Record.Name",
	"traffic_policy_instance_id": "description.Record.TrafficPolicyInstanceId",
	"ttl":                        "record.TTL",
	"type":                       "description.Record.Type",
	"weight":                     "description.Record.Weight",
	"zone_id":                    "description.ZoneId",
}

func ListRoute53Record(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53Record")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53RecordPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53RecordFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53RecordFilters = map[string]string{
	"akas":                       "aRN",
	"alias_target":               "description.Record.AliasTarget",
	"failover":                   "description.Record.Failover",
	"geo_location":               "description.Record.GeoLocation",
	"health_check_id":            "description.Record.HealthCheckId",
	"kaytu_account_id":           "metadata.SourceID",
	"latency_region":             "description.Record.Region",
	"multi_value_answer":         "description.Record.MultiValueAnswer",
	"name":                       "description.Record.Name",
	"set_identifier":             "description.Record.SetIdentifier",
	"title":                      "description.Record.Name",
	"traffic_policy_instance_id": "description.Record.TrafficPolicyInstanceId",
	"ttl":                        "record.TTL",
	"type":                       "description.Record.Type",
	"weight":                     "description.Record.Weight",
	"zone_id":                    "description.ZoneID",
}

func GetRoute53Record(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53Record")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53RecordPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53RecordFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53Record =============================

// ==========================  START: Route53TrafficPolicy =============================

type Route53TrafficPolicy struct {
	Description   aws.Route53TrafficPolicyDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type Route53TrafficPolicyHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  Route53TrafficPolicy `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type Route53TrafficPolicyHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []Route53TrafficPolicyHit `json:"hits"`
}

type Route53TrafficPolicySearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  Route53TrafficPolicyHits `json:"hits"`
}

type Route53TrafficPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53TrafficPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (Route53TrafficPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_trafficpolicy", filters, limit)
	if err != nil {
		return Route53TrafficPolicyPaginator{}, err
	}

	p := Route53TrafficPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53TrafficPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53TrafficPolicyPaginator) NextPage(ctx context.Context) ([]Route53TrafficPolicy, error) {
	var response Route53TrafficPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53TrafficPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53TrafficPolicyFilters = map[string]string{
	"akas":             "aRN",
	"comment":          "description.TrafficPolicy.Comment",
	"document":         "description.TrafficPolicy.Document",
	"id":               "description.TrafficPolicy.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.TrafficPolicy.Name",
	"title":            "description.TrafficPolicy.Name",
	"type":             "description.TrafficPolicy.Type",
	"version":          "description.TrafficPolicy.Version",
}

func ListRoute53TrafficPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53TrafficPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53TrafficPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53TrafficPolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53TrafficPolicyFilters = map[string]string{
	"akas":             "aRN",
	"comment":          "description.TrafficPolicy.Comment",
	"document":         "description.TrafficPolicy.Document",
	"id":               "description.TrafficPolicy.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.TrafficPolicy.Name",
	"title":            "description.TrafficPolicy.Name",
	"type":             "description.TrafficPolicy.Type",
	"version":          "description.TrafficPolicy.Version",
}

func GetRoute53TrafficPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53TrafficPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53TrafficPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53TrafficPolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53TrafficPolicy =============================

// ==========================  START: Route53TrafficPolicyInstance =============================

type Route53TrafficPolicyInstance struct {
	Description   aws.Route53TrafficPolicyInstanceDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type Route53TrafficPolicyInstanceHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  Route53TrafficPolicyInstance `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type Route53TrafficPolicyInstanceHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []Route53TrafficPolicyInstanceHit `json:"hits"`
}

type Route53TrafficPolicyInstanceSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  Route53TrafficPolicyInstanceHits `json:"hits"`
}

type Route53TrafficPolicyInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53TrafficPolicyInstancePaginator(filters []essdk.BoolFilter, limit *int64) (Route53TrafficPolicyInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_trafficpolicyinstance", filters, limit)
	if err != nil {
		return Route53TrafficPolicyInstancePaginator{}, err
	}

	p := Route53TrafficPolicyInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53TrafficPolicyInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53TrafficPolicyInstancePaginator) NextPage(ctx context.Context) ([]Route53TrafficPolicyInstance, error) {
	var response Route53TrafficPolicyInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53TrafficPolicyInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53TrafficPolicyInstanceFilters = map[string]string{
	"akas":                   "aRN",
	"hosted_zone_id":         "description.TrafficPolicyInstance.HostedZoneId",
	"id":                     "description.TrafficPolicyInstance.Id",
	"kaytu_account_id":       "metadata.SourceID",
	"message":                "description.TrafficPolicyInstance.Message",
	"name":                   "description.TrafficPolicyInstance.Name",
	"state":                  "description.TrafficPolicyInstance.State",
	"title":                  "description.TrafficPolicyInstance.Name",
	"traffic_policy_id":      "description.TrafficPolicyInstance.TrafficPolicyId",
	"traffic_policy_type":    "description.TrafficPolicyInstance.TrafficPolicyType",
	"traffic_policy_version": "description.TrafficPolicyInstance.TrafficPolicyVersion",
	"ttl":                    "tTL",
}

func ListRoute53TrafficPolicyInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53TrafficPolicyInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoute53TrafficPolicyInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoute53TrafficPolicyInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoute53TrafficPolicyInstanceFilters = map[string]string{
	"akas":                   "aRN",
	"hosted_zone_id":         "description.TrafficPolicyInstance.HostedZoneId",
	"id":                     "description.TrafficPolicyInstance.Id",
	"kaytu_account_id":       "metadata.SourceID",
	"message":                "description.TrafficPolicyInstance.Message",
	"name":                   "description.TrafficPolicyInstance.Name",
	"state":                  "description.TrafficPolicyInstance.State",
	"title":                  "description.TrafficPolicyInstance.Name",
	"traffic_policy_id":      "description.TrafficPolicyInstance.TrafficPolicyId",
	"traffic_policy_type":    "description.TrafficPolicyInstance.TrafficPolicyType",
	"traffic_policy_version": "description.TrafficPolicyInstance.TrafficPolicyVersion",
	"ttl":                    "tTL",
}

func GetRoute53TrafficPolicyInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53TrafficPolicyInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoute53TrafficPolicyInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoute53TrafficPolicyInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Route53TrafficPolicyInstance =============================

// ==========================  START: BatchComputeEnvironment =============================

type BatchComputeEnvironment struct {
	Description   aws.BatchComputeEnvironmentDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type BatchComputeEnvironmentHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  BatchComputeEnvironment `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type BatchComputeEnvironmentHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []BatchComputeEnvironmentHit `json:"hits"`
}

type BatchComputeEnvironmentSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  BatchComputeEnvironmentHits `json:"hits"`
}

type BatchComputeEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchComputeEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (BatchComputeEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_batch_computeenvironment", filters, limit)
	if err != nil {
		return BatchComputeEnvironmentPaginator{}, err
	}

	p := BatchComputeEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchComputeEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchComputeEnvironmentPaginator) NextPage(ctx context.Context) ([]BatchComputeEnvironment, error) {
	var response BatchComputeEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchComputeEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchComputeEnvironmentFilters = map[string]string{
	"akas":                     "description.ComputeEnvironment.ComputeEnvironmentArn",
	"arn":                      "description.ComputeEnvironment.ComputeEnvironmentArn",
	"compute_environment_name": "description.ComputeEnvironment.ComputeEnvironmentName",
	"id":                       "description.ComputeEnvironment.Uuid",
	"kaytu_account_id":         "metadata.SourceID",
	"tags":                     "description.ComputeEnvironment.Tags",
	"title":                    "description.ComputeEnvironment.ComputeEnvironmentName",
}

func ListBatchComputeEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchComputeEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBatchComputeEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBatchComputeEnvironmentFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBatchComputeEnvironmentFilters = map[string]string{
	"akas":                     "description.ComputeEnvironment.ComputeEnvironmentArn",
	"arn":                      "description.ComputeEnvironment.ComputeEnvironmentArn",
	"compute_environment_name": "description.ComputeEnvironment.ComputeEnvironmentName",
	"id":                       "description.ComputeEnvironment.Uuid",
	"kaytu_account_id":         "metadata.SourceID",
	"tags":                     "description.ComputeEnvironment.Tags",
	"title":                    "description.ComputeEnvironment.ComputeEnvironmentName",
}

func GetBatchComputeEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchComputeEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBatchComputeEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBatchComputeEnvironmentFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BatchComputeEnvironment =============================

// ==========================  START: BatchJob =============================

type BatchJob struct {
	Description   aws.BatchJobDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type BatchJobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BatchJob      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BatchJobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BatchJobHit     `json:"hits"`
}

type BatchJobSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  BatchJobHits `json:"hits"`
}

type BatchJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchJobPaginator(filters []essdk.BoolFilter, limit *int64) (BatchJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_batch_job", filters, limit)
	if err != nil {
		return BatchJobPaginator{}, err
	}

	p := BatchJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchJobPaginator) NextPage(ctx context.Context) ([]BatchJob, error) {
	var response BatchJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchJobFilters = map[string]string{
	"akas":             "description.Job.JobArn",
	"arn":              "description.Job.JobArn",
	"id":               "description.Job.JobId",
	"job_name":         "description.Job.JobName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Job.JobName",
}

func ListBatchJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBatchJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBatchJobFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBatchJobFilters = map[string]string{
	"akas":             "description.Job.JobArn",
	"arn":              "description.Job.JobArn",
	"id":               "description.Job.JobId",
	"job_name":         "description.Job.JobName",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Job.JobName",
}

func GetBatchJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBatchJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBatchJobFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BatchJob =============================

// ==========================  START: BatchJobQueue =============================

type BatchJobQueue struct {
	Description   aws.BatchJobQueueDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type BatchJobQueueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BatchJobQueue `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BatchJobQueueHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []BatchJobQueueHit `json:"hits"`
}

type BatchJobQueueSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  BatchJobQueueHits `json:"hits"`
}

type BatchJobQueuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchJobQueuePaginator(filters []essdk.BoolFilter, limit *int64) (BatchJobQueuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_batch_jobqueue", filters, limit)
	if err != nil {
		return BatchJobQueuePaginator{}, err
	}

	p := BatchJobQueuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchJobQueuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchJobQueuePaginator) NextPage(ctx context.Context) ([]BatchJobQueue, error) {
	var response BatchJobQueueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchJobQueue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchJobQueueFilters = map[string]string{
	"akas":             "description.Queue.ARN",
	"arn":              "description.Queue.ARN",
	"id":               "description.Queue.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Queue.Name",
	"tags":             "description.Queue.Tags",
	"title":            "description.Queue.Name",
}

func ListBatchJobQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchJobQueue")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBatchJobQueuePaginator(essdk.BuildFilter(d.KeyColumnQuals, listBatchJobQueueFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBatchJobQueueFilters = map[string]string{
	"akas":             "description.Queue.ARN",
	"arn":              "description.Queue.ARN",
	"id":               "description.Queue.Id",
	"job_queue_name":   "description.JobQueue.JobQueueName",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Queue.Name",
	"tags":             "description.Queue.Tags",
	"title":            "description.Queue.Name",
}

func GetBatchJobQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchJobQueue")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBatchJobQueuePaginator(essdk.BuildFilter(d.KeyColumnQuals, getBatchJobQueueFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BatchJobQueue =============================

// ==========================  START: CodeArtifactRepository =============================

type CodeArtifactRepository struct {
	Description   aws.CodeArtifactRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CodeArtifactRepositoryHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CodeArtifactRepository `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CodeArtifactRepositoryHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CodeArtifactRepositoryHit `json:"hits"`
}

type CodeArtifactRepositorySearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CodeArtifactRepositoryHits `json:"hits"`
}

type CodeArtifactRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeArtifactRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (CodeArtifactRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codeartifact_repository", filters, limit)
	if err != nil {
		return CodeArtifactRepositoryPaginator{}, err
	}

	p := CodeArtifactRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeArtifactRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeArtifactRepositoryPaginator) NextPage(ctx context.Context) ([]CodeArtifactRepository, error) {
	var response CodeArtifactRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeArtifactRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeArtifactRepositoryFilters = map[string]string{
	"akas":             "description.Repository.Arn",
	"arn":              "description.Repository.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Repository.Name",
	"title":            "description.Repository.Name",
}

func ListCodeArtifactRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeArtifactRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeArtifactRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeArtifactRepositoryFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeArtifactRepositoryFilters = map[string]string{
	"akas":             "description.Repository.Arn",
	"arn":              "description.Repository.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Repository.Name",
	"title":            "description.Repository.Name",
}

func GetCodeArtifactRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeArtifactRepository")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeArtifactRepositoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeArtifactRepositoryFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeArtifactRepository =============================

// ==========================  START: CodeArtifactDomain =============================

type CodeArtifactDomain struct {
	Description   aws.CodeArtifactDomainDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type CodeArtifactDomainHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  CodeArtifactDomain `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type CodeArtifactDomainHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []CodeArtifactDomainHit `json:"hits"`
}

type CodeArtifactDomainSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  CodeArtifactDomainHits `json:"hits"`
}

type CodeArtifactDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeArtifactDomainPaginator(filters []essdk.BoolFilter, limit *int64) (CodeArtifactDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codeartifact_domain", filters, limit)
	if err != nil {
		return CodeArtifactDomainPaginator{}, err
	}

	p := CodeArtifactDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeArtifactDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeArtifactDomainPaginator) NextPage(ctx context.Context) ([]CodeArtifactDomain, error) {
	var response CodeArtifactDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeArtifactDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeArtifactDomainFilters = map[string]string{
	"akas":             "description.Domain.Arn",
	"arn":              "description.Domain.Arn",
	"asset_size_bytes": "description.Domain.AssetSizeBytes",
	"created_time":     "description.Domain.CreatedTime",
	"encryption_key":   "description.Domain.EncryptionKey",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Domain.Name",
	"owner":            "description.Domain.Owner",
	"policy":           "description.Policy",
	"policy_std":       "description.Policy",
	"repository_count": "description.Domain.RepositoryCount",
	"s3_bucket_arn":    "description.Domain.S3BucketArn",
	"status":           "description.Domain.Status",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.Domain.Name",
}

func ListCodeArtifactDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeArtifactDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeArtifactDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeArtifactDomainFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeArtifactDomainFilters = map[string]string{
	"akas":             "description.Domain.Arn",
	"arn":              "description.Domain.Arn",
	"asset_size_bytes": "description.Domain.AssetSizeBytes",
	"created_time":     "description.Domain.CreatedTime",
	"encryption_key":   "description.Domain.EncryptionKey",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Domain.Owner",
	"owner":            "description.Domain.Owner",
	"policy":           "description.Policy",
	"policy_std":       "description.Policy",
	"repository_count": "description.Domain.RepositoryCount",
	"s3_bucket_arn":    "description.Domain.S3BucketArn",
	"status":           "description.Domain.Status",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.Domain.Name",
}

func GetCodeArtifactDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeArtifactDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeArtifactDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeArtifactDomainFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeArtifactDomain =============================

// ==========================  START: CodeDeployDeploymentGroup =============================

type CodeDeployDeploymentGroup struct {
	Description   aws.CodeDeployDeploymentGroupDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type CodeDeployDeploymentGroupHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  CodeDeployDeploymentGroup `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type CodeDeployDeploymentGroupHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []CodeDeployDeploymentGroupHit `json:"hits"`
}

type CodeDeployDeploymentGroupSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  CodeDeployDeploymentGroupHits `json:"hits"`
}

type CodeDeployDeploymentGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeDeployDeploymentGroupPaginator(filters []essdk.BoolFilter, limit *int64) (CodeDeployDeploymentGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codedeploy_deploymentgroup", filters, limit)
	if err != nil {
		return CodeDeployDeploymentGroupPaginator{}, err
	}

	p := CodeDeployDeploymentGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeDeployDeploymentGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeDeployDeploymentGroupPaginator) NextPage(ctx context.Context) ([]CodeDeployDeploymentGroup, error) {
	var response CodeDeployDeploymentGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeDeployDeploymentGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeDeployDeploymentGroupFilters = map[string]string{
	"deployment_group_name": "description.DeploymentGroup.DeploymentGroupName",
	"id":                    "description.DeploymentGroup.DeploymentGroupId",
	"kaytu_account_id":      "metadata.SourceID",
	"title":                 "description.DeploymentGroup.DeploymentGroupName",
}

func ListCodeDeployDeploymentGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeDeployDeploymentGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeDeployDeploymentGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeDeployDeploymentGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeDeployDeploymentGroupFilters = map[string]string{
	"deployment_group_name": "description.DeploymentGroup.DeploymentGroupName",
	"id":                    "description.DeploymentGroup.DeploymentGroupId",
	"kaytu_account_id":      "metadata.SourceID",
	"title":                 "description.DeploymentGroup.DeploymentGroupName",
}

func GetCodeDeployDeploymentGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeDeployDeploymentGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeDeployDeploymentGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeDeployDeploymentGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeDeployDeploymentGroup =============================

// ==========================  START: CodeDeployApplication =============================

type CodeDeployApplication struct {
	Description   aws.CodeDeployApplicationDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type CodeDeployApplicationHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  CodeDeployApplication `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type CodeDeployApplicationHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []CodeDeployApplicationHit `json:"hits"`
}

type CodeDeployApplicationSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  CodeDeployApplicationHits `json:"hits"`
}

type CodeDeployApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeDeployApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (CodeDeployApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codedeploy_application", filters, limit)
	if err != nil {
		return CodeDeployApplicationPaginator{}, err
	}

	p := CodeDeployApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeDeployApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeDeployApplicationPaginator) NextPage(ctx context.Context) ([]CodeDeployApplication, error) {
	var response CodeDeployApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeDeployApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeDeployApplicationFilters = map[string]string{
	"application_name": "description.Application.ApplicationName",
	"id":               "description.Application.ApplicationId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Application.ApplicationName",
}

func ListCodeDeployApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeDeployApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeDeployApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeDeployApplicationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeDeployApplicationFilters = map[string]string{
	"application_name": "description.Application.ApplicationName",
	"id":               "description.Application.ApplicationId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Application.ApplicationName",
}

func GetCodeDeployApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeDeployApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeDeployApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeDeployApplicationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeDeployApplication =============================

// ==========================  START: CodeStarProject =============================

type CodeStarProject struct {
	Description   aws.CodeStarProjectDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CodeStarProjectHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CodeStarProject `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CodeStarProjectHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CodeStarProjectHit `json:"hits"`
}

type CodeStarProjectSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CodeStarProjectHits `json:"hits"`
}

type CodeStarProjectPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeStarProjectPaginator(filters []essdk.BoolFilter, limit *int64) (CodeStarProjectPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codestar_project", filters, limit)
	if err != nil {
		return CodeStarProjectPaginator{}, err
	}

	p := CodeStarProjectPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeStarProjectPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeStarProjectPaginator) NextPage(ctx context.Context) ([]CodeStarProject, error) {
	var response CodeStarProjectSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeStarProject
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeStarProjectFilters = map[string]string{
	"akas":             "description.Project.Arn",
	"arn":              "description.Project.Arn",
	"id":               "description.Project.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Project.Name",
	"tags":             "description.Tags",
	"title":            "description.Project.Name",
}

func ListCodeStarProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeStarProject")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCodeStarProjectPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCodeStarProjectFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCodeStarProjectFilters = map[string]string{
	"akas":             "description.Project.Arn",
	"arn":              "description.Project.Arn",
	"id":               "description.Project.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Project.Name",
	"tags":             "description.Tags",
	"title":            "description.Project.Name",
}

func GetCodeStarProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeStarProject")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCodeStarProjectPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCodeStarProjectFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CodeStarProject =============================

// ==========================  START: DirectConnectConnection =============================

type DirectConnectConnection struct {
	Description   aws.DirectConnectConnectionDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type DirectConnectConnectionHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  DirectConnectConnection `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type DirectConnectConnectionHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []DirectConnectConnectionHit `json:"hits"`
}

type DirectConnectConnectionSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  DirectConnectConnectionHits `json:"hits"`
}

type DirectConnectConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectConnectConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (DirectConnectConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directconnect_connection", filters, limit)
	if err != nil {
		return DirectConnectConnectionPaginator{}, err
	}

	p := DirectConnectConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectConnectConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectConnectConnectionPaginator) NextPage(ctx context.Context) ([]DirectConnectConnection, error) {
	var response DirectConnectConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectConnectConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectConnectConnectionFilters = map[string]string{
	"connection_id":    "description.Connection.ConnectionId",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Connection.ConnectionName",
	"title":            "description.Connection.ConnectionName",
}

func ListDirectConnectConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectConnectConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDirectConnectConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDirectConnectConnectionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDirectConnectConnectionFilters = map[string]string{
	"connection_id":    "description.Connection.ConnectionId",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Connection.ConnectionName",
	"title":            "description.Connection.ConnectionName",
}

func GetDirectConnectConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectConnectConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDirectConnectConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDirectConnectConnectionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DirectConnectConnection =============================

// ==========================  START: DirectConnectGateway =============================

type DirectConnectGateway struct {
	Description   aws.DirectConnectGatewayDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type DirectConnectGatewayHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  DirectConnectGateway `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type DirectConnectGatewayHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []DirectConnectGatewayHit `json:"hits"`
}

type DirectConnectGatewaySearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  DirectConnectGatewayHits `json:"hits"`
}

type DirectConnectGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectConnectGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (DirectConnectGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directconnect_gateway", filters, limit)
	if err != nil {
		return DirectConnectGatewayPaginator{}, err
	}

	p := DirectConnectGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectConnectGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectConnectGatewayPaginator) NextPage(ctx context.Context) ([]DirectConnectGateway, error) {
	var response DirectConnectGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectConnectGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectConnectGatewayFilters = map[string]string{
	"direct_connect_gateway_id": "description.Gateway.DirectConnectGatewayId",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.Gateway.DirectConnectGatewayName",
	"title":                     "description.Gateway.DirectConnectGatewayName",
}

func ListDirectConnectGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectConnectGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDirectConnectGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDirectConnectGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDirectConnectGatewayFilters = map[string]string{
	"direct_connect_gateway_id": "description.Gateway.DirectConnectGatewayId",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.Gateway.DirectConnectGatewayName",
	"title":                     "description.Gateway.DirectConnectGatewayName",
}

func GetDirectConnectGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectConnectGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDirectConnectGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDirectConnectGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DirectConnectGateway =============================

// ==========================  START: NetworkFirewallFirewall =============================

type NetworkFirewallFirewall struct {
	Description   aws.NetworkFirewallFirewallDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type NetworkFirewallFirewallHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  NetworkFirewallFirewall `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type NetworkFirewallFirewallHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []NetworkFirewallFirewallHit `json:"hits"`
}

type NetworkFirewallFirewallSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  NetworkFirewallFirewallHits `json:"hits"`
}

type NetworkFirewallFirewallPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkFirewallFirewallPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkFirewallFirewallPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_networkfirewall_firewall", filters, limit)
	if err != nil {
		return NetworkFirewallFirewallPaginator{}, err
	}

	p := NetworkFirewallFirewallPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkFirewallFirewallPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkFirewallFirewallPaginator) NextPage(ctx context.Context) ([]NetworkFirewallFirewall, error) {
	var response NetworkFirewallFirewallSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkFirewallFirewall
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkFirewallFirewallFilters = map[string]string{
	"akas":             "description.Firewall.FirewallArn",
	"arn":              "description.Firewall.FirewallArn",
	"firewall_name":    "description.Firewall.FirewallName",
	"id":               "description.Firewall.FirewallId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Firewall.FirewallName",
}

func ListNetworkFirewallFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkFirewallFirewall")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkFirewallFirewallPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkFirewallFirewallFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkFirewallFirewallFilters = map[string]string{
	"akas":             "description.Firewall.FirewallArn",
	"arn":              "description.Firewall.FirewallArn",
	"firewall_name":    "description.Firewall.FirewallName",
	"id":               "description.Firewall.FirewallId",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Firewall.FirewallName",
}

func GetNetworkFirewallFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkFirewallFirewall")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkFirewallFirewallPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkFirewallFirewallFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkFirewallFirewall =============================

// ==========================  START: NetworkFirewallFirewallPolicy =============================

type NetworkFirewallFirewallPolicy struct {
	Description   aws.NetworkFirewallFirewallPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type NetworkFirewallFirewallPolicyHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  NetworkFirewallFirewallPolicy `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type NetworkFirewallFirewallPolicyHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []NetworkFirewallFirewallPolicyHit `json:"hits"`
}

type NetworkFirewallFirewallPolicySearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  NetworkFirewallFirewallPolicyHits `json:"hits"`
}

type NetworkFirewallFirewallPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkFirewallFirewallPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkFirewallFirewallPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_networkfirewall_firewallpolicy", filters, limit)
	if err != nil {
		return NetworkFirewallFirewallPolicyPaginator{}, err
	}

	p := NetworkFirewallFirewallPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkFirewallFirewallPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkFirewallFirewallPolicyPaginator) NextPage(ctx context.Context) ([]NetworkFirewallFirewallPolicy, error) {
	var response NetworkFirewallFirewallPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkFirewallFirewallPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkFirewallFirewallPolicyFilters = map[string]string{
	"akas":                             "description.FirewallPolicyResponse.Tags",
	"arn":                              "arn",
	"consumed_stateful_rule_capacity":  "description.FirewallPolicyResponse.ConsumedStatefulRuleCapacity",
	"consumed_stateless_rule_capacity": "description.FirewallPolicyResponse.ConsumedStatelessRuleCapacity",
	"description":                      "description.FirewallPolicyResponse.Description",
	"encryption_configuration":         "description.FirewallPolicyResponse.EncryptionConfiguration",
	"firewall_policy":                  "description.FirewallPolicy",
	"firewall_policy_id":               "description.FirewallPolicyResponse.FirewallPolicyId",
	"firewall_policy_status":           "description.FirewallPolicyResponse.FirewallPolicyStatus",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_modified_time":               "description.FirewallPolicyResponse.LastModifiedTime",
	"name":                             "description.FirewallPolicyResponse.FirewallPolicyName",
	"number_of_associations":           "description.FirewallPolicyResponse.NumberOfAssociations",
	"tags":                             "description.FirewallPolicyResponse.Tags",
	"tags_src":                         "description.FirewallPolicyResponse.Tags",
	"title":                            "description.FirewallPolicyResponse.FirewallPolicyName",
}

func ListNetworkFirewallFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkFirewallFirewallPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkFirewallFirewallPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkFirewallFirewallPolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkFirewallFirewallPolicyFilters = map[string]string{
	"akas":                             "description.FirewallPolicyResponse.Tags",
	"arn":                              "description.FirewallPolicyResponse.FirewallPolicyArn",
	"consumed_stateful_rule_capacity":  "description.FirewallPolicyResponse.ConsumedStatefulRuleCapacity",
	"consumed_stateless_rule_capacity": "description.FirewallPolicyResponse.ConsumedStatelessRuleCapacity",
	"description":                      "description.FirewallPolicyResponse.Description",
	"encryption_configuration":         "description.FirewallPolicyResponse.EncryptionConfiguration",
	"firewall_policy":                  "description.FirewallPolicy",
	"firewall_policy_id":               "description.FirewallPolicyResponse.FirewallPolicyId",
	"firewall_policy_status":           "description.FirewallPolicyResponse.FirewallPolicyStatus",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_modified_time":               "description.FirewallPolicyResponse.LastModifiedTime",
	"name":                             "description.FirewallPolicyResponse.FirewallPolicyName",
	"number_of_associations":           "description.FirewallPolicyResponse.NumberOfAssociations",
	"tags":                             "description.FirewallPolicyResponse.Tags",
	"tags_src":                         "description.FirewallPolicyResponse.Tags",
	"title":                            "description.FirewallPolicyResponse.FirewallPolicyName",
}

func GetNetworkFirewallFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkFirewallFirewallPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkFirewallFirewallPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkFirewallFirewallPolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkFirewallFirewallPolicy =============================

// ==========================  START: NetworkFirewallRuleGroup =============================

type NetworkFirewallRuleGroup struct {
	Description   aws.NetworkFirewallRuleGroupDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type NetworkFirewallRuleGroupHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  NetworkFirewallRuleGroup `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type NetworkFirewallRuleGroupHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []NetworkFirewallRuleGroupHit `json:"hits"`
}

type NetworkFirewallRuleGroupSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  NetworkFirewallRuleGroupHits `json:"hits"`
}

type NetworkFirewallRuleGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkFirewallRuleGroupPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkFirewallRuleGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_networkfirewall_rulegroup", filters, limit)
	if err != nil {
		return NetworkFirewallRuleGroupPaginator{}, err
	}

	p := NetworkFirewallRuleGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkFirewallRuleGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkFirewallRuleGroupPaginator) NextPage(ctx context.Context) ([]NetworkFirewallRuleGroup, error) {
	var response NetworkFirewallRuleGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkFirewallRuleGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkFirewallRuleGroupFilters = map[string]string{
	"akas":                   "description.RuleGroup.RuleGroupArn",
	"arn":                    "description.RuleGroupResponse.RuleGroupArn",
	"capacity":               "description.RuleGroupResponse.Capacity",
	"consumed_capacity":      "description.RuleGroupResponse.ConsumedCapacity",
	"description":            "description.RuleGroupResponse.Description",
	"kaytu_account_id":       "metadata.SourceID",
	"number_of_associations": "description.RuleGroupResponse.NumberOfAssociations",
	"rule_group_id":          "description.RuleGroupResponse.RuleGroupId",
	"rule_group_name":        "description.RuleGroupResponse.RuleGroupName",
	"rule_group_status":      "description.RuleGroupResponse.RuleGroupStatus",
	"rule_variables":         "description.RuleGroup.RuleVariables",
	"rules_source":           "description.RuleGroup.RulesSource",
	"stateful_rule_options":  "description.RuleGroup.StatefulRuleOptions",
	"tags":                   "description.RuleGroupResponse.Tags",
	"tags_src":               "description.RuleGroupResponse.Tags",
	"title":                  "description.RuleGroupResponse.RuleGroupName",
	"type":                   "description.RuleGroupResponse.Type",
}

func ListNetworkFirewallRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkFirewallRuleGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkFirewallRuleGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkFirewallRuleGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkFirewallRuleGroupFilters = map[string]string{
	"akas":                   "description.RuleGroup.RuleGroupArn",
	"arn":                    "description.RuleGroupResponse.RuleGroupArn",
	"capacity":               "description.RuleGroupResponse.Capacity",
	"consumed_capacity":      "description.RuleGroupResponse.ConsumedCapacity",
	"description":            "description.RuleGroupResponse.Description",
	"kaytu_account_id":       "metadata.SourceID",
	"number_of_associations": "description.RuleGroupResponse.NumberOfAssociations",
	"rule_group_id":          "description.RuleGroupResponse.RuleGroupId",
	"rule_group_name":        "description.RuleGroupResponse.RuleGroupName",
	"rule_group_status":      "description.RuleGroupResponse.RuleGroupStatus",
	"rule_variables":         "description.RuleGroup.RuleVariables",
	"rules_source":           "description.RuleGroup.RulesSource",
	"stateful_rule_options":  "description.RuleGroup.StatefulRuleOptions",
	"tags":                   "description.RuleGroupResponse.Tags",
	"tags_src":               "description.RuleGroupResponse.Tags",
	"title":                  "description.RuleGroupResponse.RuleGroupName",
	"type":                   "description.RuleGroupResponse.Type",
}

func GetNetworkFirewallRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkFirewallRuleGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkFirewallRuleGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkFirewallRuleGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkFirewallRuleGroup =============================

// ==========================  START: OpsWorksCMServer =============================

type OpsWorksCMServer struct {
	Description   aws.OpsWorksCMServerDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type OpsWorksCMServerHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  OpsWorksCMServer `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type OpsWorksCMServerHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []OpsWorksCMServerHit `json:"hits"`
}

type OpsWorksCMServerSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  OpsWorksCMServerHits `json:"hits"`
}

type OpsWorksCMServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOpsWorksCMServerPaginator(filters []essdk.BoolFilter, limit *int64) (OpsWorksCMServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_opsworkscm_server", filters, limit)
	if err != nil {
		return OpsWorksCMServerPaginator{}, err
	}

	p := OpsWorksCMServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OpsWorksCMServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OpsWorksCMServerPaginator) NextPage(ctx context.Context) ([]OpsWorksCMServer, error) {
	var response OpsWorksCMServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OpsWorksCMServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOpsWorksCMServerFilters = map[string]string{
	"akas":             "description.Server.ServerArn",
	"arn":              "description.Server.ServerArn",
	"kaytu_account_id": "metadata.SourceID",
	"server_name":      "description.Server.ServerName",
	"title":            "description.Server.ServerName",
}

func ListOpsWorksCMServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOpsWorksCMServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewOpsWorksCMServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listOpsWorksCMServerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getOpsWorksCMServerFilters = map[string]string{
	"akas":             "description.Server.ServerArn",
	"arn":              "description.Server.ServerArn",
	"kaytu_account_id": "metadata.SourceID",
	"server_name":      "description.Server.ServerName",
	"title":            "description.Server.ServerName",
}

func GetOpsWorksCMServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOpsWorksCMServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewOpsWorksCMServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getOpsWorksCMServerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: OpsWorksCMServer =============================

// ==========================  START: OrganizationsOrganization =============================

type OrganizationsOrganization struct {
	Description   aws.OrganizationsOrganizationDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type OrganizationsOrganizationHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  OrganizationsOrganization `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type OrganizationsOrganizationHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []OrganizationsOrganizationHit `json:"hits"`
}

type OrganizationsOrganizationSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  OrganizationsOrganizationHits `json:"hits"`
}

type OrganizationsOrganizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsOrganizationPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsOrganizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_organization", filters, limit)
	if err != nil {
		return OrganizationsOrganizationPaginator{}, err
	}

	p := OrganizationsOrganizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsOrganizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsOrganizationPaginator) NextPage(ctx context.Context) ([]OrganizationsOrganization, error) {
	var response OrganizationsOrganizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsOrganization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsOrganizationFilters = map[string]string{
	"akas":             "description.Organization.Arn",
	"arn":              "description.Organization.Arn",
	"id":               "description.Organization.Id",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Organization.Id",
}

func ListOrganizationsOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsOrganization")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewOrganizationsOrganizationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listOrganizationsOrganizationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getOrganizationsOrganizationFilters = map[string]string{
	"akas":             "description.Organization.Arn",
	"arn":              "description.Organization.Arn",
	"id":               "description.Organization.Id",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.Organization.Id",
}

func GetOrganizationsOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsOrganization")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewOrganizationsOrganizationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getOrganizationsOrganizationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: OrganizationsOrganization =============================

// ==========================  START: OrganizationsAccount =============================

type OrganizationsAccount struct {
	Description   aws.OrganizationsAccountDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type OrganizationsAccountHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  OrganizationsAccount `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type OrganizationsAccountHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []OrganizationsAccountHit `json:"hits"`
}

type OrganizationsAccountSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  OrganizationsAccountHits `json:"hits"`
}

type OrganizationsAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsAccountPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_account", filters, limit)
	if err != nil {
		return OrganizationsAccountPaginator{}, err
	}

	p := OrganizationsAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsAccountPaginator) NextPage(ctx context.Context) ([]OrganizationsAccount, error) {
	var response OrganizationsAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsAccountFilters = map[string]string{
	"akas":             "description.Account.Arn",
	"arn":              "description.Account.Arn",
	"email":            "description.Account.Email",
	"id":               "description.Account.Id",
	"joined_method":    "description.Account.JoinedMethod",
	"joined_timestamp": "description.Account.JoinedTimestamp",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Account.Name",
	"status":           "description.Account.Status",
	"tags_src":         "description.Tags",
	"title":            "description.Account.Name",
}

func ListOrganizationsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewOrganizationsAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, listOrganizationsAccountFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getOrganizationsAccountFilters = map[string]string{
	"akas":             "description.Account.Arn",
	"arn":              "description.Account.Arn",
	"email":            "description.Account.Email",
	"id":               "description.Account.Id",
	"joined_method":    "description.Account.JoinedMethod",
	"joined_timestamp": "description.Account.JoinedTimestamp",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Account.Name",
	"status":           "description.Account.Status",
	"tags_src":         "description.Tags",
	"title":            "description.Account.Name",
}

func GetOrganizationsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewOrganizationsAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, getOrganizationsAccountFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: OrganizationsAccount =============================

// ==========================  START: PinPointApp =============================

type PinPointApp struct {
	Description   aws.PinPointAppDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type PinPointAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PinPointApp   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PinPointAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PinPointAppHit  `json:"hits"`
}

type PinPointAppSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  PinPointAppHits `json:"hits"`
}

type PinPointAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPinPointAppPaginator(filters []essdk.BoolFilter, limit *int64) (PinPointAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_pinpoint_app", filters, limit)
	if err != nil {
		return PinPointAppPaginator{}, err
	}

	p := PinPointAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PinPointAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PinPointAppPaginator) NextPage(ctx context.Context) ([]PinPointApp, error) {
	var response PinPointAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PinPointApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPinPointAppFilters = map[string]string{
	"akas":               "description.App.Arn",
	"arn":                "description.App.Arn",
	"campaign_hook":      "description.Settings.CampaignHook",
	"id":                 "description.App.Id",
	"kaytu_account_id":   "metadata.SourceID",
	"last_modified_date": "description.Settings.LastModifiedDate",
	"limits":             "description.Settings.Limits",
	"name":               "description.App.Name",
	"quiet_time":         "description.Settings.QuietTime",
	"tags":               "description.App.Tags",
	"title":              "description.App.Name",
}

func ListPinPointApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPinPointApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPinPointAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPinPointAppFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPinPointAppFilters = map[string]string{
	"akas":               "description.App.Arn",
	"arn":                "description.App.Arn",
	"campaign_hook":      "description.Settings.CampaignHook",
	"id":                 "description.App.Id",
	"kaytu_account_id":   "metadata.SourceID",
	"last_modified_date": "description.Settings.LastModifiedDate",
	"limits":             "description.Settings.Limits",
	"name":               "description.App.Name",
	"quiet_time":         "description.Settings.QuietTime",
	"tags":               "description.App.Tags",
	"title":              "description.App.Name",
}

func GetPinPointApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPinPointApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPinPointAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPinPointAppFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PinPointApp =============================

// ==========================  START: PipesPipe =============================

type PipesPipe struct {
	Description   aws.PipesPipeDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type PipesPipeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PipesPipe     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PipesPipeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PipesPipeHit    `json:"hits"`
}

type PipesPipeSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  PipesPipeHits `json:"hits"`
}

type PipesPipePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPipesPipePaginator(filters []essdk.BoolFilter, limit *int64) (PipesPipePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_pipes_pipe", filters, limit)
	if err != nil {
		return PipesPipePaginator{}, err
	}

	p := PipesPipePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PipesPipePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PipesPipePaginator) NextPage(ctx context.Context) ([]PipesPipe, error) {
	var response PipesPipeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PipesPipe
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPipesPipeFilters = map[string]string{
	"akas":                  "description.Pipe.Arn",
	"arn":                   "description.Pipe.Arn",
	"creation_time":         "description.Pipe.CreationTime",
	"current_state":         "description.PipeOutput.CurrentState",
	"description":           "description.PipeOutput.Description",
	"desired_state":         "description.PipeOutput.DesiredState",
	"enrichment":            "description.Pipe.Enrichment",
	"enrichment_parameters": "description.PipeOutput.EnrichmentParameters",
	"kaytu_account_id":      "metadata.SourceID",
	"last_modified_time":    "description.Pipe.LastModifiedTime",
	"name":                  "description.Pipe.Name",
	"role_arn":              "description.PipeOutput.RoleArn",
	"source":                "description.Pipe.Source",
	"state_reason":          "description.Pipe.StateReason",
	"tags":                  "description.PipeOutput.Tags",
	"target":                "description.Pipe.Target",
	"target_parameters":     "description.PipeOutput.TargetParameters",
	"title":                 "description.Pipe.Name",
}

func ListPipesPipe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPipesPipe")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPipesPipePaginator(essdk.BuildFilter(d.KeyColumnQuals, listPipesPipeFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPipesPipeFilters = map[string]string{
	"akas":                  "description.Pipe.Arn",
	"arn":                   "description.Pipe.Arn",
	"creation_time":         "description.Pipe.CreationTime",
	"current_state":         "description.Pipe.CurrentState",
	"description":           "description.PipeOutput.Description",
	"desired_state":         "description.Pipe.DesiredState",
	"enrichment":            "description.Pipe.Enrichment",
	"enrichment_parameters": "description.PipeOutput.EnrichmentParameters",
	"kaytu_account_id":      "metadata.SourceID",
	"last_modified_time":    "description.Pipe.LastModifiedTime",
	"name":                  "description.PipeOutput.Name",
	"role_arn":              "description.PipeOutput.RoleArn",
	"source":                "description.Pipe.Source",
	"state_reason":          "description.Pipe.StateReason",
	"tags":                  "description.PipeOutput.Tags",
	"target":                "description.Pipe.Target",
	"target_parameters":     "description.PipeOutput.TargetParameters",
	"title":                 "description.Pipe.Name",
}

func GetPipesPipe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPipesPipe")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPipesPipePaginator(essdk.BuildFilter(d.KeyColumnQuals, getPipesPipeFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PipesPipe =============================

// ==========================  START: ResourceExplorer2Index =============================

type ResourceExplorer2Index struct {
	Description   aws.ResourceExplorer2IndexDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ResourceExplorer2IndexHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ResourceExplorer2Index `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ResourceExplorer2IndexHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ResourceExplorer2IndexHit `json:"hits"`
}

type ResourceExplorer2IndexSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ResourceExplorer2IndexHits `json:"hits"`
}

type ResourceExplorer2IndexPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceExplorer2IndexPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceExplorer2IndexPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_resourceexplorer2_index", filters, limit)
	if err != nil {
		return ResourceExplorer2IndexPaginator{}, err
	}

	p := ResourceExplorer2IndexPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceExplorer2IndexPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceExplorer2IndexPaginator) NextPage(ctx context.Context) ([]ResourceExplorer2Index, error) {
	var response ResourceExplorer2IndexSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceExplorer2Index
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceExplorer2IndexFilters = map[string]string{
	"arn":              "description.Index.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"region":           "description.Index.Region",
	"type":             "description.Index.Type",
}

func ListResourceExplorer2Index(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceExplorer2Index")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewResourceExplorer2IndexPaginator(essdk.BuildFilter(d.KeyColumnQuals, listResourceExplorer2IndexFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getResourceExplorer2IndexFilters = map[string]string{
	"arn":              "description.Index.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"region":           "description.Index.Region",
	"type":             "description.Index.Type",
}

func GetResourceExplorer2Index(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceExplorer2Index")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewResourceExplorer2IndexPaginator(essdk.BuildFilter(d.KeyColumnQuals, getResourceExplorer2IndexFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ResourceExplorer2Index =============================

// ==========================  START: ResourceExplorer2SupportedResourceType =============================

type ResourceExplorer2SupportedResourceType struct {
	Description   aws.ResourceExplorer2SupportedResourceTypeDescription `json:"description"`
	Metadata      aws.Metadata                                          `json:"metadata"`
	ResourceJobID int                                                   `json:"resource_job_id"`
	SourceJobID   int                                                   `json:"source_job_id"`
	ResourceType  string                                                `json:"resource_type"`
	SourceType    string                                                `json:"source_type"`
	ID            string                                                `json:"id"`
	ARN           string                                                `json:"arn"`
	SourceID      string                                                `json:"source_id"`
}

type ResourceExplorer2SupportedResourceTypeHit struct {
	ID      string                                 `json:"_id"`
	Score   float64                                `json:"_score"`
	Index   string                                 `json:"_index"`
	Type    string                                 `json:"_type"`
	Version int64                                  `json:"_version,omitempty"`
	Source  ResourceExplorer2SupportedResourceType `json:"_source"`
	Sort    []interface{}                          `json:"sort"`
}

type ResourceExplorer2SupportedResourceTypeHits struct {
	Total essdk.SearchTotal                           `json:"total"`
	Hits  []ResourceExplorer2SupportedResourceTypeHit `json:"hits"`
}

type ResourceExplorer2SupportedResourceTypeSearchResponse struct {
	PitID string                                     `json:"pit_id"`
	Hits  ResourceExplorer2SupportedResourceTypeHits `json:"hits"`
}

type ResourceExplorer2SupportedResourceTypePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceExplorer2SupportedResourceTypePaginator(filters []essdk.BoolFilter, limit *int64) (ResourceExplorer2SupportedResourceTypePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_resourceexplorer2_supportedresourcetype", filters, limit)
	if err != nil {
		return ResourceExplorer2SupportedResourceTypePaginator{}, err
	}

	p := ResourceExplorer2SupportedResourceTypePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceExplorer2SupportedResourceTypePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceExplorer2SupportedResourceTypePaginator) NextPage(ctx context.Context) ([]ResourceExplorer2SupportedResourceType, error) {
	var response ResourceExplorer2SupportedResourceTypeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceExplorer2SupportedResourceType
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceExplorer2SupportedResourceTypeFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"resource_type":    "description.SupportedResourceType.ResourceType",
	"service":          "description.SupportedResourceType.Service",
}

func ListResourceExplorer2SupportedResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceExplorer2SupportedResourceType")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewResourceExplorer2SupportedResourceTypePaginator(essdk.BuildFilter(d.KeyColumnQuals, listResourceExplorer2SupportedResourceTypeFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getResourceExplorer2SupportedResourceTypeFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"resource_type":    "description.SupportedResourceType.ResourceType",
	"service":          "description.SupportedResourceType.Service",
}

func GetResourceExplorer2SupportedResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceExplorer2SupportedResourceType")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewResourceExplorer2SupportedResourceTypePaginator(essdk.BuildFilter(d.KeyColumnQuals, getResourceExplorer2SupportedResourceTypeFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ResourceExplorer2SupportedResourceType =============================

// ==========================  START: StepFunctionsStateMachine =============================

type StepFunctionsStateMachine struct {
	Description   aws.StepFunctionsStateMachineDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type StepFunctionsStateMachineHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  StepFunctionsStateMachine `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type StepFunctionsStateMachineHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []StepFunctionsStateMachineHit `json:"hits"`
}

type StepFunctionsStateMachineSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  StepFunctionsStateMachineHits `json:"hits"`
}

type StepFunctionsStateMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStepFunctionsStateMachinePaginator(filters []essdk.BoolFilter, limit *int64) (StepFunctionsStateMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_stepfunctions_statemachine", filters, limit)
	if err != nil {
		return StepFunctionsStateMachinePaginator{}, err
	}

	p := StepFunctionsStateMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StepFunctionsStateMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StepFunctionsStateMachinePaginator) NextPage(ctx context.Context) ([]StepFunctionsStateMachine, error) {
	var response StepFunctionsStateMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StepFunctionsStateMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStepFunctionsStateMachineFilters = map[string]string{
	"akas":                  "description.StateMachine.StateMachineArn",
	"arn":                   "description.StateMachine.StateMachineArn",
	"creation_date":         "description.StateMachine.CreationDate",
	"definition":            "description.StateMachine.Definition",
	"kaytu_account_id":      "metadata.SourceID",
	"logging_configuration": "description.StateMachine.LoggingConfiguration",
	"name":                  "description.StateMachine.Name",
	"role_arn":              "description.StateMachine.RoleArn",
	"status":                "description.StateMachine.Status",
	"tags_src":              "description.Tags",
	"title":                 "description.StateMachine.Name",
	"tracing_configuration": "description.StateMachine.TracingConfiguration",
	"type":                  "description.StateMachine.Type",
}

func ListStepFunctionsStateMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStepFunctionsStateMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStepFunctionsStateMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listStepFunctionsStateMachineFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStepFunctionsStateMachineFilters = map[string]string{
	"akas":                  "description.StateMachine.StateMachineArn",
	"arn":                   "description.StateMachineItem.StateMachineArn",
	"creation_date":         "description.StateMachine.CreationDate",
	"definition":            "description.StateMachine.Definition",
	"kaytu_account_id":      "metadata.SourceID",
	"logging_configuration": "description.StateMachine.LoggingConfiguration",
	"name":                  "description.StateMachine.Name",
	"role_arn":              "description.StateMachine.RoleArn",
	"status":                "description.StateMachine.Status",
	"tags_src":              "description.Tags",
	"title":                 "description.StateMachine.Name",
	"tracing_configuration": "description.StateMachine.TracingConfiguration",
	"type":                  "description.StateMachine.Type",
}

func GetStepFunctionsStateMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStepFunctionsStateMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStepFunctionsStateMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getStepFunctionsStateMachineFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StepFunctionsStateMachine =============================

// ==========================  START: StepFunctionsStateMachineExecutionHistories =============================

type StepFunctionsStateMachineExecutionHistories struct {
	Description   aws.StepFunctionsStateMachineExecutionHistoriesDescription `json:"description"`
	Metadata      aws.Metadata                                               `json:"metadata"`
	ResourceJobID int                                                        `json:"resource_job_id"`
	SourceJobID   int                                                        `json:"source_job_id"`
	ResourceType  string                                                     `json:"resource_type"`
	SourceType    string                                                     `json:"source_type"`
	ID            string                                                     `json:"id"`
	ARN           string                                                     `json:"arn"`
	SourceID      string                                                     `json:"source_id"`
}

type StepFunctionsStateMachineExecutionHistoriesHit struct {
	ID      string                                      `json:"_id"`
	Score   float64                                     `json:"_score"`
	Index   string                                      `json:"_index"`
	Type    string                                      `json:"_type"`
	Version int64                                       `json:"_version,omitempty"`
	Source  StepFunctionsStateMachineExecutionHistories `json:"_source"`
	Sort    []interface{}                               `json:"sort"`
}

type StepFunctionsStateMachineExecutionHistoriesHits struct {
	Total essdk.SearchTotal                                `json:"total"`
	Hits  []StepFunctionsStateMachineExecutionHistoriesHit `json:"hits"`
}

type StepFunctionsStateMachineExecutionHistoriesSearchResponse struct {
	PitID string                                          `json:"pit_id"`
	Hits  StepFunctionsStateMachineExecutionHistoriesHits `json:"hits"`
}

type StepFunctionsStateMachineExecutionHistoriesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStepFunctionsStateMachineExecutionHistoriesPaginator(filters []essdk.BoolFilter, limit *int64) (StepFunctionsStateMachineExecutionHistoriesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_stepfunctions_statemachineexecutionhistories", filters, limit)
	if err != nil {
		return StepFunctionsStateMachineExecutionHistoriesPaginator{}, err
	}

	p := StepFunctionsStateMachineExecutionHistoriesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StepFunctionsStateMachineExecutionHistoriesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StepFunctionsStateMachineExecutionHistoriesPaginator) NextPage(ctx context.Context) ([]StepFunctionsStateMachineExecutionHistories, error) {
	var response StepFunctionsStateMachineExecutionHistoriesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StepFunctionsStateMachineExecutionHistories
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStepFunctionsStateMachineExecutionHistoriesFilters = map[string]string{
	"activity_failed_event_details":                 "description.ExecutionHistory.ActivityFailedEventDetails",
	"activity_schedule_failed_event_details":        "description.ExecutionHistory.ActivityScheduleFailedEventDetails",
	"activity_scheduled_event_details":              "description.ExecutionHistory.ActivityScheduledEventDetails",
	"activity_started_event_details":                "description.ExecutionHistory.ActivityStartedEventDetails",
	"activity_succeeded_event_details":              "description.ExecutionHistory.ActivitySucceededEventDetails",
	"activity_timed_out_event_details":              "description.ExecutionHistory.ActivityTimedOutEventDetails",
	"akas":                                          "description.ARN",
	"execution_aborted_event_details":               "description.ExecutionHistory.ExecutionAbortedEventDetails",
	"execution_arn":                                 "description.ARN",
	"execution_failed_event_details":                "description.ExecutionHistory.ExecutionFailedEventDetails",
	"execution_started_event_details":               "description.ExecutionHistory.ExecutionStartedEventDetails",
	"execution_succeeded_event_details":             "description.ExecutionHistory.ExecutionSucceededEventDetails",
	"execution_timed_out_event_details":             "description.ExecutionHistory.ExecutionTimedOutEventDetails",
	"id":                                            "description.ExecutionHistory.Id",
	"kaytu_account_id":                              "metadata.SourceID",
	"lambda_function_failed_event_details":          "description.ExecutionHistory.LambdaFunctionFailedEventDetails",
	"lambda_function_schedule_failed_event_details": "description.ExecutionHistory.LambdaFunctionScheduleFailedEventDetails",
	"lambda_function_scheduled_event_details":       "description.ExecutionHistory.LambdaFunctionScheduledEventDetails",
	"lambda_function_start_failed_event_details":    "description.ExecutionHistory.LambdaFunctionStartFailedEventDetails",
	"lambda_function_succeeded_event_details":       "description.ExecutionHistory.LambdaFunctionSucceededEventDetails",
	"lambda_function_timed_out_event_details":       "description.ExecutionHistory.LambdaFunctionTimedOutEventDetails",
	"map_iteration_aborted_event_details":           "description.ExecutionHistory.MapIterationAbortedEventDetails",
	"map_iteration_failed_event_details":            "description.ExecutionHistory.MapIterationFailedEventDetails",
	"map_iteration_started_event_details":           "description.ExecutionHistory.MapIterationStartedEventDetails",
	"map_iteration_succeeded_event_details":         "description.ExecutionHistory.MapIterationSucceededEventDetails",
	"map_state_started_event_details":               "description.ExecutionHistory.MapStateStartedEventDetails",
	"previous_event_id":                             "description.ExecutionHistory.PreviousEventId",
	"state_entered_event_details":                   "description.ExecutionHistory.StateEnteredEventDetails",
	"state_exited_event_details":                    "description.ExecutionHistory.StateExitedEventDetails",
	"task_failed_event_details":                     "description.ExecutionHistory.TaskFailedEventDetails",
	"task_scheduled_event_details":                  "description.ExecutionHistory.TaskScheduledEventDetails",
	"task_start_failed_event_details":               "description.ExecutionHistory.TaskStartFailedEventDetails",
	"task_started_event_details":                    "description.ExecutionHistory.TaskStartedEventDetails",
	"task_submit_failed_event_details":              "description.ExecutionHistory.TaskSubmitFailedEventDetails",
	"task_submitted_event_details":                  "description.ExecutionHistory.TaskSubmittedEventDetails",
	"task_succeeded_event_details":                  "description.ExecutionHistory.TaskSucceededEventDetails",
	"task_timed_out_event_details":                  "description.ExecutionHistory.TaskTimedOutEventDetails",
	"timestamp":                                     "description.ExecutionHistory.Timestamp",
	"title":                                         "description.ExecutionHistory.Id",
	"type":                                          "description.ExecutionHistory.Type",
}

func ListStepFunctionsStateMachineExecutionHistories(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStepFunctionsStateMachineExecutionHistories")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStepFunctionsStateMachineExecutionHistoriesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStepFunctionsStateMachineExecutionHistoriesFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStepFunctionsStateMachineExecutionHistoriesFilters = map[string]string{
	"activity_failed_event_details":                 "description.ExecutionHistory.ActivityFailedEventDetails",
	"activity_schedule_failed_event_details":        "description.ExecutionHistory.ActivityScheduleFailedEventDetails",
	"activity_scheduled_event_details":              "description.ExecutionHistory.ActivityScheduledEventDetails",
	"activity_started_event_details":                "description.ExecutionHistory.ActivityStartedEventDetails",
	"activity_succeeded_event_details":              "description.ExecutionHistory.ActivitySucceededEventDetails",
	"activity_timed_out_event_details":              "description.ExecutionHistory.ActivityTimedOutEventDetails",
	"akas":                                          "description.ARN",
	"execution_aborted_event_details":               "description.ExecutionHistory.ExecutionAbortedEventDetails",
	"execution_arn":                                 "description.ARN",
	"execution_failed_event_details":                "description.ExecutionHistory.ExecutionFailedEventDetails",
	"execution_started_event_details":               "description.ExecutionHistory.ExecutionStartedEventDetails",
	"execution_succeeded_event_details":             "description.ExecutionHistory.ExecutionSucceededEventDetails",
	"execution_timed_out_event_details":             "description.ExecutionHistory.ExecutionTimedOutEventDetails",
	"id":                                            "description.ExecutionHistory.Id",
	"kaytu_account_id":                              "metadata.SourceID",
	"lambda_function_failed_event_details":          "description.ExecutionHistory.LambdaFunctionFailedEventDetails",
	"lambda_function_schedule_failed_event_details": "description.ExecutionHistory.LambdaFunctionScheduleFailedEventDetails",
	"lambda_function_scheduled_event_details":       "description.ExecutionHistory.LambdaFunctionScheduledEventDetails",
	"lambda_function_start_failed_event_details":    "description.ExecutionHistory.LambdaFunctionStartFailedEventDetails",
	"lambda_function_succeeded_event_details":       "description.ExecutionHistory.LambdaFunctionSucceededEventDetails",
	"lambda_function_timed_out_event_details":       "description.ExecutionHistory.LambdaFunctionTimedOutEventDetails",
	"map_iteration_aborted_event_details":           "description.ExecutionHistory.MapIterationAbortedEventDetails",
	"map_iteration_failed_event_details":            "description.ExecutionHistory.MapIterationFailedEventDetails",
	"map_iteration_started_event_details":           "description.ExecutionHistory.MapIterationStartedEventDetails",
	"map_iteration_succeeded_event_details":         "description.ExecutionHistory.MapIterationSucceededEventDetails",
	"map_state_started_event_details":               "description.ExecutionHistory.MapStateStartedEventDetails",
	"previous_event_id":                             "description.ExecutionHistory.PreviousEventId",
	"state_entered_event_details":                   "description.ExecutionHistory.StateEnteredEventDetails",
	"state_exited_event_details":                    "description.ExecutionHistory.StateExitedEventDetails",
	"task_failed_event_details":                     "description.ExecutionHistory.TaskFailedEventDetails",
	"task_scheduled_event_details":                  "description.ExecutionHistory.TaskScheduledEventDetails",
	"task_start_failed_event_details":               "description.ExecutionHistory.TaskStartFailedEventDetails",
	"task_started_event_details":                    "description.ExecutionHistory.TaskStartedEventDetails",
	"task_submit_failed_event_details":              "description.ExecutionHistory.TaskSubmitFailedEventDetails",
	"task_submitted_event_details":                  "description.ExecutionHistory.TaskSubmittedEventDetails",
	"task_succeeded_event_details":                  "description.ExecutionHistory.TaskSucceededEventDetails",
	"task_timed_out_event_details":                  "description.ExecutionHistory.TaskTimedOutEventDetails",
	"timestamp":                                     "description.ExecutionHistory.Timestamp",
	"title":                                         "description.ExecutionHistory.Id",
	"type":                                          "description.ExecutionHistory.Type",
}

func GetStepFunctionsStateMachineExecutionHistories(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStepFunctionsStateMachineExecutionHistories")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStepFunctionsStateMachineExecutionHistoriesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStepFunctionsStateMachineExecutionHistoriesFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StepFunctionsStateMachineExecutionHistories =============================

// ==========================  START: StepFunctionsStateMachineExecution =============================

type StepFunctionsStateMachineExecution struct {
	Description   aws.StepFunctionsStateMachineExecutionDescription `json:"description"`
	Metadata      aws.Metadata                                      `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type StepFunctionsStateMachineExecutionHit struct {
	ID      string                             `json:"_id"`
	Score   float64                            `json:"_score"`
	Index   string                             `json:"_index"`
	Type    string                             `json:"_type"`
	Version int64                              `json:"_version,omitempty"`
	Source  StepFunctionsStateMachineExecution `json:"_source"`
	Sort    []interface{}                      `json:"sort"`
}

type StepFunctionsStateMachineExecutionHits struct {
	Total essdk.SearchTotal                       `json:"total"`
	Hits  []StepFunctionsStateMachineExecutionHit `json:"hits"`
}

type StepFunctionsStateMachineExecutionSearchResponse struct {
	PitID string                                 `json:"pit_id"`
	Hits  StepFunctionsStateMachineExecutionHits `json:"hits"`
}

type StepFunctionsStateMachineExecutionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStepFunctionsStateMachineExecutionPaginator(filters []essdk.BoolFilter, limit *int64) (StepFunctionsStateMachineExecutionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_stepfunctions_statemachineexecution", filters, limit)
	if err != nil {
		return StepFunctionsStateMachineExecutionPaginator{}, err
	}

	p := StepFunctionsStateMachineExecutionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StepFunctionsStateMachineExecutionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StepFunctionsStateMachineExecutionPaginator) NextPage(ctx context.Context) ([]StepFunctionsStateMachineExecution, error) {
	var response StepFunctionsStateMachineExecutionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StepFunctionsStateMachineExecution
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStepFunctionsStateMachineExecutionFilters = map[string]string{
	"akas":              "description.Execution.ExecutionArn",
	"execution_arn":     "description.Execution.ExecutionArn",
	"input":             "description.Execution.Input",
	"input_details":     "description.Execution.InputDetails",
	"kaytu_account_id":  "metadata.SourceID",
	"name":              "description.Execution.Name",
	"output":            "description.Execution.Output",
	"output_details":    "description.Execution.OutputDetails",
	"start_date":        "description.Execution.StartDate",
	"state_machine_arn": "description.ExecutionItem.StateMachineArn",
	"status":            "description.ExecutionItem.Status",
	"stop_date":         "description.Execution.StopDate",
	"title":             "description.Execution.Name",
	"trace_header":      "description.Execution.TraceHeader",
}

func ListStepFunctionsStateMachineExecution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStepFunctionsStateMachineExecution")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStepFunctionsStateMachineExecutionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStepFunctionsStateMachineExecutionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStepFunctionsStateMachineExecutionFilters = map[string]string{
	"akas":              "description.Execution.ExecutionArn",
	"execution_arn":     "description.ExecutionItem.ExecutionArn",
	"input":             "description.Execution.Input",
	"input_details":     "description.Execution.InputDetails",
	"kaytu_account_id":  "metadata.SourceID",
	"name":              "description.Execution.Name",
	"output":            "description.Execution.Output",
	"output_details":    "description.Execution.OutputDetails",
	"start_date":        "description.Execution.StartDate",
	"state_machine_arn": "description.Execution.StateMachineArn",
	"status":            "description.Execution.Status",
	"stop_date":         "description.Execution.StopDate",
	"title":             "description.Execution.Name",
	"trace_header":      "description.Execution.TraceHeader",
}

func GetStepFunctionsStateMachineExecution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStepFunctionsStateMachineExecution")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStepFunctionsStateMachineExecutionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStepFunctionsStateMachineExecutionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StepFunctionsStateMachineExecution =============================

// ==========================  START: SimSpaceWeaverSimulation =============================

type SimSpaceWeaverSimulation struct {
	Description   aws.SimSpaceWeaverSimulationDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type SimSpaceWeaverSimulationHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  SimSpaceWeaverSimulation `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type SimSpaceWeaverSimulationHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []SimSpaceWeaverSimulationHit `json:"hits"`
}

type SimSpaceWeaverSimulationSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  SimSpaceWeaverSimulationHits `json:"hits"`
}

type SimSpaceWeaverSimulationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSimSpaceWeaverSimulationPaginator(filters []essdk.BoolFilter, limit *int64) (SimSpaceWeaverSimulationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_simspaceweaver_simulation", filters, limit)
	if err != nil {
		return SimSpaceWeaverSimulationPaginator{}, err
	}

	p := SimSpaceWeaverSimulationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SimSpaceWeaverSimulationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SimSpaceWeaverSimulationPaginator) NextPage(ctx context.Context) ([]SimSpaceWeaverSimulation, error) {
	var response SimSpaceWeaverSimulationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SimSpaceWeaverSimulation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSimSpaceWeaverSimulationFilters = map[string]string{
	"akas":                  "description.Simulation.Arn",
	"arn":                   "description.Simulation.Arn",
	"creation_time":         "description.Simulation.CreationTime",
	"execution_id":          "description.SimulationItem.ExecutionId",
	"kaytu_account_id":      "metadata.SourceID",
	"live_simulation_state": "description.SimulationItem.LiveSimulationState",
	"logging_configuration": "description.SimulationItem.LoggingConfiguration",
	"maximum_duration":      "description.SimulationItem.MaximumDuration",
	"name":                  "description.Simulation.Name",
	"role_arn":              "description.SimulationItem.RoleArn",
	"schema_error":          "description.SimulationItem.SchemaError",
	"schema_s3_location":    "description.SimulationItem.SchemaS3Location",
	"status":                "description.Simulation.Status",
	"tags":                  "description.Tags",
	"target_status":         "description.Simulation.TargetStatus",
	"title":                 "description.Simulation.Name",
}

func ListSimSpaceWeaverSimulation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSimSpaceWeaverSimulation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSimSpaceWeaverSimulationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSimSpaceWeaverSimulationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSimSpaceWeaverSimulationFilters = map[string]string{
	"akas":                  "description.Simulation.Arn",
	"arn":                   "description.Simulation.Arn",
	"creation_time":         "description.Simulation.CreationTime",
	"execution_id":          "description.SimulationItem.ExecutionId",
	"kaytu_account_id":      "metadata.SourceID",
	"live_simulation_state": "description.SimulationItem.LiveSimulationState",
	"logging_configuration": "description.SimulationItem.LoggingConfiguration",
	"maximum_duration":      "description.SimulationItem.MaximumDuration",
	"name":                  "description.Simulation.Name",
	"role_arn":              "description.SimulationItem.RoleArn",
	"schema_error":          "description.SimulationItem.SchemaError",
	"schema_s3_location":    "description.SimulationItem.SchemaS3Location",
	"status":                "description.Simulation.Status",
	"tags":                  "description.Tags",
	"target_status":         "description.Simulation.TargetStatus",
	"title":                 "description.Simulation.Name",
}

func GetSimSpaceWeaverSimulation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSimSpaceWeaverSimulation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSimSpaceWeaverSimulationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSimSpaceWeaverSimulationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SimSpaceWeaverSimulation =============================

// ==========================  START: ACMPCACertificateAuthority =============================

type ACMPCACertificateAuthority struct {
	Description   aws.ACMPCACertificateAuthorityDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type ACMPCACertificateAuthorityHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  ACMPCACertificateAuthority `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type ACMPCACertificateAuthorityHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []ACMPCACertificateAuthorityHit `json:"hits"`
}

type ACMPCACertificateAuthoritySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  ACMPCACertificateAuthorityHits `json:"hits"`
}

type ACMPCACertificateAuthorityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewACMPCACertificateAuthorityPaginator(filters []essdk.BoolFilter, limit *int64) (ACMPCACertificateAuthorityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_acmpca_certificateauthority", filters, limit)
	if err != nil {
		return ACMPCACertificateAuthorityPaginator{}, err
	}

	p := ACMPCACertificateAuthorityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ACMPCACertificateAuthorityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ACMPCACertificateAuthorityPaginator) NextPage(ctx context.Context) ([]ACMPCACertificateAuthority, error) {
	var response ACMPCACertificateAuthoritySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ACMPCACertificateAuthority
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listACMPCACertificateAuthorityFilters = map[string]string{
	"akas":             "description.CertificateAuthority.Arn",
	"arn":              "description.CertificateAuthority.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.CertificateAuthority.Arn",
}

func ListACMPCACertificateAuthority(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListACMPCACertificateAuthority")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewACMPCACertificateAuthorityPaginator(essdk.BuildFilter(d.KeyColumnQuals, listACMPCACertificateAuthorityFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getACMPCACertificateAuthorityFilters = map[string]string{
	"akas":             "description.CertificateAuthority.Arn",
	"arn":              "description.CertificateAuthority.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"title":            "description.CertificateAuthority.Arn",
}

func GetACMPCACertificateAuthority(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetACMPCACertificateAuthority")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewACMPCACertificateAuthorityPaginator(essdk.BuildFilter(d.KeyColumnQuals, getACMPCACertificateAuthorityFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ACMPCACertificateAuthority =============================

// ==========================  START: ShieldProtectionGroup =============================

type ShieldProtectionGroup struct {
	Description   aws.ShieldProtectionGroupDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ShieldProtectionGroupHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ShieldProtectionGroup `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ShieldProtectionGroupHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ShieldProtectionGroupHit `json:"hits"`
}

type ShieldProtectionGroupSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ShieldProtectionGroupHits `json:"hits"`
}

type ShieldProtectionGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewShieldProtectionGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ShieldProtectionGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_shield_protectiongroup", filters, limit)
	if err != nil {
		return ShieldProtectionGroupPaginator{}, err
	}

	p := ShieldProtectionGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ShieldProtectionGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ShieldProtectionGroupPaginator) NextPage(ctx context.Context) ([]ShieldProtectionGroup, error) {
	var response ShieldProtectionGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ShieldProtectionGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listShieldProtectionGroupFilters = map[string]string{
	"akas":                "description.ProtectionGroup.ProtectionGroupArn",
	"arn":                 "description.ProtectionGroup.ProtectionGroupArn",
	"kaytu_account_id":    "metadata.SourceID",
	"protection_group_id": "description.ProtectionGroup.ProtectionGroupId",
	"title":               "description.ProtectionGroup.ProtectionGroupId",
}

func ListShieldProtectionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListShieldProtectionGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewShieldProtectionGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listShieldProtectionGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getShieldProtectionGroupFilters = map[string]string{
	"akas":                "description.ProtectionGroup.ProtectionGroupArn",
	"arn":                 "description.ProtectionGroup.ProtectionGroupArn",
	"kaytu_account_id":    "metadata.SourceID",
	"protection_group_id": "description.ProtectionGroup.ProtectionGroupId",
	"title":               "description.ProtectionGroup.ProtectionGroupId",
}

func GetShieldProtectionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetShieldProtectionGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewShieldProtectionGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getShieldProtectionGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ShieldProtectionGroup =============================

// ==========================  START: StorageGatewayStorageGateway =============================

type StorageGatewayStorageGateway struct {
	Description   aws.StorageGatewayStorageGatewayDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type StorageGatewayStorageGatewayHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  StorageGatewayStorageGateway `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type StorageGatewayStorageGatewayHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []StorageGatewayStorageGatewayHit `json:"hits"`
}

type StorageGatewayStorageGatewaySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  StorageGatewayStorageGatewayHits `json:"hits"`
}

type StorageGatewayStorageGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageGatewayStorageGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (StorageGatewayStorageGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_storagegateway_storagegateway", filters, limit)
	if err != nil {
		return StorageGatewayStorageGatewayPaginator{}, err
	}

	p := StorageGatewayStorageGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageGatewayStorageGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageGatewayStorageGatewayPaginator) NextPage(ctx context.Context) ([]StorageGatewayStorageGateway, error) {
	var response StorageGatewayStorageGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageGatewayStorageGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageGatewayStorageGatewayFilters = map[string]string{
	"akas":             "description.StorageGateway.GatewayARN",
	"arn":              "description.StorageGateway.GatewayARN",
	"gateway_id":       "description.StorageGateway.GatewayId",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.StorageGateway.GatewayName",
	"title":            "description.StorageGateway.GatewayName",
}

func ListStorageGatewayStorageGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageGatewayStorageGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageGatewayStorageGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageGatewayStorageGatewayFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageGatewayStorageGatewayFilters = map[string]string{
	"akas":             "description.StorageGateway.GatewayARN",
	"arn":              "description.StorageGateway.GatewayARN",
	"gateway_id":       "description.StorageGateway.GatewayId",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.StorageGateway.GatewayName",
	"title":            "description.StorageGateway.GatewayName",
}

func GetStorageGatewayStorageGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageGatewayStorageGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageGatewayStorageGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageGatewayStorageGatewayFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageGatewayStorageGateway =============================

// ==========================  START: ImageBuilderImage =============================

type ImageBuilderImage struct {
	Description   aws.ImageBuilderImageDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ImageBuilderImageHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ImageBuilderImage `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ImageBuilderImageHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ImageBuilderImageHit `json:"hits"`
}

type ImageBuilderImageSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ImageBuilderImageHits `json:"hits"`
}

type ImageBuilderImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewImageBuilderImagePaginator(filters []essdk.BoolFilter, limit *int64) (ImageBuilderImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_imagebuilder_image", filters, limit)
	if err != nil {
		return ImageBuilderImagePaginator{}, err
	}

	p := ImageBuilderImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ImageBuilderImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ImageBuilderImagePaginator) NextPage(ctx context.Context) ([]ImageBuilderImage, error) {
	var response ImageBuilderImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ImageBuilderImage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listImageBuilderImageFilters = map[string]string{
	"akas":             "description.Image.Arn",
	"arn":              "description.Image.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Image.Name",
	"tags":             "description.Image.Tags",
	"title":            "description.Image.Name",
}

func ListImageBuilderImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListImageBuilderImage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewImageBuilderImagePaginator(essdk.BuildFilter(d.KeyColumnQuals, listImageBuilderImageFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getImageBuilderImageFilters = map[string]string{
	"akas":             "description.Image.Arn",
	"arn":              "description.Image.Arn",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Image.Name",
	"tags":             "description.Image.Tags",
	"title":            "description.Image.Name",
}

func GetImageBuilderImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetImageBuilderImage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewImageBuilderImagePaginator(essdk.BuildFilter(d.KeyColumnQuals, getImageBuilderImageFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ImageBuilderImage =============================

// ==========================  START: AccountAlternateContact =============================

type AccountAlternateContact struct {
	Description   aws.AccountAlternateContactDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type AccountAlternateContactHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  AccountAlternateContact `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type AccountAlternateContactHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []AccountAlternateContactHit `json:"hits"`
}

type AccountAlternateContactSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  AccountAlternateContactHits `json:"hits"`
}

type AccountAlternateContactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountAlternateContactPaginator(filters []essdk.BoolFilter, limit *int64) (AccountAlternateContactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_account_alternatecontact", filters, limit)
	if err != nil {
		return AccountAlternateContactPaginator{}, err
	}

	p := AccountAlternateContactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountAlternateContactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountAlternateContactPaginator) NextPage(ctx context.Context) ([]AccountAlternateContact, error) {
	var response AccountAlternateContactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccountAlternateContact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountAlternateContactFilters = map[string]string{
	"contact_title":     "description.AlternateContact.Title",
	"contact_type":      "description.AlternateContact.AlternateContactType",
	"email_address":     "description.AlternateContact.EmailAddress",
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.LinkedAccountID",
	"name":              "description.AlternateContact.Name",
	"phone_number":      "description.AlternateContact.PhoneNumber",
	"title":             "description.AlternateContact.Name",
}

func ListAccountAlternateContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccountAlternateContact")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAccountAlternateContactPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAccountAlternateContactFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAccountAlternateContactFilters = map[string]string{
	"contact_title":     "description.AlternateContact.Title",
	"contact_type":      "description.AlternateContact.AlternateContactType",
	"email_address":     "description.AlternateContact.EmailAddress",
	"kaytu_account_id":  "metadata.SourceID",
	"linked_account_id": "description.LinkedAccountID",
	"name":              "description.AlternateContact.Name",
	"phone_number":      "description.AlternateContact.PhoneNumber",
	"title":             "description.AlternateContact.Name",
}

func GetAccountAlternateContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccountAlternateContact")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAccountAlternateContactPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAccountAlternateContactFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AccountAlternateContact =============================

// ==========================  START: AccountContact =============================

type AccountContact struct {
	Description   aws.AccountContactDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type AccountContactHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AccountContact `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AccountContactHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AccountContactHit `json:"hits"`
}

type AccountContactSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AccountContactHits `json:"hits"`
}

type AccountContactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountContactPaginator(filters []essdk.BoolFilter, limit *int64) (AccountContactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_account_contact", filters, limit)
	if err != nil {
		return AccountContactPaginator{}, err
	}

	p := AccountContactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountContactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountContactPaginator) NextPage(ctx context.Context) ([]AccountContact, error) {
	var response AccountContactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccountContact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountContactFilters = map[string]string{
	"address_line_1":     "description.AlternateContact.AddressLine1",
	"address_line_2":     "description.AlternateContact.AddressLine2",
	"address_line_3":     "description.AlternateContact.AddressLine3",
	"city":               "description.AlternateContact.City",
	"company_name":       "description.AlternateContact.CompanyName",
	"country_code":       "description.AlternateContact.CountryCode",
	"district_or_county": "description.AlternateContact.DistrictOrCounty",
	"full_name":          "description.AlternateContact.FullName",
	"kaytu_account_id":   "metadata.SourceID",
	"linked_account_id":  "description.LinkedAccountID",
	"phone_number":       "description.AlternateContact.PhoneNumber",
	"postal_code":        "description.AlternateContact.PostalCode",
	"state_or_region":    "description.AlternateContact.StateOrRegion",
	"title":              "description.AlternateContact.FullName",
	"website_url":        "description.AlternateContact.WebsiteUrl",
}

func ListAccountContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccountContact")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAccountContactPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAccountContactFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAccountContactFilters = map[string]string{
	"address_line_1":     "description.AlternateContact.AddressLine1",
	"address_line_2":     "description.AlternateContact.AddressLine2",
	"address_line_3":     "description.AlternateContact.AddressLine3",
	"city":               "description.AlternateContact.City",
	"company_name":       "description.AlternateContact.CompanyName",
	"country_code":       "description.AlternateContact.CountryCode",
	"district_or_county": "description.AlternateContact.DistrictOrCounty",
	"full_name":          "description.AlternateContact.FullName",
	"kaytu_account_id":   "metadata.SourceID",
	"linked_account_id":  "description.LinkedAccountID",
	"phone_number":       "description.AlternateContact.PhoneNumber",
	"postal_code":        "description.AlternateContact.PostalCode",
	"state_or_region":    "description.AlternateContact.StateOrRegion",
	"title":              "description.AlternateContact.FullName",
	"website_url":        "description.AlternateContact.WebsiteUrl",
}

func GetAccountContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccountContact")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAccountContactPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAccountContactFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AccountContact =============================

// ==========================  START: AmplifyApp =============================

type AmplifyApp struct {
	Description   aws.AmplifyAppDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type AmplifyAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AmplifyApp    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AmplifyAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AmplifyAppHit   `json:"hits"`
}

type AmplifyAppSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  AmplifyAppHits `json:"hits"`
}

type AmplifyAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAmplifyAppPaginator(filters []essdk.BoolFilter, limit *int64) (AmplifyAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_amplify_app", filters, limit)
	if err != nil {
		return AmplifyAppPaginator{}, err
	}

	p := AmplifyAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AmplifyAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AmplifyAppPaginator) NextPage(ctx context.Context) ([]AmplifyApp, error) {
	var response AmplifyAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AmplifyApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAmplifyAppFilters = map[string]string{
	"akas":                          "description.App.AppArn",
	"app_id":                        "description.App.AppId",
	"arn":                           "description.App.AppArn",
	"auto_branch_creation_config":   "description.App.AutoBranchCreationConfig",
	"auto_branch_creation_patterns": "description.App.AutoBranchCreationPatterns",
	"basic_auth_credentials":        "description.App.BasicAuthCredentials",
	"build_spec":                    "description.App.BuildSpec",
	"create_time":                   "description.App.CreateTime",
	"custom_headers":                "description.App.CustomHeaders",
	"custom_rules":                  "description.App.CustomRules",
	"default_domain":                "description.App.DefaultDomain",
	"description":                   "description.App.Description",
	"enable_auto_branch_creation":   "description.App.EnableAutoBranchCreation",
	"enable_basic_auth":             "description.App.EnableBasicAuth",
	"enable_branch_auto_build":      "description.App.EnableBranchAutoBuild",
	"enable_branch_auto_deletion":   "description.App.EnableBranchAutoDeletion",
	"environment_variables":         "description.App.EnvironmentVariables",
	"iam_service_role_arn":          "description.App.IamServiceRoleArn",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.App.Name",
	"platform":                      "description.App.Platform",
	"production_branch":             "description.App.ProductionBranch",
	"repository":                    "description.App.Repository",
	"repository_clone_method":       "description.App.RepositoryCloneMethod",
	"tags":                          "description.App.Tags",
	"title":                         "description.App.Name",
	"update_time":                   "description.App.UpdateTime",
}

func ListAmplifyApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAmplifyApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAmplifyAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAmplifyAppFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAmplifyAppFilters = map[string]string{
	"akas":                          "description.App.AppArn",
	"app_id":                        "description.App.AppId",
	"arn":                           "description.App.AppArn",
	"auto_branch_creation_config":   "description.App.AutoBranchCreationConfig",
	"auto_branch_creation_patterns": "description.App.AutoBranchCreationPatterns",
	"basic_auth_credentials":        "description.App.BasicAuthCredentials",
	"build_spec":                    "description.App.BuildSpec",
	"create_time":                   "description.App.CreateTime",
	"custom_headers":                "description.App.CustomHeaders",
	"custom_rules":                  "description.App.CustomRules",
	"default_domain":                "description.App.DefaultDomain",
	"description":                   "description.App.Description",
	"enable_auto_branch_creation":   "description.App.EnableAutoBranchCreation",
	"enable_basic_auth":             "description.App.EnableBasicAuth",
	"enable_branch_auto_build":      "description.App.EnableBranchAutoBuild",
	"enable_branch_auto_deletion":   "description.App.EnableBranchAutoDeletion",
	"environment_variables":         "description.App.EnvironmentVariables",
	"iam_service_role_arn":          "description.App.IamServiceRoleArn",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.App.Name",
	"platform":                      "description.App.Platform",
	"production_branch":             "description.App.ProductionBranch",
	"repository":                    "description.App.Repository",
	"repository_clone_method":       "description.App.RepositoryCloneMethod",
	"tags":                          "description.App.Tags",
	"title":                         "description.App.Name",
	"update_time":                   "description.App.UpdateTime",
}

func GetAmplifyApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAmplifyApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAmplifyAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAmplifyAppFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AmplifyApp =============================

// ==========================  START: AppConfigApplication =============================

type AppConfigApplication struct {
	Description   aws.AppConfigApplicationDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AppConfigApplicationHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AppConfigApplication `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AppConfigApplicationHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AppConfigApplicationHit `json:"hits"`
}

type AppConfigApplicationSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AppConfigApplicationHits `json:"hits"`
}

type AppConfigApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppConfigApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (AppConfigApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appconfig_application", filters, limit)
	if err != nil {
		return AppConfigApplicationPaginator{}, err
	}

	p := AppConfigApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppConfigApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppConfigApplicationPaginator) NextPage(ctx context.Context) ([]AppConfigApplication, error) {
	var response AppConfigApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppConfigApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppConfigApplicationFilters = map[string]string{
	"akas":             "aRN",
	"arn":              "aRN",
	"description":      "description.Application.Description",
	"id":               "description.Application.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Application.Name",
	"tags":             "description.Tags",
	"title":            "description.Application.Name",
}

func ListAppConfigApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppConfigApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppConfigApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppConfigApplicationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppConfigApplicationFilters = map[string]string{
	"akas":             "aRN",
	"arn":              "aRN",
	"description":      "description.Application.Description",
	"id":               "description.Application.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Application.Name",
	"tags":             "description.Tags",
	"title":            "description.Application.Name",
}

func GetAppConfigApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppConfigApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppConfigApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppConfigApplicationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppConfigApplication =============================

// ==========================  START: AuditManagerAssessment =============================

type AuditManagerAssessment struct {
	Description   aws.AuditManagerAssessmentDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type AuditManagerAssessmentHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  AuditManagerAssessment `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type AuditManagerAssessmentHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []AuditManagerAssessmentHit `json:"hits"`
}

type AuditManagerAssessmentSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  AuditManagerAssessmentHits `json:"hits"`
}

type AuditManagerAssessmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerAssessmentPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerAssessmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_assessment", filters, limit)
	if err != nil {
		return AuditManagerAssessmentPaginator{}, err
	}

	p := AuditManagerAssessmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerAssessmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerAssessmentPaginator) NextPage(ctx context.Context) ([]AuditManagerAssessment, error) {
	var response AuditManagerAssessmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerAssessment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerAssessmentFilters = map[string]string{
	"akas":                               "aRN",
	"arn":                                "aRN",
	"assessment_report_destination":      "description.Assessment.Metadata.AssessmentReportsDestination.Destination",
	"assessment_report_destination_type": "description.Assessment.Metadata.AssessmentReportsDestination.DestinationType",
	"aws_account":                        "description.Assessment.AwsAccount",
	"compliance_type":                    "description.Assessment.Metadata.ComplianceType",
	"creation_time":                      "description.Assessment.Metadata.CreationTime",
	"delegations":                        "description.Assessment.Metadata.Delegations",
	"description":                        "description.Assessment.Metadata.Description",
	"framework":                          "description.Assessment.Framework",
	"id":                                 "description.Assessment.Metadata.Id",
	"kaytu_account_id":                   "metadata.SourceID",
	"last_updated":                       "description.Assessment.Metadata.LastUpdated",
	"name":                               "description.Assessment.Metadata.Name",
	"roles":                              "description.Assessment.Metadata.Roles",
	"scope":                              "description.Assessment.Metadata.Scope",
	"status":                             "description.Assessment.Metadata.Status",
	"tags":                               "description.Assessment.Tags",
	"title":                              "description.Assessment.Metadata.Name",
}

func ListAuditManagerAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerAssessment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAuditManagerAssessmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAuditManagerAssessmentFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAuditManagerAssessmentFilters = map[string]string{
	"akas":                               "aRN",
	"arn":                                "aRN",
	"assessment_id":                      "description.Assessment.Metadata.Id",
	"assessment_report_destination":      "description.Assessment.Metadata.AssessmentReportsDestination.Destination",
	"assessment_report_destination_type": "description.Assessment.Metadata.AssessmentReportsDestination.DestinationType",
	"aws_account":                        "description.Assessment.AwsAccount",
	"compliance_type":                    "description.Assessment.Metadata.ComplianceType",
	"creation_time":                      "description.Assessment.Metadata.CreationTime",
	"delegations":                        "description.Assessment.Metadata.Delegations",
	"description":                        "description.Assessment.Metadata.Description",
	"framework":                          "description.Assessment.Framework",
	"id":                                 "description.Assessment.Metadata.Id",
	"kaytu_account_id":                   "metadata.SourceID",
	"last_updated":                       "description.Assessment.Metadata.LastUpdated",
	"name":                               "description.Assessment.Metadata.Name",
	"roles":                              "description.Assessment.Metadata.Roles",
	"scope":                              "description.Assessment.Metadata.Scope",
	"status":                             "description.Assessment.Metadata.Status",
	"tags":                               "description.Assessment.Tags",
	"title":                              "description.Assessment.Metadata.Name",
}

func GetAuditManagerAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerAssessment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAuditManagerAssessmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAuditManagerAssessmentFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AuditManagerAssessment =============================

// ==========================  START: AuditManagerControl =============================

type AuditManagerControl struct {
	Description   aws.AuditManagerControlDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type AuditManagerControlHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  AuditManagerControl `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type AuditManagerControlHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []AuditManagerControlHit `json:"hits"`
}

type AuditManagerControlSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  AuditManagerControlHits `json:"hits"`
}

type AuditManagerControlPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerControlPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerControlPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_control", filters, limit)
	if err != nil {
		return AuditManagerControlPaginator{}, err
	}

	p := AuditManagerControlPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerControlPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerControlPaginator) NextPage(ctx context.Context) ([]AuditManagerControl, error) {
	var response AuditManagerControlSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerControl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerControlFilters = map[string]string{
	"action_plan_instructions": "description.Control.ActionPlanInstructions",
	"action_plan_title":        "description.Control.ActionPlanTitle",
	"akas":                     "description.Control.Arn",
	"arn":                      "description.Control.Arn",
	"control_mapping_sources":  "description.Control.ControlMappingSources",
	"control_sources":          "description.Control.ControlSources",
	"created_at":               "description.Control.CreatedAt",
	"created_by":               "description.Control.CreatedBy",
	"description":              "description.Control.Description",
	"id":                       "description.Control.Id",
	"kaytu_account_id":         "metadata.SourceID",
	"last_updated_at":          "description.Control.LastUpdatedAt",
	"last_updated_by":          "description.Control.LastUpdatedBy",
	"name":                     "description.Control.Name",
	"tags":                     "description.Control.Tags",
	"testing_information":      "description.Control.TestingInformation",
	"title":                    "description.Control.Name",
	"type":                     "description.Control.Type",
}

func ListAuditManagerControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerControl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAuditManagerControlPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAuditManagerControlFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAuditManagerControlFilters = map[string]string{
	"action_plan_instructions": "description.Control.ActionPlanInstructions",
	"action_plan_title":        "description.Control.ActionPlanTitle",
	"akas":                     "description.Control.Arn",
	"arn":                      "description.Control.Arn",
	"control_id":               "description.Control.Id",
	"control_mapping_sources":  "description.Control.ControlMappingSources",
	"control_sources":          "description.Control.ControlSources",
	"created_at":               "description.Control.CreatedAt",
	"created_by":               "description.Control.CreatedBy",
	"description":              "description.Control.Description",
	"id":                       "description.Control.Id",
	"kaytu_account_id":         "metadata.SourceID",
	"last_updated_at":          "description.Control.LastUpdatedAt",
	"last_updated_by":          "description.Control.LastUpdatedBy",
	"name":                     "description.Control.Name",
	"tags":                     "description.Control.Tags",
	"testing_information":      "description.Control.TestingInformation",
	"title":                    "description.Control.Name",
	"type":                     "description.Control.Type",
}

func GetAuditManagerControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerControl")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAuditManagerControlPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAuditManagerControlFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AuditManagerControl =============================

// ==========================  START: AuditManagerEvidence =============================

type AuditManagerEvidence struct {
	Description   aws.AuditManagerEvidenceDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AuditManagerEvidenceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AuditManagerEvidence `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AuditManagerEvidenceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AuditManagerEvidenceHit `json:"hits"`
}

type AuditManagerEvidenceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AuditManagerEvidenceHits `json:"hits"`
}

type AuditManagerEvidencePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerEvidencePaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerEvidencePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_evidence", filters, limit)
	if err != nil {
		return AuditManagerEvidencePaginator{}, err
	}

	p := AuditManagerEvidencePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerEvidencePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerEvidencePaginator) NextPage(ctx context.Context) ([]AuditManagerEvidence, error) {
	var response AuditManagerEvidenceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerEvidence
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerEvidenceFilters = map[string]string{
	"akas":                        "aRN",
	"arn":                         "aRN",
	"assessment_id":               "description.AssessmentID",
	"assessment_report_selection": "description.Evidence.AssessmentReportSelection",
	"attributes":                  "description.Evidence.Attributes",
	"aws_account_id":              "description.Evidence.AwsAccountId",
	"aws_organization":            "description.Evidence.AwsOrganization",
	"compliance_check":            "description.Evidence.ComplianceCheck",
	"control_set_id":              "description.ControlSetID",
	"data_source":                 "description.Evidence.DataSource",
	"event_name":                  "description.Evidence.EventName",
	"event_source":                "description.Evidence.EventSource",
	"evidence_aws_account_id":     "description.Evidence.EvidenceAwsAccountId",
	"evidence_by_type":            "description.Evidence.EvidenceByType",
	"evidence_folder_id":          "description.Evidence.EvidenceFolderId",
	"iam_id":                      "description.Evidence.IamId",
	"id":                          "description.Evidence.Id",
	"kaytu_account_id":            "metadata.SourceID",
	"resources_included":          "description.Evidence.ResourcesIncluded",
	"time":                        "description.Evidence.Time",
	"title":                       "description.Evidence.Id",
}

func ListAuditManagerEvidence(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerEvidence")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAuditManagerEvidencePaginator(essdk.BuildFilter(d.KeyColumnQuals, listAuditManagerEvidenceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAuditManagerEvidenceFilters = map[string]string{
	"akas":                        "aRN",
	"arn":                         "aRN",
	"assessment_id":               "description.AssessmentID",
	"assessment_report_selection": "description.Evidence.AssessmentReportSelection",
	"attributes":                  "description.Evidence.Attributes",
	"aws_account_id":              "description.Evidence.AwsAccountId",
	"aws_organization":            "description.Evidence.AwsOrganization",
	"compliance_check":            "description.Evidence.ComplianceCheck",
	"control_set_id":              "description.ControlSetID",
	"data_source":                 "description.Evidence.DataSource",
	"event_name":                  "description.Evidence.EventName",
	"event_source":                "description.Evidence.EventSource",
	"evidence_aws_account_id":     "description.Evidence.EvidenceAwsAccountId",
	"evidence_by_type":            "description.Evidence.EvidenceByType",
	"evidence_folder_id":          "description.Evidence.EvidenceFolderId",
	"iam_id":                      "description.Evidence.IamId",
	"id":                          "description.Evidence.Id",
	"kaytu_account_id":            "metadata.SourceID",
	"resources_included":          "description.Evidence.ResourcesIncluded",
	"time":                        "description.Evidence.Time",
	"title":                       "description.Evidence.Id",
}

func GetAuditManagerEvidence(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerEvidence")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAuditManagerEvidencePaginator(essdk.BuildFilter(d.KeyColumnQuals, getAuditManagerEvidenceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AuditManagerEvidence =============================

// ==========================  START: AuditManagerEvidenceFolder =============================

type AuditManagerEvidenceFolder struct {
	Description   aws.AuditManagerEvidenceFolderDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type AuditManagerEvidenceFolderHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  AuditManagerEvidenceFolder `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type AuditManagerEvidenceFolderHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []AuditManagerEvidenceFolderHit `json:"hits"`
}

type AuditManagerEvidenceFolderSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  AuditManagerEvidenceFolderHits `json:"hits"`
}

type AuditManagerEvidenceFolderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerEvidenceFolderPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerEvidenceFolderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_evidencefolder", filters, limit)
	if err != nil {
		return AuditManagerEvidenceFolderPaginator{}, err
	}

	p := AuditManagerEvidenceFolderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerEvidenceFolderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerEvidenceFolderPaginator) NextPage(ctx context.Context) ([]AuditManagerEvidenceFolder, error) {
	var response AuditManagerEvidenceFolderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerEvidenceFolder
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerEvidenceFolderFilters = map[string]string{
	"akas":                              "aRN",
	"arn":                               "aRN",
	"assessment_id":                     "description.AssessmentID",
	"assessment_report_selection_count": "description.EvidenceFolder.AssessmentReportSelectionCount",
	"author":                            "description.EvidenceFolder.Author",
	"control_id":                        "description.EvidenceFolder.ControlId",
	"control_name":                      "description.EvidenceFolder.ControlName",
	"control_set_id":                    "description.EvidenceFolder.ControlSetId",
	"data_source":                       "description.EvidenceFolder.DataSource",
	"date":                              "description.EvidenceFolder.Date",
	"evidence_aws_service_source_count": "description.EvidenceFolder.EvidenceAwsServiceSourceCount",
	"evidence_by_type_compliance_check_count":        "description.EvidenceFolder.EvidenceByTypeComplianceCheckCount",
	"evidence_by_type_compliance_check_issues_count": "description.EvidenceFolder.EvidenceByTypeComplianceCheckIssuesCount",
	"evidence_by_type_configuration_data_count":      "description.EvidenceFolder.EvidenceByTypeConfigurationDataCount",
	"evidence_by_type_manual_count":                  "description.EvidenceFolder.EvidenceByTypeManualCount",
	"evidence_by_type_user_activity_count":           "description.EvidenceFolder.EvidenceByTypeUserActivityCount",
	"evidence_resources_included_count":              "description.EvidenceFolder.EvidenceResourcesIncludedCount",
	"id":                                             "description.EvidenceFolder.Id",
	"kaytu_account_id":                               "metadata.SourceID",
	"name":                                           "description.EvidenceFolder.Name",
	"title":                                          "description.EvidenceFolder.Name",
	"total_evidence":                                 "description.EvidenceFolder.TotalEvidence",
}

func ListAuditManagerEvidenceFolder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerEvidenceFolder")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAuditManagerEvidenceFolderPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAuditManagerEvidenceFolderFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAuditManagerEvidenceFolderFilters = map[string]string{
	"akas":                              "aRN",
	"arn":                               "aRN",
	"assessment_id":                     "description.AssessmentID",
	"assessment_report_selection_count": "description.EvidenceFolder.AssessmentReportSelectionCount",
	"author":                            "description.EvidenceFolder.Author",
	"control_id":                        "description.EvidenceFolder.ControlId",
	"control_name":                      "description.EvidenceFolder.ControlName",
	"control_set_id":                    "description.ControlSetID",
	"data_source":                       "description.EvidenceFolder.DataSource",
	"date":                              "description.EvidenceFolder.Date",
	"evidence_aws_service_source_count": "description.EvidenceFolder.EvidenceAwsServiceSourceCount",
	"evidence_by_type_compliance_check_count":        "description.EvidenceFolder.EvidenceByTypeComplianceCheckCount",
	"evidence_by_type_compliance_check_issues_count": "description.EvidenceFolder.EvidenceByTypeComplianceCheckIssuesCount",
	"evidence_by_type_configuration_data_count":      "description.EvidenceFolder.EvidenceByTypeConfigurationDataCount",
	"evidence_by_type_manual_count":                  "description.EvidenceFolder.EvidenceByTypeManualCount",
	"evidence_by_type_user_activity_count":           "description.EvidenceFolder.EvidenceByTypeUserActivityCount",
	"evidence_resources_included_count":              "description.EvidenceFolder.EvidenceResourcesIncludedCount",
	"id":                                             "description.EvidenceFolder.Id",
	"kaytu_account_id":                               "metadata.SourceID",
	"name":                                           "description.EvidenceFolder.Name",
	"title":                                          "description.EvidenceFolder.Name",
	"total_evidence":                                 "description.EvidenceFolder.TotalEvidence",
}

func GetAuditManagerEvidenceFolder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerEvidenceFolder")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAuditManagerEvidenceFolderPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAuditManagerEvidenceFolderFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AuditManagerEvidenceFolder =============================

// ==========================  START: AuditManagerFramework =============================

type AuditManagerFramework struct {
	Description   aws.AuditManagerFrameworkDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type AuditManagerFrameworkHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AuditManagerFramework `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AuditManagerFrameworkHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AuditManagerFrameworkHit `json:"hits"`
}

type AuditManagerFrameworkSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AuditManagerFrameworkHits `json:"hits"`
}

type AuditManagerFrameworkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerFrameworkPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerFrameworkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_framework", filters, limit)
	if err != nil {
		return AuditManagerFrameworkPaginator{}, err
	}

	p := AuditManagerFrameworkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerFrameworkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerFrameworkPaginator) NextPage(ctx context.Context) ([]AuditManagerFramework, error) {
	var response AuditManagerFrameworkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerFramework
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerFrameworkFilters = map[string]string{
	"akas":               "description.Framework.Arn",
	"arn":                "description.Framework.Arn",
	"compliance_type":    "description.Framework.ComplianceType",
	"control_sets":       "description.Framework.ControlSets",
	"control_sets_count": "description.Framework.ControlSources",
	"control_sources":    "description.Framework.ControlSources",
	"controls_count":     "description.Framework.ControlSources",
	"created_at":         "description.Framework.CreatedAt",
	"created_by":         "description.Framework.CreatedBy",
	"description":        "description.Framework.Description",
	"id":                 "description.Framework.Id",
	"kaytu_account_id":   "metadata.SourceID",
	"last_updated_at":    "description.Framework.LastUpdatedAt",
	"last_updated_by":    "description.Framework.LastUpdatedBy",
	"logo":               "description.Framework.Logo",
	"name":               "description.Framework.Name",
	"tags":               "description.Framework.Tags",
	"title":              "description.Framework.Name",
	"type":               "description.Framework.Type",
}

func ListAuditManagerFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerFramework")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAuditManagerFrameworkPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAuditManagerFrameworkFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAuditManagerFrameworkFilters = map[string]string{
	"akas":               "description.Framework.Arn",
	"arn":                "description.Framework.Arn",
	"compliance_type":    "description.Framework.ComplianceType",
	"control_sets":       "description.Framework.ControlSets",
	"control_sets_count": "description.Framework.ControlSources",
	"control_sources":    "description.Framework.ControlSources",
	"controls_count":     "description.Framework.ControlSources",
	"created_at":         "description.Framework.CreatedAt",
	"created_by":         "description.Framework.CreatedBy",
	"description":        "description.Framework.Description",
	"id":                 "description.Framework.Id",
	"kaytu_account_id":   "metadata.SourceID",
	"last_updated_at":    "description.Framework.LastUpdatedAt",
	"last_updated_by":    "description.Framework.LastUpdatedBy",
	"logo":               "description.Framework.Logo",
	"name":               "description.Framework.Name",
	"region":             "metadata.Region",
	"tags":               "description.Framework.Tags",
	"title":              "description.Framework.Name",
	"type":               "description.Framework.Type",
}

func GetAuditManagerFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerFramework")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAuditManagerFrameworkPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAuditManagerFrameworkFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AuditManagerFramework =============================

// ==========================  START: CloudSearchDomain =============================

type CloudSearchDomain struct {
	Description   aws.CloudSearchDomainDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type CloudSearchDomainHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  CloudSearchDomain `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type CloudSearchDomainHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []CloudSearchDomainHit `json:"hits"`
}

type CloudSearchDomainSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  CloudSearchDomainHits `json:"hits"`
}

type CloudSearchDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudSearchDomainPaginator(filters []essdk.BoolFilter, limit *int64) (CloudSearchDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudsearch_domain", filters, limit)
	if err != nil {
		return CloudSearchDomainPaginator{}, err
	}

	p := CloudSearchDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudSearchDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudSearchDomainPaginator) NextPage(ctx context.Context) ([]CloudSearchDomain, error) {
	var response CloudSearchDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudSearchDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudSearchDomainFilters = map[string]string{
	"akas":                     "aRN",
	"arn":                      "aRN",
	"created":                  "description.DomainStatus.Created",
	"deleted":                  "description.DomainStatus.Deleted",
	"doc_service":              "description.DomainStatus.DocService",
	"domain_id":                "description.DomainStatus.DomainId",
	"domain_name":              "description.DomainStatus.DomainName",
	"kaytu_account_id":         "metadata.SourceID",
	"limits":                   "description.DomainStatus.Limits",
	"processing":               "description.DomainStatus.Processing",
	"requires_index_documents": "description.DomainStatus.RequiresIndexDocuments",
	"search_instance_count":    "description.DomainStatus.SearchInstanceCount",
	"search_instance_type":     "description.DomainStatus.SearchInstanceType",
	"search_partition_count":   "description.DomainStatus.SearchPartitionCount",
	"search_service":           "description.DomainStatus.SearchService",
	"title":                    "description.DomainStatus.DomainName",
}

func ListCloudSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudSearchDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCloudSearchDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCloudSearchDomainFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCloudSearchDomainFilters = map[string]string{
	"akas":                     "aRN",
	"arn":                      "aRN",
	"created":                  "description.DomainStatus.Created",
	"deleted":                  "description.DomainStatus.Deleted",
	"doc_service":              "description.DomainStatus.DocService",
	"domain_id":                "description.DomainStatus.DomainId",
	"domain_name":              "description.DomainStatus.DomainName",
	"kaytu_account_id":         "metadata.SourceID",
	"limits":                   "description.DomainStatus.Limits",
	"processing":               "description.DomainStatus.Processing",
	"requires_index_documents": "description.DomainStatus.RequiresIndexDocuments",
	"search_instance_count":    "description.DomainStatus.SearchInstanceCount",
	"search_instance_type":     "description.DomainStatus.SearchInstanceType",
	"search_partition_count":   "description.DomainStatus.SearchPartitionCount",
	"search_service":           "description.DomainStatus.SearchService",
	"title":                    "description.DomainStatus.DomainName",
}

func GetCloudSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudSearchDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCloudSearchDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCloudSearchDomainFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CloudSearchDomain =============================

// ==========================  START: DLMLifecyclePolicy =============================

type DLMLifecyclePolicy struct {
	Description   aws.DLMLifecyclePolicyDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type DLMLifecyclePolicyHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  DLMLifecyclePolicy `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type DLMLifecyclePolicyHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []DLMLifecyclePolicyHit `json:"hits"`
}

type DLMLifecyclePolicySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  DLMLifecyclePolicyHits `json:"hits"`
}

type DLMLifecyclePolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDLMLifecyclePolicyPaginator(filters []essdk.BoolFilter, limit *int64) (DLMLifecyclePolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dlm_lifecyclepolicy", filters, limit)
	if err != nil {
		return DLMLifecyclePolicyPaginator{}, err
	}

	p := DLMLifecyclePolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DLMLifecyclePolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DLMLifecyclePolicyPaginator) NextPage(ctx context.Context) ([]DLMLifecyclePolicy, error) {
	var response DLMLifecyclePolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DLMLifecyclePolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDLMLifecyclePolicyFilters = map[string]string{
	"akas":               "description.LifecyclePolicy.PolicyArn",
	"arn":                "description.LifecyclePolicy.PolicyArn",
	"date_created":       "description.LifecyclePolicy.DateCreated",
	"date_modified":      "description.LifecyclePolicy.DateModified",
	"description":        "description.LifecyclePolicy.Description",
	"execution_role_arn": "description.LifecyclePolicy.ExecutionRoleArn",
	"kaytu_account_id":   "metadata.SourceID",
	"policy_details":     "description.LifecyclePolicy.PolicyDetails",
	"policy_id":          "description.LifecyclePolicy.PolicyId",
	"policy_type":        "description.LifecyclePolicy.PolicyDetails.PolicyType",
	"state":              "description.LifecyclePolicy.State",
	"status_message":     "description.LifecyclePolicy.StatusMessage",
	"tags":               "description.LifecyclePolicy.Tags",
	"title":              "description.LifecyclePolicy.PolicyId",
}

func ListDLMLifecyclePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDLMLifecyclePolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDLMLifecyclePolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDLMLifecyclePolicyFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDLMLifecyclePolicyFilters = map[string]string{
	"akas":               "description.LifecyclePolicy.PolicyArn",
	"arn":                "description.LifecyclePolicy.PolicyArn",
	"date_created":       "description.LifecyclePolicy.DateCreated",
	"date_modified":      "description.LifecyclePolicy.DateModified",
	"description":        "description.LifecyclePolicy.Description",
	"execution_role_arn": "description.LifecyclePolicy.ExecutionRoleArn",
	"id":                 "description.LifecyclePolicy.PolicyId",
	"kaytu_account_id":   "metadata.SourceID",
	"policy_details":     "description.LifecyclePolicy.PolicyDetails",
	"policy_id":          "description.LifecyclePolicy.PolicyId",
	"policy_type":        "description.LifecyclePolicy.PolicyDetails.PolicyType",
	"state":              "description.LifecyclePolicy.State",
	"status_message":     "description.LifecyclePolicy.StatusMessage",
	"tags":               "description.LifecyclePolicy.Tags",
	"title":              "description.LifecyclePolicy.PolicyId",
}

func GetDLMLifecyclePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDLMLifecyclePolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDLMLifecyclePolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDLMLifecyclePolicyFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DLMLifecyclePolicy =============================

// ==========================  START: DocDBCluster =============================

type DocDBCluster struct {
	Description   aws.DocDBClusterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type DocDBClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DocDBCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DocDBClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DocDBClusterHit `json:"hits"`
}

type DocDBClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  DocDBClusterHits `json:"hits"`
}

type DocDBClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDocDBClusterPaginator(filters []essdk.BoolFilter, limit *int64) (DocDBClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_docdb_cluster", filters, limit)
	if err != nil {
		return DocDBClusterPaginator{}, err
	}

	p := DocDBClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DocDBClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DocDBClusterPaginator) NextPage(ctx context.Context) ([]DocDBCluster, error) {
	var response DocDBClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DocDBCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDocDBClusterFilters = map[string]string{
	"akas":                            "description.DBCluster.DBClusterArn",
	"arn":                             "description.DBCluster.DBClusterArn",
	"associated_roles":                "description.DBCluster.AssociatedRoles",
	"availability_zones":              "description.DBCluster.AvailabilityZones",
	"backup_retention_period":         "description.DBCluster.BackupRetentionPeriod",
	"clone_group_id":                  "description.DBCluster.CloneGroupId",
	"cluster_create_time":             "description.DBCluster.ClusterCreateTime",
	"db_cluster_identifier":           "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":      "description.DBCluster.DBClusterParameterGroup",
	"db_cluster_resource_id":          "description.DBCluster.DbClusterResourceId",
	"db_subnet_group":                 "description.DBCluster.DBSubnetGroup",
	"deletion_protection":             "description.DBCluster.DeletionProtection",
	"earliest_restorable_time":        "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports": "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                        "description.DBCluster.Endpoint",
	"engine":                          "description.DBCluster.Engine",
	"engine_version":                  "description.DBCluster.EngineVersion",
	"hosted_zone_id":                  "description.DBCluster.HostedZoneId",
	"kaytu_account_id":                "metadata.SourceID",
	"kms_key_id":                      "description.DBCluster.KmsKeyId",
	"latest_restorable_time":          "description.DBCluster.LatestRestorableTime",
	"master_user_name":                "description.DBCluster.MasterUsername",
	"members":                         "description.DBCluster.DBClusterMembers",
	"multi_az":                        "description.DBCluster.MultiAZ",
	"percent_progress":                "description.DBCluster.PercentProgress",
	"port":                            "description.DBCluster.Port",
	"preferred_backup_window":         "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":    "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":        "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                 "description.DBCluster.ReaderEndpoint",
	"replication_source_identifier":   "description.DBCluster.ReplicationSourceIdentifier",
	"status":                          "description.DBCluster.Status",
	"storage_encrypted":               "description.DBCluster.StorageEncrypted",
	"tags":                            "description.Tags",
	"tags_src":                        "description.Tags",
	"title":                           "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":             "description.DBCluster.VpcSecurityGroups",
}

func ListDocDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDocDBCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDocDBClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDocDBClusterFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDocDBClusterFilters = map[string]string{
	"akas":                            "description.DBCluster.DBClusterArn",
	"arn":                             "description.DBCluster.DBClusterArn",
	"associated_roles":                "description.DBCluster.AssociatedRoles",
	"availability_zones":              "description.DBCluster.AvailabilityZones",
	"backup_retention_period":         "description.DBCluster.BackupRetentionPeriod",
	"clone_group_id":                  "description.DBCluster.CloneGroupId",
	"cluster_create_time":             "description.DBCluster.ClusterCreateTime",
	"db_cluster_identifier":           "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":      "description.DBCluster.DBClusterParameterGroup",
	"db_cluster_resource_id":          "description.DBCluster.DbClusterResourceId",
	"db_subnet_group":                 "description.DBCluster.DBSubnetGroup",
	"deletion_protection":             "description.DBCluster.DeletionProtection",
	"earliest_restorable_time":        "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports": "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                        "description.DBCluster.Endpoint",
	"engine":                          "description.DBCluster.Engine",
	"engine_version":                  "description.DBCluster.EngineVersion",
	"hosted_zone_id":                  "description.DBCluster.HostedZoneId",
	"kaytu_account_id":                "metadata.SourceID",
	"kms_key_id":                      "description.DBCluster.KmsKeyId",
	"latest_restorable_time":          "description.DBCluster.LatestRestorableTime",
	"master_user_name":                "description.DBCluster.MasterUsername",
	"members":                         "description.DBCluster.DBClusterMembers",
	"multi_az":                        "description.DBCluster.MultiAZ",
	"percent_progress":                "description.DBCluster.PercentProgress",
	"port":                            "description.DBCluster.Port",
	"preferred_backup_window":         "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":    "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":        "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                 "description.DBCluster.ReaderEndpoint",
	"replication_source_identifier":   "description.DBCluster.ReplicationSourceIdentifier",
	"status":                          "description.DBCluster.Status",
	"storage_encrypted":               "description.DBCluster.StorageEncrypted",
	"tags":                            "description.Tags",
	"tags_src":                        "description.Tags",
	"title":                           "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":             "description.DBCluster.VpcSecurityGroups",
}

func GetDocDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDocDBCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDocDBClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDocDBClusterFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DocDBCluster =============================

// ==========================  START: GlobalAcceleratorAccelerator =============================

type GlobalAcceleratorAccelerator struct {
	Description   aws.GlobalAcceleratorAcceleratorDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type GlobalAcceleratorAcceleratorHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  GlobalAcceleratorAccelerator `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type GlobalAcceleratorAcceleratorHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []GlobalAcceleratorAcceleratorHit `json:"hits"`
}

type GlobalAcceleratorAcceleratorSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  GlobalAcceleratorAcceleratorHits `json:"hits"`
}

type GlobalAcceleratorAcceleratorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlobalAcceleratorAcceleratorPaginator(filters []essdk.BoolFilter, limit *int64) (GlobalAcceleratorAcceleratorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_globalaccelerator_accelerator", filters, limit)
	if err != nil {
		return GlobalAcceleratorAcceleratorPaginator{}, err
	}

	p := GlobalAcceleratorAcceleratorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlobalAcceleratorAcceleratorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlobalAcceleratorAcceleratorPaginator) NextPage(ctx context.Context) ([]GlobalAcceleratorAccelerator, error) {
	var response GlobalAcceleratorAcceleratorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlobalAcceleratorAccelerator
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlobalAcceleratorAcceleratorFilters = map[string]string{
	"accelerator_attributes": "description.AcceleratorAttributes",
	"akas":                   "description.Accelerator.AcceleratorArn",
	"arn":                    "description.Accelerator.AcceleratorArn",
	"created_time":           "description.Accelerator.CreatedTime",
	"dns_name":               "description.Accelerator.DnsName",
	"enabled":                "description.Accelerator.Enabled",
	"ip_address_type":        "description.Accelerator.IpAddressType",
	"ip_sets":                "description.Accelerator.IpSets",
	"kaytu_account_id":       "metadata.SourceID",
	"last_modified_time":     "description.Accelerator.LastModifiedTime",
	"name":                   "description.Accelerator.Name",
	"status":                 "description.Accelerator.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Accelerator.Name",
}

func ListGlobalAcceleratorAccelerator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlobalAcceleratorAccelerator")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlobalAcceleratorAcceleratorPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlobalAcceleratorAcceleratorFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlobalAcceleratorAcceleratorFilters = map[string]string{
	"accelerator_attributes": "description.AcceleratorAttributes",
	"akas":                   "description.Accelerator.AcceleratorArn",
	"arn":                    "description.Accelerator.AcceleratorArn",
	"created_time":           "description.Accelerator.CreatedTime",
	"dns_name":               "description.Accelerator.DnsName",
	"enabled":                "description.Accelerator.Enabled",
	"ip_address_type":        "description.Accelerator.IpAddressType",
	"ip_sets":                "description.Accelerator.IpSets",
	"kaytu_account_id":       "metadata.SourceID",
	"last_modified_time":     "description.Accelerator.LastModifiedTime",
	"name":                   "description.Accelerator.Name",
	"status":                 "description.Accelerator.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Accelerator.Name",
}

func GetGlobalAcceleratorAccelerator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlobalAcceleratorAccelerator")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlobalAcceleratorAcceleratorPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlobalAcceleratorAcceleratorFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlobalAcceleratorAccelerator =============================

// ==========================  START: GlobalAcceleratorEndpointGroup =============================

type GlobalAcceleratorEndpointGroup struct {
	Description   aws.GlobalAcceleratorEndpointGroupDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type GlobalAcceleratorEndpointGroupHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  GlobalAcceleratorEndpointGroup `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type GlobalAcceleratorEndpointGroupHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []GlobalAcceleratorEndpointGroupHit `json:"hits"`
}

type GlobalAcceleratorEndpointGroupSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  GlobalAcceleratorEndpointGroupHits `json:"hits"`
}

type GlobalAcceleratorEndpointGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlobalAcceleratorEndpointGroupPaginator(filters []essdk.BoolFilter, limit *int64) (GlobalAcceleratorEndpointGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_globalaccelerator_endpointgroup", filters, limit)
	if err != nil {
		return GlobalAcceleratorEndpointGroupPaginator{}, err
	}

	p := GlobalAcceleratorEndpointGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlobalAcceleratorEndpointGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlobalAcceleratorEndpointGroupPaginator) NextPage(ctx context.Context) ([]GlobalAcceleratorEndpointGroup, error) {
	var response GlobalAcceleratorEndpointGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlobalAcceleratorEndpointGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlobalAcceleratorEndpointGroupFilters = map[string]string{
	"akas":                          "description.EndpointGroup.EndpointGroupArn",
	"arn":                           "description.EndpointGroup.EndpointGroupArn",
	"endpoint_descriptions":         "description.EndpointGroup.EndpointDescriptions",
	"endpoint_group_region":         "description.EndpointGroup.EndpointGroupRegion",
	"health_check_interval_seconds": "description.EndpointGroup.HealthCheckIntervalSeconds",
	"health_check_path":             "description.EndpointGroup.HealthCheckPath",
	"health_check_port":             "description.EndpointGroup.HealthCheckPort",
	"health_check_protocol":         "description.EndpointGroup.HealthCheckProtocol",
	"kaytu_account_id":              "metadata.SourceID",
	"listener_arn":                  "description.ListenerArn",
	"port_overrides":                "description.EndpointGroup.PortOverrides",
	"threshold_count":               "description.EndpointGroup.ThresholdCount",
	"title":                         "description.EndpointGroup.EndpointGroupArn",
	"traffic_dial_percentage":       "description.EndpointGroup.TrafficDialPercentage",
}

func ListGlobalAcceleratorEndpointGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlobalAcceleratorEndpointGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlobalAcceleratorEndpointGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlobalAcceleratorEndpointGroupFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlobalAcceleratorEndpointGroupFilters = map[string]string{
	"akas":                          "description.EndpointGroup.EndpointGroupArn",
	"arn":                           "description.EndpointGroup.EndpointGroupArn",
	"endpoint_descriptions":         "description.EndpointGroup.EndpointDescriptions",
	"endpoint_group_region":         "description.EndpointGroup.EndpointGroupRegion",
	"health_check_interval_seconds": "description.EndpointGroup.HealthCheckIntervalSeconds",
	"health_check_path":             "description.EndpointGroup.HealthCheckPath",
	"health_check_port":             "description.EndpointGroup.HealthCheckPort",
	"health_check_protocol":         "description.EndpointGroup.HealthCheckProtocol",
	"kaytu_account_id":              "metadata.SourceID",
	"listener_arn":                  "description.ListenerArn",
	"port_overrides":                "description.EndpointGroup.PortOverrides",
	"threshold_count":               "description.EndpointGroup.ThresholdCount",
	"title":                         "description.EndpointGroup.EndpointGroupArn",
	"traffic_dial_percentage":       "description.EndpointGroup.TrafficDialPercentage",
}

func GetGlobalAcceleratorEndpointGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlobalAcceleratorEndpointGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlobalAcceleratorEndpointGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlobalAcceleratorEndpointGroupFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlobalAcceleratorEndpointGroup =============================

// ==========================  START: GlobalAcceleratorListener =============================

type GlobalAcceleratorListener struct {
	Description   aws.GlobalAcceleratorListenerDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type GlobalAcceleratorListenerHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  GlobalAcceleratorListener `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type GlobalAcceleratorListenerHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []GlobalAcceleratorListenerHit `json:"hits"`
}

type GlobalAcceleratorListenerSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  GlobalAcceleratorListenerHits `json:"hits"`
}

type GlobalAcceleratorListenerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlobalAcceleratorListenerPaginator(filters []essdk.BoolFilter, limit *int64) (GlobalAcceleratorListenerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_globalaccelerator_listener", filters, limit)
	if err != nil {
		return GlobalAcceleratorListenerPaginator{}, err
	}

	p := GlobalAcceleratorListenerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlobalAcceleratorListenerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlobalAcceleratorListenerPaginator) NextPage(ctx context.Context) ([]GlobalAcceleratorListener, error) {
	var response GlobalAcceleratorListenerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlobalAcceleratorListener
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlobalAcceleratorListenerFilters = map[string]string{
	"accelerator_arn":  "description.AcceleratorArn",
	"akas":             "description.Listener.ListenerArn",
	"arn":              "description.Listener.ListenerArn",
	"client_affinity":  "description.Listener.ClientAffinity",
	"kaytu_account_id": "metadata.SourceID",
	"port_ranges":      "description.Listener.PortRanges",
	"protocol":         "description.Listener.Protocol",
	"title":            "description.Listener.ListenerArn",
}

func ListGlobalAcceleratorListener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlobalAcceleratorListener")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlobalAcceleratorListenerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlobalAcceleratorListenerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlobalAcceleratorListenerFilters = map[string]string{
	"accelerator_arn":  "description.AcceleratorArn",
	"akas":             "description.Listener.ListenerArn",
	"arn":              "description.Listener.ListenerArn",
	"client_affinity":  "description.Listener.ClientAffinity",
	"kaytu_account_id": "metadata.SourceID",
	"port_ranges":      "description.Listener.PortRanges",
	"protocol":         "description.Listener.Protocol",
	"title":            "description.Listener.ListenerArn",
}

func GetGlobalAcceleratorListener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlobalAcceleratorListener")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlobalAcceleratorListenerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlobalAcceleratorListenerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlobalAcceleratorListener =============================

// ==========================  START: GlueCatalogDatabase =============================

type GlueCatalogDatabase struct {
	Description   aws.GlueCatalogDatabaseDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type GlueCatalogDatabaseHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  GlueCatalogDatabase `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type GlueCatalogDatabaseHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []GlueCatalogDatabaseHit `json:"hits"`
}

type GlueCatalogDatabaseSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  GlueCatalogDatabaseHits `json:"hits"`
}

type GlueCatalogDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueCatalogDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (GlueCatalogDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_catalogdatabase", filters, limit)
	if err != nil {
		return GlueCatalogDatabasePaginator{}, err
	}

	p := GlueCatalogDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueCatalogDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueCatalogDatabasePaginator) NextPage(ctx context.Context) ([]GlueCatalogDatabase, error) {
	var response GlueCatalogDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueCatalogDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueCatalogDatabaseFilters = map[string]string{
	"akas":                             "aRN",
	"catalog_id":                       "description.Database.CatalogId",
	"create_table_default_permissions": "description.Database.CreateTableDefaultPermissions",
	"create_time":                      "description.Database.CreateTime",
	"description":                      "description.Database.Description",
	"kaytu_account_id":                 "metadata.SourceID",
	"location_uri":                     "description.Database.LocationUri",
	"name":                             "description.Database.Name",
	"parameters":                       "description.Database.Parameters",
	"target_database":                  "description.Database.TargetDatabase",
	"title":                            "description.Database.Name",
}

func ListGlueCatalogDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueCatalogDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueCatalogDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueCatalogDatabaseFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueCatalogDatabaseFilters = map[string]string{
	"akas":                             "aRN",
	"catalog_id":                       "description.Database.CatalogId",
	"create_table_default_permissions": "description.Database.CreateTableDefaultPermissions",
	"create_time":                      "description.Database.CreateTime",
	"description":                      "description.Database.Description",
	"kaytu_account_id":                 "metadata.SourceID",
	"location_uri":                     "description.Database.LocationUri",
	"name":                             "description.Database.Name",
	"parameters":                       "description.Database.Parameters",
	"target_database":                  "description.Database.TargetDatabase",
	"title":                            "description.Database.Name",
}

func GetGlueCatalogDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueCatalogDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueCatalogDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueCatalogDatabaseFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueCatalogDatabase =============================

// ==========================  START: GlueCatalogTable =============================

type GlueCatalogTable struct {
	Description   aws.GlueCatalogTableDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type GlueCatalogTableHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  GlueCatalogTable `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type GlueCatalogTableHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []GlueCatalogTableHit `json:"hits"`
}

type GlueCatalogTableSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  GlueCatalogTableHits `json:"hits"`
}

type GlueCatalogTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueCatalogTablePaginator(filters []essdk.BoolFilter, limit *int64) (GlueCatalogTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_catalogtable", filters, limit)
	if err != nil {
		return GlueCatalogTablePaginator{}, err
	}

	p := GlueCatalogTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueCatalogTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueCatalogTablePaginator) NextPage(ctx context.Context) ([]GlueCatalogTable, error) {
	var response GlueCatalogTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueCatalogTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueCatalogTableFilters = map[string]string{
	"akas":                              "aRN",
	"catalog_id":                        "description.Table.CatalogId",
	"create_time":                       "description.Table.CreateTime",
	"created_by":                        "description.Table.CreatedBy",
	"database_name":                     "description.Table.DatabaseName",
	"description":                       "description.Table.Description",
	"is_registered_with_lake_formation": "description.Table.IsRegisteredWithLakeFormation",
	"kaytu_account_id":                  "metadata.SourceID",
	"last_access_time":                  "description.Table.LastAccessTime",
	"last_analyzed_time":                "description.Table.LastAnalyzedTime",
	"name":                              "description.Table.Name",
	"owner":                             "description.Table.Owner",
	"parameters":                        "description.Table.Parameters",
	"partition_keys":                    "description.Table.PartitionKeys",
	"retention":                         "description.Table.Retention",
	"storage_descriptor":                "description.Table.StorageDescriptor",
	"table_type":                        "description.Table.TableType",
	"target_table":                      "description.Table.TargetTable",
	"title":                             "description.Table.Name",
	"update_time":                       "description.Table.UpdateTime",
	"view_expanded_text":                "description.Table.ViewExpandedText",
	"view_original_text":                "description.Table.ViewOriginalText",
}

func ListGlueCatalogTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueCatalogTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueCatalogTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueCatalogTableFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueCatalogTableFilters = map[string]string{
	"akas":                              "aRN",
	"catalog_id":                        "description.Table.CatalogId",
	"create_time":                       "description.Table.CreateTime",
	"created_by":                        "description.Table.CreatedBy",
	"database_name":                     "description.DatabaseName",
	"description":                       "description.Table.Description",
	"is_registered_with_lake_formation": "description.Table.IsRegisteredWithLakeFormation",
	"kaytu_account_id":                  "metadata.SourceID",
	"last_access_time":                  "description.Table.LastAccessTime",
	"last_analyzed_time":                "description.Table.LastAnalyzedTime",
	"name":                              "description.Table.Name",
	"owner":                             "description.Table.Owner",
	"parameters":                        "description.Table.Parameters",
	"partition_keys":                    "description.Table.PartitionKeys",
	"retention":                         "description.Table.Retention",
	"storage_descriptor":                "description.Table.StorageDescriptor",
	"table_type":                        "description.Table.TableType",
	"target_table":                      "description.Table.TargetTable",
	"title":                             "description.Table.Name",
	"update_time":                       "description.Table.UpdateTime",
	"view_expanded_text":                "description.Table.ViewExpandedText",
	"view_original_text":                "description.Table.ViewOriginalText",
}

func GetGlueCatalogTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueCatalogTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueCatalogTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueCatalogTableFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueCatalogTable =============================

// ==========================  START: GlueConnection =============================

type GlueConnection struct {
	Description   aws.GlueConnectionDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type GlueConnectionHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  GlueConnection `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type GlueConnectionHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []GlueConnectionHit `json:"hits"`
}

type GlueConnectionSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  GlueConnectionHits `json:"hits"`
}

type GlueConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (GlueConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_connection", filters, limit)
	if err != nil {
		return GlueConnectionPaginator{}, err
	}

	p := GlueConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueConnectionPaginator) NextPage(ctx context.Context) ([]GlueConnection, error) {
	var response GlueConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueConnectionFilters = map[string]string{
	"akas":                             "aRN",
	"arn":                              "aRN",
	"connection_properties":            "description.Connection.ConnectionProperties",
	"connection_type":                  "description.Connection.ConnectionType",
	"creation_time":                    "description.Connection.CreationTime",
	"description":                      "description.Connection.Description",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_updated_by":                  "description.Connection.LastUpdatedBy",
	"last_updated_time":                "description.Connection.LastUpdatedTime",
	"match_criteria":                   "description.Connection.MatchCriteria",
	"name":                             "description.Connection.Name",
	"physical_connection_requirements": "description.Connection.PhysicalConnectionRequirements",
	"title":                            "description.Connection.Name",
}

func ListGlueConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueConnectionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueConnectionFilters = map[string]string{
	"akas":                             "aRN",
	"arn":                              "aRN",
	"connection_properties":            "description.Connection.ConnectionProperties",
	"connection_type":                  "description.Connection.ConnectionType",
	"creation_time":                    "description.Connection.CreationTime",
	"description":                      "description.Connection.Description",
	"kaytu_account_id":                 "metadata.SourceID",
	"last_updated_by":                  "description.Connection.LastUpdatedBy",
	"last_updated_time":                "description.Connection.LastUpdatedTime",
	"match_criteria":                   "description.Connection.MatchCriteria",
	"name":                             "description.Connection.Name",
	"physical_connection_requirements": "description.Connection.PhysicalConnectionRequirements",
	"title":                            "description.Connection.Name",
}

func GetGlueConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueConnectionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueConnection =============================

// ==========================  START: GlueCrawler =============================

type GlueCrawler struct {
	Description   aws.GlueCrawlerDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type GlueCrawlerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GlueCrawler   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GlueCrawlerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GlueCrawlerHit  `json:"hits"`
}

type GlueCrawlerSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  GlueCrawlerHits `json:"hits"`
}

type GlueCrawlerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueCrawlerPaginator(filters []essdk.BoolFilter, limit *int64) (GlueCrawlerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_crawler", filters, limit)
	if err != nil {
		return GlueCrawlerPaginator{}, err
	}

	p := GlueCrawlerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueCrawlerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueCrawlerPaginator) NextPage(ctx context.Context) ([]GlueCrawler, error) {
	var response GlueCrawlerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueCrawler
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueCrawlerFilters = map[string]string{
	"akas":                           "aRN",
	"arn":                            "aRN",
	"classifiers":                    "description.Crawler.Classifiers",
	"configuration":                  "description.Crawler.Configuration",
	"crawl_elapsed_time":             "description.Crawler.CrawlElapsedTime",
	"crawler_lineage_settings":       "description.Crawler.LineageConfiguration.CrawlerLineageSettings",
	"crawler_security_configuration": "description.Crawler.CrawlerSecurityConfiguration",
	"creation_time":                  "description.Crawler.CreationTime",
	"database_name":                  "description.Crawler.DatabaseName",
	"description":                    "description.Crawler.Description",
	"kaytu_account_id":               "metadata.SourceID",
	"last_crawl":                     "description.Crawler.LastCrawl",
	"last_updated":                   "description.Crawler.LastUpdated",
	"name":                           "description.Crawler.Name",
	"recrawl_behavior":               "description.Crawler.RecrawlPolicy.RecrawlBehavior",
	"role":                           "description.Crawler.Role",
	"schedule":                       "description.Crawler.Schedule",
	"schema_change_policy":           "description.Crawler.SchemaChangePolicy",
	"state":                          "description.Crawler.State",
	"table_prefix":                   "description.Crawler.TablePrefix",
	"targets":                        "description.Crawler.Targets",
	"title":                          "description.Crawler.Name",
	"version":                        "description.Crawler.Version",
}

func ListGlueCrawler(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueCrawler")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueCrawlerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueCrawlerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueCrawlerFilters = map[string]string{
	"akas":                           "aRN",
	"arn":                            "aRN",
	"classifiers":                    "description.Crawler.Classifiers",
	"configuration":                  "description.Crawler.Configuration",
	"crawl_elapsed_time":             "description.Crawler.CrawlElapsedTime",
	"crawler_lineage_settings":       "description.Crawler.LineageConfiguration.CrawlerLineageSettings",
	"crawler_security_configuration": "description.Crawler.CrawlerSecurityConfiguration",
	"creation_time":                  "description.Crawler.CreationTime",
	"database_name":                  "description.Crawler.DatabaseName",
	"description":                    "description.Crawler.Description",
	"kaytu_account_id":               "metadata.SourceID",
	"last_crawl":                     "description.Crawler.LastCrawl",
	"last_updated":                   "description.Crawler.LastUpdated",
	"name":                           "description.Crawler.Name",
	"recrawl_behavior":               "description.Crawler.RecrawlPolicy.RecrawlBehavior",
	"role":                           "description.Crawler.Role",
	"schedule":                       "description.Crawler.Schedule",
	"schema_change_policy":           "description.Crawler.SchemaChangePolicy",
	"state":                          "description.Crawler.State",
	"table_prefix":                   "description.Crawler.TablePrefix",
	"targets":                        "description.Crawler.Targets",
	"title":                          "description.Crawler.Name",
	"version":                        "description.Crawler.Version",
}

func GetGlueCrawler(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueCrawler")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueCrawlerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueCrawlerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueCrawler =============================

// ==========================  START: GlueDataCatalogEncryptionSettings =============================

type GlueDataCatalogEncryptionSettings struct {
	Description   aws.GlueDataCatalogEncryptionSettingsDescription `json:"description"`
	Metadata      aws.Metadata                                     `json:"metadata"`
	ResourceJobID int                                              `json:"resource_job_id"`
	SourceJobID   int                                              `json:"source_job_id"`
	ResourceType  string                                           `json:"resource_type"`
	SourceType    string                                           `json:"source_type"`
	ID            string                                           `json:"id"`
	ARN           string                                           `json:"arn"`
	SourceID      string                                           `json:"source_id"`
}

type GlueDataCatalogEncryptionSettingsHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  GlueDataCatalogEncryptionSettings `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type GlueDataCatalogEncryptionSettingsHits struct {
	Total essdk.SearchTotal                      `json:"total"`
	Hits  []GlueDataCatalogEncryptionSettingsHit `json:"hits"`
}

type GlueDataCatalogEncryptionSettingsSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  GlueDataCatalogEncryptionSettingsHits `json:"hits"`
}

type GlueDataCatalogEncryptionSettingsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueDataCatalogEncryptionSettingsPaginator(filters []essdk.BoolFilter, limit *int64) (GlueDataCatalogEncryptionSettingsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_datacatalogencryptionsettings", filters, limit)
	if err != nil {
		return GlueDataCatalogEncryptionSettingsPaginator{}, err
	}

	p := GlueDataCatalogEncryptionSettingsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueDataCatalogEncryptionSettingsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueDataCatalogEncryptionSettingsPaginator) NextPage(ctx context.Context) ([]GlueDataCatalogEncryptionSettings, error) {
	var response GlueDataCatalogEncryptionSettingsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueDataCatalogEncryptionSettings
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueDataCatalogEncryptionSettingsFilters = map[string]string{
	"connection_password_encryption": "description.DataCatalogEncryptionSettings.ConnectionPasswordEncryption",
	"encryption_at_rest":             "description.DataCatalogEncryptionSettings.EncryptionAtRest",
	"kaytu_account_id":               "metadata.SourceID",
}

func ListGlueDataCatalogEncryptionSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueDataCatalogEncryptionSettings")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueDataCatalogEncryptionSettingsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueDataCatalogEncryptionSettingsFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueDataCatalogEncryptionSettingsFilters = map[string]string{
	"connection_password_encryption": "description.DataCatalogEncryptionSettings.ConnectionPasswordEncryption",
	"encryption_at_rest":             "description.DataCatalogEncryptionSettings.EncryptionAtRest",
	"kaytu_account_id":               "metadata.SourceID",
}

func GetGlueDataCatalogEncryptionSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueDataCatalogEncryptionSettings")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueDataCatalogEncryptionSettingsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueDataCatalogEncryptionSettingsFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueDataCatalogEncryptionSettings =============================

// ==========================  START: GlueDataQualityRuleset =============================

type GlueDataQualityRuleset struct {
	Description   aws.GlueDataQualityRulesetDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type GlueDataQualityRulesetHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  GlueDataQualityRuleset `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type GlueDataQualityRulesetHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []GlueDataQualityRulesetHit `json:"hits"`
}

type GlueDataQualityRulesetSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  GlueDataQualityRulesetHits `json:"hits"`
}

type GlueDataQualityRulesetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueDataQualityRulesetPaginator(filters []essdk.BoolFilter, limit *int64) (GlueDataQualityRulesetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_dataqualityruleset", filters, limit)
	if err != nil {
		return GlueDataQualityRulesetPaginator{}, err
	}

	p := GlueDataQualityRulesetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueDataQualityRulesetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueDataQualityRulesetPaginator) NextPage(ctx context.Context) ([]GlueDataQualityRuleset, error) {
	var response GlueDataQualityRulesetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueDataQualityRuleset
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueDataQualityRulesetFilters = map[string]string{
	"created_on":            "description.DataQualityRuleset.CreatedOn",
	"database_name":         "description.DataQualityRuleset.TargetTable.DatabaseName",
	"description":           "description.DataQualityRuleset.Description",
	"kaytu_account_id":      "metadata.SourceID",
	"last_modified_on":      "description.DataQualityRuleset.LastModifiedOn",
	"name":                  "description.DataQualityRuleset.Name",
	"recommendation_run_id": "description.DataQualityRuleset.RecommendationRunId",
	"rule_count":            "description.DataQualityRuleset",
	"rule_set":              "description.DataQualityRuleset",
	"table_name":            "description.DataQualityRuleset.TargetTable.TableName",
	"target_table":          "description.DataQualityRuleset.TargetTable",
	"title":                 "description.DataQualityRuleset.Name",
}

func ListGlueDataQualityRuleset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueDataQualityRuleset")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueDataQualityRulesetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueDataQualityRulesetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueDataQualityRulesetFilters = map[string]string{
	"created_on":            "description.DataQualityRuleset.CreatedOn",
	"database_name":         "description.DataQualityRuleset.TargetTable.DatabaseName",
	"description":           "description.DataQualityRuleset.Description",
	"kaytu_account_id":      "metadata.SourceID",
	"last_modified_on":      "description.DataQualityRuleset.LastModifiedOn",
	"name":                  "description.DataQualityRuleset.Name",
	"recommendation_run_id": "description.DataQualityRuleset.RecommendationRunId",
	"rule_count":            "description.DataQualityRuleset",
	"rule_set":              "description.DataQualityRuleset",
	"table_name":            "description.DataQualityRuleset.TargetTable.TableName",
	"target_table":          "description.DataQualityRuleset.TargetTable",
	"title":                 "description.DataQualityRuleset.Name",
}

func GetGlueDataQualityRuleset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueDataQualityRuleset")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueDataQualityRulesetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueDataQualityRulesetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueDataQualityRuleset =============================

// ==========================  START: GlueDevEndpoint =============================

type GlueDevEndpoint struct {
	Description   aws.GlueDevEndpointDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type GlueDevEndpointHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  GlueDevEndpoint `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type GlueDevEndpointHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []GlueDevEndpointHit `json:"hits"`
}

type GlueDevEndpointSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  GlueDevEndpointHits `json:"hits"`
}

type GlueDevEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueDevEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (GlueDevEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_devendpoint", filters, limit)
	if err != nil {
		return GlueDevEndpointPaginator{}, err
	}

	p := GlueDevEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueDevEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueDevEndpointPaginator) NextPage(ctx context.Context) ([]GlueDevEndpoint, error) {
	var response GlueDevEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueDevEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueDevEndpointFilters = map[string]string{
	"akas":                                   "aRN",
	"arn":                                    "aRN",
	"availability_zone":                      "description.DevEndpoint.AvailabilityZone",
	"created_timestamp":                      "description.DevEndpoint.CreatedTimestamp",
	"endpoint_name":                          "description.DevEndpoint.EndpointName",
	"extra_jars_s3_path":                     "description.DevEndpoint.ExtraJarsS3Path",
	"extra_python_libs_s3_path":              "description.DevEndpoint.ExtraPythonLibsS3Path",
	"failure_reason":                         "description.DevEndpoint.FailureReason",
	"glue_version":                           "description.DevEndpoint.GlueVersion",
	"kaytu_account_id":                       "metadata.SourceID",
	"last_modified_timestamp":                "description.DevEndpoint.LastModifiedTimestamp",
	"last_update_status":                     "description.DevEndpoint.LastUpdateStatus",
	"number_of_nodes":                        "description.DevEndpoint.NumberOfNodes",
	"number_of_workers":                      "description.DevEndpoint.NumberOfWorkers",
	"private_address":                        "description.DevEndpoint.PrivateAddress",
	"public_address":                         "description.DevEndpoint.PublicAddress",
	"public_key":                             "description.DevEndpoint.PublicKey",
	"public_keys":                            "description.DevEndpoint.PublicKeys",
	"role_arn":                               "description.DevEndpoint.RoleArn",
	"security_configuration":                 "description.DevEndpoint.SecurityConfiguration",
	"security_group_ids":                     "description.DevEndpoint.SecurityGroupIds",
	"status":                                 "description.DevEndpoint.Status",
	"subnet_id":                              "description.DevEndpoint.SubnetId",
	"title":                                  "description.DevEndpoint.EndpointName",
	"vpc_id":                                 "description.DevEndpoint.VpcId",
	"worker_type":                            "description.DevEndpoint.WorkerType",
	"yarn_endpoint_address":                  "description.DevEndpoint.YarnEndpointAddress",
	"zeppelin_remote_spark_interpreter_port": "description.DevEndpoint.ZeppelinRemoteSparkInterpreterPort",
}

func ListGlueDevEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueDevEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueDevEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueDevEndpointFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueDevEndpointFilters = map[string]string{
	"akas":                                   "aRN",
	"arn":                                    "aRN",
	"availability_zone":                      "description.DevEndpoint.AvailabilityZone",
	"created_timestamp":                      "description.DevEndpoint.CreatedTimestamp",
	"endpoint_name":                          "description.DevEndpoint.EndpointName",
	"extra_jars_s3_path":                     "description.DevEndpoint.ExtraJarsS3Path",
	"extra_python_libs_s3_path":              "description.DevEndpoint.ExtraPythonLibsS3Path",
	"failure_reason":                         "description.DevEndpoint.FailureReason",
	"glue_version":                           "description.DevEndpoint.GlueVersion",
	"kaytu_account_id":                       "metadata.SourceID",
	"last_modified_timestamp":                "description.DevEndpoint.LastModifiedTimestamp",
	"last_update_status":                     "description.DevEndpoint.LastUpdateStatus",
	"number_of_nodes":                        "description.DevEndpoint.NumberOfNodes",
	"number_of_workers":                      "description.DevEndpoint.NumberOfWorkers",
	"private_address":                        "description.DevEndpoint.PrivateAddress",
	"public_address":                         "description.DevEndpoint.PublicAddress",
	"public_key":                             "description.DevEndpoint.PublicKey",
	"public_keys":                            "description.DevEndpoint.PublicKeys",
	"role_arn":                               "description.DevEndpoint.RoleArn",
	"security_configuration":                 "description.DevEndpoint.SecurityConfiguration",
	"security_group_ids":                     "description.DevEndpoint.SecurityGroupIds",
	"status":                                 "description.DevEndpoint.Status",
	"subnet_id":                              "description.DevEndpoint.SubnetId",
	"title":                                  "description.DevEndpoint.EndpointName",
	"vpc_id":                                 "description.DevEndpoint.VpcId",
	"worker_type":                            "description.DevEndpoint.WorkerType",
	"yarn_endpoint_address":                  "description.DevEndpoint.YarnEndpointAddress",
	"zeppelin_remote_spark_interpreter_port": "description.DevEndpoint.ZeppelinRemoteSparkInterpreterPort",
}

func GetGlueDevEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueDevEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueDevEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueDevEndpointFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueDevEndpoint =============================

// ==========================  START: GlueJob =============================

type GlueJob struct {
	Description   aws.GlueJobDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type GlueJobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GlueJob       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GlueJobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GlueJobHit      `json:"hits"`
}

type GlueJobSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  GlueJobHits `json:"hits"`
}

type GlueJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueJobPaginator(filters []essdk.BoolFilter, limit *int64) (GlueJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_job", filters, limit)
	if err != nil {
		return GlueJobPaginator{}, err
	}

	p := GlueJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueJobPaginator) NextPage(ctx context.Context) ([]GlueJob, error) {
	var response GlueJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueJobFilters = map[string]string{
	"akas":                      "aRN",
	"allocated_capacity":        "description.Job.AllocatedCapacity",
	"arn":                       "aRN",
	"command":                   "description.Job.Command",
	"connections":               "description.Job.Connections",
	"created_on":                "description.Job.CreatedOn",
	"default_arguments":         "description.Job.DefaultArguments",
	"description":               "description.Job.Description",
	"execution_property":        "description.Job.ExecutionProperty",
	"glue_version":              "description.Job.GlueVersion",
	"job_bookmark":              "description.Bookmark",
	"kaytu_account_id":          "metadata.SourceID",
	"last_modified_on":          "description.Job.LastModifiedOn",
	"log_uri":                   "description.Job.LogUri",
	"max_capacity":              "description.Job.MaxCapacity",
	"max_retries":               "description.Job.MaxRetries",
	"name":                      "description.Job.Name",
	"non_overridable_arguments": "description.Job.NonOverridableArguments",
	"notification_property":     "description.Job.NotificationProperty",
	"number_of_workers":         "description.Job.NumberOfWorkers",
	"role":                      "description.Job.Role",
	"security_configuration":    "description.Job.SecurityConfiguration",
	"timeout":                   "description.Job.Timeout",
	"title":                     "description.Job.Name",
	"worker_type":               "description.Job.WorkerType",
}

func ListGlueJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueJobFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueJobFilters = map[string]string{
	"akas":                      "aRN",
	"allocated_capacity":        "description.Job.AllocatedCapacity",
	"arn":                       "aRN",
	"command":                   "description.Job.Command",
	"connections":               "description.Job.Connections",
	"created_on":                "description.Job.CreatedOn",
	"default_arguments":         "description.Job.DefaultArguments",
	"description":               "description.Job.Description",
	"execution_property":        "description.Job.ExecutionProperty",
	"glue_version":              "description.Job.GlueVersion",
	"job_bookmark":              "description.Bookmark",
	"kaytu_account_id":          "metadata.SourceID",
	"last_modified_on":          "description.Job.LastModifiedOn",
	"log_uri":                   "description.Job.LogUri",
	"max_capacity":              "description.Job.MaxCapacity",
	"max_retries":               "description.Job.MaxRetries",
	"name":                      "description.Job.Name",
	"non_overridable_arguments": "description.Job.NonOverridableArguments",
	"notification_property":     "description.Job.NotificationProperty",
	"number_of_workers":         "description.Job.NumberOfWorkers",
	"role":                      "description.Job.Role",
	"security_configuration":    "description.Job.SecurityConfiguration",
	"timeout":                   "description.Job.Timeout",
	"title":                     "description.Job.Name",
	"worker_type":               "description.Job.WorkerType",
}

func GetGlueJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueJobFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueJob =============================

// ==========================  START: GlueSecurityConfiguration =============================

type GlueSecurityConfiguration struct {
	Description   aws.GlueSecurityConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type GlueSecurityConfigurationHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  GlueSecurityConfiguration `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type GlueSecurityConfigurationHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []GlueSecurityConfigurationHit `json:"hits"`
}

type GlueSecurityConfigurationSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  GlueSecurityConfigurationHits `json:"hits"`
}

type GlueSecurityConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueSecurityConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (GlueSecurityConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_securityconfiguration", filters, limit)
	if err != nil {
		return GlueSecurityConfigurationPaginator{}, err
	}

	p := GlueSecurityConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueSecurityConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueSecurityConfigurationPaginator) NextPage(ctx context.Context) ([]GlueSecurityConfiguration, error) {
	var response GlueSecurityConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueSecurityConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueSecurityConfigurationFilters = map[string]string{
	"akas":                     "aRN",
	"cloud_watch_encryption":   "description.SecurityConfiguration.EncryptionConfiguration.CloudWatchEncryption",
	"created_time_stamp":       "description.SecurityConfiguration.CreatedTimeStamp",
	"job_bookmarks_encryption": "description.SecurityConfiguration.EncryptionConfiguration.JobBookmarksEncryption",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.SecurityConfiguration.Name",
	"s3_encryption":            "description.SecurityConfiguration.EncryptionConfiguration.S3Encryption",
	"title":                    "description.SecurityConfiguration.Name",
}

func ListGlueSecurityConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueSecurityConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewGlueSecurityConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listGlueSecurityConfigurationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getGlueSecurityConfigurationFilters = map[string]string{
	"akas":                     "aRN",
	"cloud_watch_encryption":   "description.SecurityConfiguration.EncryptionConfiguration.CloudWatchEncryption",
	"created_time_stamp":       "description.SecurityConfiguration.CreatedTimeStamp",
	"job_bookmarks_encryption": "description.SecurityConfiguration.EncryptionConfiguration.JobBookmarksEncryption",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.SecurityConfiguration.Name",
	"s3_encryption":            "description.SecurityConfiguration.EncryptionConfiguration.S3Encryption",
	"title":                    "description.SecurityConfiguration.Name",
}

func GetGlueSecurityConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueSecurityConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewGlueSecurityConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getGlueSecurityConfigurationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: GlueSecurityConfiguration =============================

// ==========================  START: HealthEvent =============================

type HealthEvent struct {
	Description   aws.HealthEventDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type HealthEventHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  HealthEvent   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type HealthEventHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []HealthEventHit  `json:"hits"`
}

type HealthEventSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  HealthEventHits `json:"hits"`
}

type HealthEventPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHealthEventPaginator(filters []essdk.BoolFilter, limit *int64) (HealthEventPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_health_event", filters, limit)
	if err != nil {
		return HealthEventPaginator{}, err
	}

	p := HealthEventPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HealthEventPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HealthEventPaginator) NextPage(ctx context.Context) ([]HealthEvent, error) {
	var response HealthEventSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HealthEvent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHealthEventFilters = map[string]string{
	"akas":                "description.Event.Arn",
	"arn":                 "description.Event.Arn",
	"availability_zone":   "description.Event.AvailabilityZone",
	"end_time":            "description.Event.EndTime",
	"event_scope_code":    "description.Event.EventScopeCode",
	"event_type_category": "description.Event.EventTypeCategory",
	"event_type_code":     "description.Event.EventTypeCode",
	"kaytu_account_id":    "metadata.SourceID",
	"last_updated_time":   "description.Event.LastUpdatedTime",
	"service":             "description.Event.Service",
	"start_time":          "description.Event.StartTime",
	"status_code":         "description.Event.StatusCode",
}

func ListHealthEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHealthEvent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewHealthEventPaginator(essdk.BuildFilter(d.KeyColumnQuals, listHealthEventFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHealthEventFilters = map[string]string{
	"akas":                "description.Event.Arn",
	"arn":                 "description.Event.Arn",
	"availability_zone":   "description.Event.AvailabilityZone",
	"end_time":            "description.Event.EndTime",
	"event_scope_code":    "description.Event.EventScopeCode",
	"event_type_category": "description.Event.EventTypeCategory",
	"event_type_code":     "description.Event.EventTypeCode",
	"kaytu_account_id":    "metadata.SourceID",
	"last_updated_time":   "description.Event.LastUpdatedTime",
	"service":             "description.Event.Service",
	"start_time":          "description.Event.StartTime",
	"status_code":         "description.Event.StatusCode",
}

func GetHealthEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHealthEvent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewHealthEventPaginator(essdk.BuildFilter(d.KeyColumnQuals, getHealthEventFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HealthEvent =============================

// ==========================  START: InspectorAssessmentRun =============================

type InspectorAssessmentRun struct {
	Description   aws.InspectorAssessmentRunDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type InspectorAssessmentRunHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  InspectorAssessmentRun `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type InspectorAssessmentRunHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []InspectorAssessmentRunHit `json:"hits"`
}

type InspectorAssessmentRunSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  InspectorAssessmentRunHits `json:"hits"`
}

type InspectorAssessmentRunPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorAssessmentRunPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorAssessmentRunPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_assessmentrun", filters, limit)
	if err != nil {
		return InspectorAssessmentRunPaginator{}, err
	}

	p := InspectorAssessmentRunPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorAssessmentRunPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorAssessmentRunPaginator) NextPage(ctx context.Context) ([]InspectorAssessmentRun, error) {
	var response InspectorAssessmentRunSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorAssessmentRun
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorAssessmentRunFilters = map[string]string{
	"akas":                         "description.AssessmentRun.Arn",
	"arn":                          "description.AssessmentRun.Arn",
	"assessment_template_arn":      "description.AssessmentRun.AssessmentTemplateArn",
	"completed_at":                 "description.AssessmentRun.CompletedAt",
	"created_at":                   "description.AssessmentRun.CreatedAt",
	"data_collected":               "description.AssessmentRun.DataCollected",
	"duration_in_seconds":          "description.AssessmentRun.DurationInSeconds",
	"finding_counts":               "description.AssessmentRun.FindingCounts",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.AssessmentRun.Name",
	"notifications":                "description.AssessmentRun.Notifications",
	"rules_package_arns":           "description.AssessmentRun.RulesPackageArns",
	"started_at":                   "description.AssessmentRun.StartedAt",
	"state":                        "description.AssessmentRun.State",
	"state_changed_at":             "description.AssessmentRun.StateChangedAt",
	"state_changes":                "description.AssessmentRun.StateChanges",
	"title":                        "description.AssessmentRun.Name",
	"user_attributes_for_findings": "description.AssessmentRun.UserAttributesForFindings",
}

func ListInspectorAssessmentRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorAssessmentRun")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewInspectorAssessmentRunPaginator(essdk.BuildFilter(d.KeyColumnQuals, listInspectorAssessmentRunFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getInspectorAssessmentRunFilters = map[string]string{
	"akas":                         "description.AssessmentRun.Arn",
	"arn":                          "description.AssessmentRun.Arn",
	"assessment_template_arn":      "description.AssessmentRun.AssessmentTemplateArn",
	"completed_at":                 "description.AssessmentRun.CompletedAt",
	"created_at":                   "description.AssessmentRun.CreatedAt",
	"data_collected":               "description.AssessmentRun.DataCollected",
	"duration_in_seconds":          "description.AssessmentRun.DurationInSeconds",
	"finding_counts":               "description.AssessmentRun.FindingCounts",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.AssessmentRun.Name",
	"notifications":                "description.AssessmentRun.Notifications",
	"rules_package_arns":           "description.AssessmentRun.RulesPackageArns",
	"started_at":                   "description.AssessmentRun.StartedAt",
	"state":                        "description.AssessmentRun.State",
	"state_changed_at":             "description.AssessmentRun.StateChangedAt",
	"state_changes":                "description.AssessmentRun.StateChanges",
	"title":                        "description.AssessmentRun.Name",
	"user_attributes_for_findings": "description.AssessmentRun.UserAttributesForFindings",
}

func GetInspectorAssessmentRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorAssessmentRun")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewInspectorAssessmentRunPaginator(essdk.BuildFilter(d.KeyColumnQuals, getInspectorAssessmentRunFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: InspectorAssessmentRun =============================

// ==========================  START: InspectorAssessmentTarget =============================

type InspectorAssessmentTarget struct {
	Description   aws.InspectorAssessmentTargetDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type InspectorAssessmentTargetHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  InspectorAssessmentTarget `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type InspectorAssessmentTargetHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []InspectorAssessmentTargetHit `json:"hits"`
}

type InspectorAssessmentTargetSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  InspectorAssessmentTargetHits `json:"hits"`
}

type InspectorAssessmentTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorAssessmentTargetPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorAssessmentTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_assessmenttarget", filters, limit)
	if err != nil {
		return InspectorAssessmentTargetPaginator{}, err
	}

	p := InspectorAssessmentTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorAssessmentTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorAssessmentTargetPaginator) NextPage(ctx context.Context) ([]InspectorAssessmentTarget, error) {
	var response InspectorAssessmentTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorAssessmentTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorAssessmentTargetFilters = map[string]string{
	"akas":               "description.AssessmentTarget.Arn",
	"arn":                "description.AssessmentTarget.Arn",
	"created_at":         "description.AssessmentTarget.CreatedAt",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.AssessmentTarget.Name",
	"resource_group_arn": "description.AssessmentTarget.ResourceGroupArn",
	"title":              "description.AssessmentTarget.Name",
	"updated_at":         "description.AssessmentTarget.UpdatedAt",
}

func ListInspectorAssessmentTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorAssessmentTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewInspectorAssessmentTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listInspectorAssessmentTargetFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getInspectorAssessmentTargetFilters = map[string]string{
	"akas":               "description.AssessmentTarget.Arn",
	"arn":                "description.AssessmentTarget.Arn",
	"created_at":         "description.AssessmentTarget.CreatedAt",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.AssessmentTarget.Name",
	"resource_group_arn": "description.AssessmentTarget.ResourceGroupArn",
	"title":              "description.AssessmentTarget.Name",
	"updated_at":         "description.AssessmentTarget.UpdatedAt",
}

func GetInspectorAssessmentTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorAssessmentTarget")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewInspectorAssessmentTargetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getInspectorAssessmentTargetFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: InspectorAssessmentTarget =============================

// ==========================  START: InspectorAssessmentTemplate =============================

type InspectorAssessmentTemplate struct {
	Description   aws.InspectorAssessmentTemplateDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type InspectorAssessmentTemplateHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  InspectorAssessmentTemplate `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type InspectorAssessmentTemplateHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []InspectorAssessmentTemplateHit `json:"hits"`
}

type InspectorAssessmentTemplateSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  InspectorAssessmentTemplateHits `json:"hits"`
}

type InspectorAssessmentTemplatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorAssessmentTemplatePaginator(filters []essdk.BoolFilter, limit *int64) (InspectorAssessmentTemplatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_assessmenttemplate", filters, limit)
	if err != nil {
		return InspectorAssessmentTemplatePaginator{}, err
	}

	p := InspectorAssessmentTemplatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorAssessmentTemplatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorAssessmentTemplatePaginator) NextPage(ctx context.Context) ([]InspectorAssessmentTemplate, error) {
	var response InspectorAssessmentTemplateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorAssessmentTemplate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorAssessmentTemplateFilters = map[string]string{
	"akas":                         "description.AssessmentTemplate.Arn",
	"arn":                          "description.AssessmentTemplate.Arn",
	"assessment_run_count":         "description.AssessmentTemplate.AssessmentRunCount",
	"assessment_target_arn":        "description.AssessmentTemplate.AssessmentTargetArn",
	"created_at":                   "description.AssessmentTemplate.CreatedAt",
	"duration_in_seconds":          "description.AssessmentTemplate.DurationInSeconds",
	"event_subscriptions":          "description.EventSubscriptions",
	"kaytu_account_id":             "metadata.SourceID",
	"last_assessment_run_arn":      "description.AssessmentTemplate.LastAssessmentRunArn",
	"name":                         "description.AssessmentTemplate.Name",
	"rules_package_arns":           "description.AssessmentTemplate.RulesPackageArns",
	"tags":                         "description.Tags",
	"tags_src":                     "description.Tags",
	"title":                        "description.AssessmentTemplate.Name",
	"user_attributes_for_findings": "description.AssessmentTemplate.UserAttributesForFindings",
}

func ListInspectorAssessmentTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorAssessmentTemplate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewInspectorAssessmentTemplatePaginator(essdk.BuildFilter(d.KeyColumnQuals, listInspectorAssessmentTemplateFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getInspectorAssessmentTemplateFilters = map[string]string{
	"akas":                         "description.AssessmentTemplate.Arn",
	"arn":                          "description.AssessmentTemplate.Arn",
	"assessment_run_count":         "description.AssessmentTemplate.AssessmentRunCount",
	"assessment_target_arn":        "description.AssessmentTemplate.AssessmentTargetArn",
	"created_at":                   "description.AssessmentTemplate.CreatedAt",
	"duration_in_seconds":          "description.AssessmentTemplate.DurationInSeconds",
	"event_subscriptions":          "description.EventSubscriptions",
	"kaytu_account_id":             "metadata.SourceID",
	"last_assessment_run_arn":      "description.AssessmentTemplate.LastAssessmentRunArn",
	"name":                         "description.AssessmentTemplate.Name",
	"rules_package_arns":           "description.AssessmentTemplate.RulesPackageArns",
	"tags":                         "description.Tags",
	"tags_src":                     "description.Tags",
	"title":                        "description.AssessmentTemplate.Name",
	"user_attributes_for_findings": "description.AssessmentTemplate.UserAttributesForFindings",
}

func GetInspectorAssessmentTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorAssessmentTemplate")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewInspectorAssessmentTemplatePaginator(essdk.BuildFilter(d.KeyColumnQuals, getInspectorAssessmentTemplateFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: InspectorAssessmentTemplate =============================

// ==========================  START: InspectorExclusion =============================

type InspectorExclusion struct {
	Description   aws.InspectorExclusionDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type InspectorExclusionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  InspectorExclusion `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type InspectorExclusionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []InspectorExclusionHit `json:"hits"`
}

type InspectorExclusionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  InspectorExclusionHits `json:"hits"`
}

type InspectorExclusionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorExclusionPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorExclusionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_exclusion", filters, limit)
	if err != nil {
		return InspectorExclusionPaginator{}, err
	}

	p := InspectorExclusionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorExclusionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorExclusionPaginator) NextPage(ctx context.Context) ([]InspectorExclusion, error) {
	var response InspectorExclusionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorExclusion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorExclusionFilters = map[string]string{
	"akas":               "description.Exclusion.Arn",
	"arn":                "description.Exclusion.Arn",
	"assessment_run_arn": "description.Exclusion.Arn",
	"attributes":         "description.Exclusion.Attributes",
	"description":        "description.Exclusion.Description",
	"kaytu_account_id":   "metadata.SourceID",
	"recommendation":     "description.Exclusion.Recommendation",
	"scopes":             "description.Exclusion.Scopes",
	"title":              "description.Exclusion.Title",
}

func ListInspectorExclusion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorExclusion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewInspectorExclusionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listInspectorExclusionFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getInspectorExclusionFilters = map[string]string{
	"akas":               "description.Exclusion.Arn",
	"arn":                "description.Exclusion.Arn",
	"assessment_run_arn": "description.AssessmentRunArn",
	"attributes":         "description.Exclusion.Attributes",
	"description":        "description.Exclusion.Description",
	"kaytu_account_id":   "metadata.SourceID",
	"recommendation":     "description.Exclusion.Recommendation",
	"scopes":             "description.Exclusion.Scopes",
	"title":              "description.Exclusion.Title",
}

func GetInspectorExclusion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorExclusion")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewInspectorExclusionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getInspectorExclusionFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: InspectorExclusion =============================

// ==========================  START: InspectorFinding =============================

type InspectorFinding struct {
	Description   aws.InspectorFindingDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type InspectorFindingHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  InspectorFinding `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type InspectorFindingHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []InspectorFindingHit `json:"hits"`
}

type InspectorFindingSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  InspectorFindingHits `json:"hits"`
}

type InspectorFindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorFindingPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorFindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_finding", filters, limit)
	if err != nil {
		return InspectorFindingPaginator{}, err
	}

	p := InspectorFindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorFindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorFindingPaginator) NextPage(ctx context.Context) ([]InspectorFinding, error) {
	var response InspectorFindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorFinding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorFindingFilters = map[string]string{
	"agent_id":                "description.Finding.AssetAttributes.AgentId",
	"akas":                    "description.Finding.Arn",
	"arn":                     "description.Finding.Arn",
	"asset_attributes":        "description.Finding.AssetAttributes",
	"asset_type":              "description.Finding.AssetType",
	"attributes":              "description.Finding.Attributes",
	"auto_scaling_group":      "description.Finding.AssetAttributes.AutoScalingGroup",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"description":             "description.Finding.Description",
	"failed_items":            "description.FailedItems",
	"id":                      "description.Finding.Id",
	"indicator_of_compromise": "description.Finding.IndicatorOfCompromise",
	"kaytu_account_id":        "metadata.SourceID",
	"numeric_severity":        "description.Finding.NumericSeverity",
	"recommendation":          "description.Finding.Recommendation",
	"schema_version":          "description.Finding.SchemaVersion",
	"service":                 "description.Finding.Service",
	"service_attributes":      "description.Finding.ServiceAttributes",
	"severity":                "description.Finding.Severity",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_attributes":         "description.Finding.UserAttributes",
}

func ListInspectorFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorFinding")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewInspectorFindingPaginator(essdk.BuildFilter(d.KeyColumnQuals, listInspectorFindingFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getInspectorFindingFilters = map[string]string{
	"agent_id":                "description.Finding.AssetAttributes.AgentId",
	"akas":                    "description.Finding.Arn",
	"arn":                     "description.Finding.Arn",
	"asset_attributes":        "description.Finding.AssetAttributes",
	"asset_type":              "description.Finding.AssetType",
	"attributes":              "description.Finding.Attributes",
	"auto_scaling_group":      "description.Finding.AssetAttributes.AutoScalingGroup",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"description":             "description.Finding.Description",
	"failed_items":            "description.FailedItems",
	"id":                      "description.Finding.Id",
	"indicator_of_compromise": "description.Finding.IndicatorOfCompromise",
	"kaytu_account_id":        "metadata.SourceID",
	"numeric_severity":        "description.Finding.NumericSeverity",
	"recommendation":          "description.Finding.Recommendation",
	"schema_version":          "description.Finding.SchemaVersion",
	"service":                 "description.Finding.Service",
	"service_attributes":      "description.Finding.ServiceAttributes",
	"severity":                "description.Finding.Severity",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_attributes":         "description.Finding.UserAttributes",
}

func GetInspectorFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorFinding")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewInspectorFindingPaginator(essdk.BuildFilter(d.KeyColumnQuals, getInspectorFindingFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: InspectorFinding =============================

// ==========================  START: FirehoseDeliveryStream =============================

type FirehoseDeliveryStream struct {
	Description   aws.FirehoseDeliveryStreamDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type FirehoseDeliveryStreamHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  FirehoseDeliveryStream `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type FirehoseDeliveryStreamHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []FirehoseDeliveryStreamHit `json:"hits"`
}

type FirehoseDeliveryStreamSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  FirehoseDeliveryStreamHits `json:"hits"`
}

type FirehoseDeliveryStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFirehoseDeliveryStreamPaginator(filters []essdk.BoolFilter, limit *int64) (FirehoseDeliveryStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_firehose_deliverystream", filters, limit)
	if err != nil {
		return FirehoseDeliveryStreamPaginator{}, err
	}

	p := FirehoseDeliveryStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FirehoseDeliveryStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FirehoseDeliveryStreamPaginator) NextPage(ctx context.Context) ([]FirehoseDeliveryStream, error) {
	var response FirehoseDeliveryStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FirehoseDeliveryStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFirehoseDeliveryStreamFilters = map[string]string{
	"akas":             "description.DeliveryStream.DeliveryStreamARN",
	"arn":              "description.DeliveryStream.DeliveryStreamARN",
	"create_timestamp": "description.DeliveryStream.CreateTimestamp",
	"delivery_stream_encryption_configuration": "description.DeliveryStream.DeliveryStreamEncryptionConfiguration",
	"delivery_stream_name":                     "description.DeliveryStream.DeliveryStreamName",
	"delivery_stream_status":                   "description.DeliveryStream.DeliveryStreamStatus",
	"delivery_stream_type":                     "description.DeliveryStream.DeliveryStreamType",
	"destinations":                             "description.DeliveryStream.Destinations",
	"failure_description":                      "description.DeliveryStream.FailureDescription",
	"has_more_destinations":                    "description.DeliveryStream.HasMoreDestinations",
	"kaytu_account_id":                         "metadata.SourceID",
	"last_update_timestamp":                    "description.DeliveryStream.LastUpdateTimestamp",
	"source":                                   "description.DeliveryStream.Source",
	"tags":                                     "description.Tags",
	"tags_src":                                 "description.Tags",
	"title":                                    "description.DeliveryStream.DeliveryStreamName",
	"version_id":                               "description.DeliveryStream.VersionId",
}

func ListFirehoseDeliveryStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFirehoseDeliveryStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFirehoseDeliveryStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, listFirehoseDeliveryStreamFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFirehoseDeliveryStreamFilters = map[string]string{
	"akas":             "description.DeliveryStream.DeliveryStreamARN",
	"arn":              "description.DeliveryStream.DeliveryStreamARN",
	"create_timestamp": "description.DeliveryStream.CreateTimestamp",
	"delivery_stream_encryption_configuration": "description.DeliveryStream.DeliveryStreamEncryptionConfiguration",
	"delivery_stream_name":                     "description.DeliveryStream.DeliveryStreamName",
	"delivery_stream_status":                   "description.DeliveryStream.DeliveryStreamStatus",
	"delivery_stream_type":                     "description.DeliveryStream.DeliveryStreamType",
	"destinations":                             "description.DeliveryStream.Destinations",
	"failure_description":                      "description.DeliveryStream.FailureDescription",
	"has_more_destinations":                    "description.DeliveryStream.HasMoreDestinations",
	"kaytu_account_id":                         "metadata.SourceID",
	"last_update_timestamp":                    "description.DeliveryStream.LastUpdateTimestamp",
	"source":                                   "description.DeliveryStream.Source",
	"tags":                                     "description.Tags",
	"tags_src":                                 "description.Tags",
	"title":                                    "description.DeliveryStream.DeliveryStreamName",
	"version_id":                               "description.DeliveryStream.VersionId",
}

func GetFirehoseDeliveryStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFirehoseDeliveryStream")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFirehoseDeliveryStreamPaginator(essdk.BuildFilter(d.KeyColumnQuals, getFirehoseDeliveryStreamFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: FirehoseDeliveryStream =============================

// ==========================  START: LightsailInstance =============================

type LightsailInstance struct {
	Description   aws.LightsailInstanceDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type LightsailInstanceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  LightsailInstance `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type LightsailInstanceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []LightsailInstanceHit `json:"hits"`
}

type LightsailInstanceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  LightsailInstanceHits `json:"hits"`
}

type LightsailInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLightsailInstancePaginator(filters []essdk.BoolFilter, limit *int64) (LightsailInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lightsail_instance", filters, limit)
	if err != nil {
		return LightsailInstancePaginator{}, err
	}

	p := LightsailInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LightsailInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LightsailInstancePaginator) NextPage(ctx context.Context) ([]LightsailInstance, error) {
	var response LightsailInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LightsailInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLightsailInstanceFilters = map[string]string{
	"akas":               "description.Instance.Arn",
	"arn":                "description.Instance.Arn",
	"availability_zone":  "description.Instance.Location.AvailabilityZone",
	"blueprint_id":       "description.Instance.BlueprintId",
	"blueprint_name":     "description.Instance.BlueprintName",
	"bundle_id":          "description.Instance.BundleId",
	"created_at":         "description.Instance.CreatedAt",
	"hardware":           "description.Instance.Hardware",
	"ip_address_type":    "description.Instance.IpAddressType",
	"ip_v6_addresses":    "description.Instance.Ipv6Addresses",
	"is_static_ip":       "description.Instance.IsStaticIp",
	"kaytu_account_id":   "metadata.SourceID",
	"metadata_options":   "description.Instance.MetadataOptions",
	"name":               "description.Instance.Name",
	"networking":         "description.Instance.Networking",
	"private_ip_address": "description.Instance.PrivateIpAddress",
	"public_ip_address":  "description.Instance.PublicIpAddress",
	"resource_type":      "description.Instance.ResourceType",
	"ssh_key_name":       "description.Instance.SshKeyName",
	"state_code":         "description.Instance.State.Code",
	"state_name":         "description.Instance.State.Name",
	"support_code":       "description.Instance.SupportCode",
	"tags":               "description.Instance.Tags",
	"tags_src":           "description.Instance.Tags",
	"title":              "description.Instance.Name",
	"username":           "description.Instance.Username",
}

func ListLightsailInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLightsailInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLightsailInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listLightsailInstanceFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLightsailInstanceFilters = map[string]string{
	"akas":               "description.Instance.Arn",
	"arn":                "description.Instance.Arn",
	"availability_zone":  "description.Instance.Location.AvailabilityZone",
	"blueprint_id":       "description.Instance.BlueprintId",
	"blueprint_name":     "description.Instance.BlueprintName",
	"bundle_id":          "description.Instance.BundleId",
	"created_at":         "description.Instance.CreatedAt",
	"hardware":           "description.Instance.Hardware",
	"ip_address_type":    "description.Instance.IpAddressType",
	"ip_v6_addresses":    "description.Instance.Ipv6Addresses",
	"is_static_ip":       "description.Instance.IsStaticIp",
	"kaytu_account_id":   "metadata.SourceID",
	"metadata_options":   "description.Instance.MetadataOptions",
	"name":               "description.Instance.",
	"networking":         "description.Instance.Networking",
	"private_ip_address": "description.Instance.PrivateIpAddress",
	"public_ip_address":  "description.Instance.PublicIpAddress",
	"resource_type":      "description.Instance.ResourceType",
	"ssh_key_name":       "description.Instance.SshKeyName",
	"state_code":         "description.Instance.State.Code",
	"state_name":         "description.Instance.State.Name",
	"support_code":       "description.Instance.SupportCode",
	"tags":               "description.Instance.Tags",
	"tags_src":           "description.Instance.Tags",
	"title":              "description.Instance.Name",
	"username":           "description.Instance.Username",
}

func GetLightsailInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLightsailInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLightsailInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getLightsailInstanceFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LightsailInstance =============================

// ==========================  START: Macie2ClassificationJob =============================

type Macie2ClassificationJob struct {
	Description   aws.Macie2ClassificationJobDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type Macie2ClassificationJobHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  Macie2ClassificationJob `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type Macie2ClassificationJobHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []Macie2ClassificationJobHit `json:"hits"`
}

type Macie2ClassificationJobSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  Macie2ClassificationJobHits `json:"hits"`
}

type Macie2ClassificationJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMacie2ClassificationJobPaginator(filters []essdk.BoolFilter, limit *int64) (Macie2ClassificationJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_macie2_classificationjob", filters, limit)
	if err != nil {
		return Macie2ClassificationJobPaginator{}, err
	}

	p := Macie2ClassificationJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Macie2ClassificationJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Macie2ClassificationJobPaginator) NextPage(ctx context.Context) ([]Macie2ClassificationJob, error) {
	var response Macie2ClassificationJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Macie2ClassificationJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMacie2ClassificationJobFilters = map[string]string{
	"akas":                       "description.ClassificationJob.JobArn",
	"arn":                        "description.ClassificationJob.JobArn",
	"bucket_definitions":         "description.ClassificationJob.S3JobDefinition.BucketDefinitions",
	"client_token":               "description.ClassificationJob.ClientToken",
	"created_at":                 "description.ClassificationJob.CreatedAt",
	"custom_data_identifier_ids": "description.ClassificationJob.CustomDataIdentifierIds",
	"job_id":                     "description.ClassificationJob.JobId",
	"job_status":                 "description.ClassificationJob.JobStatus",
	"job_type":                   "description.ClassificationJob.JobType",
	"kaytu_account_id":           "metadata.SourceID",
	"last_run_error_status":      "description.ClassificationJob.LastRunErrorStatus",
	"last_run_time":              "description.ClassificationJob.LastRunTime",
	"name":                       "description.ClassificationJob.Name",
	"s3_job_definition":          "description.ClassificationJob.S3JobDefinition",
	"sampling_percentage":        "description.ClassificationJob.SamplingPercentage",
	"schedule_frequency":         "description.ClassificationJob.ScheduleFrequency",
	"statistics":                 "description.ClassificationJob.Statistics",
	"tags":                       "description.ClassificationJob.Tags",
	"title":                      "description.ClassificationJob.Name",
	"user_paused_details":        "description.ClassificationJob.UserPausedDetails",
}

func ListMacie2ClassificationJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMacie2ClassificationJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMacie2ClassificationJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMacie2ClassificationJobFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMacie2ClassificationJobFilters = map[string]string{
	"akas":                       "description.ClassificationJob.JobArn",
	"arn":                        "description.ClassificationJob.JobArn",
	"bucket_definitions":         "description.ClassificationJob.S3JobDefinition.BucketDefinitions",
	"client_token":               "description.ClassificationJob.ClientToken",
	"created_at":                 "description.ClassificationJob.CreatedAt",
	"custom_data_identifier_ids": "description.ClassificationJob.CustomDataIdentifierIds",
	"job_id":                     "description.ClassificationJob.JobId",
	"job_status":                 "description.ClassificationJob.JobStatus",
	"job_type":                   "description.ClassificationJob.JobType",
	"kaytu_account_id":           "metadata.SourceID",
	"last_run_error_status":      "description.ClassificationJob.LastRunErrorStatus",
	"last_run_time":              "description.ClassificationJob.LastRunTime",
	"name":                       "description.ClassificationJob.Name",
	"s3_job_definition":          "description.ClassificationJob.S3JobDefinition",
	"sampling_percentage":        "description.ClassificationJob.SamplingPercentage",
	"schedule_frequency":         "description.ClassificationJob.ScheduleFrequency",
	"statistics":                 "description.ClassificationJob.Statistics",
	"tags":                       "description.ClassificationJob.Tags",
	"title":                      "description.ClassificationJob.Name",
	"user_paused_details":        "description.ClassificationJob.UserPausedDetails",
}

func GetMacie2ClassificationJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMacie2ClassificationJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMacie2ClassificationJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMacie2ClassificationJobFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Macie2ClassificationJob =============================

// ==========================  START: MediaStoreContainer =============================

type MediaStoreContainer struct {
	Description   aws.MediaStoreContainerDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type MediaStoreContainerHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  MediaStoreContainer `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type MediaStoreContainerHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []MediaStoreContainerHit `json:"hits"`
}

type MediaStoreContainerSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  MediaStoreContainerHits `json:"hits"`
}

type MediaStoreContainerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMediaStoreContainerPaginator(filters []essdk.BoolFilter, limit *int64) (MediaStoreContainerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mediastore_container", filters, limit)
	if err != nil {
		return MediaStoreContainerPaginator{}, err
	}

	p := MediaStoreContainerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MediaStoreContainerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MediaStoreContainerPaginator) NextPage(ctx context.Context) ([]MediaStoreContainer, error) {
	var response MediaStoreContainerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MediaStoreContainer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMediaStoreContainerFilters = map[string]string{
	"access_logging_enabled": "description.Container.AccessLoggingEnabled",
	"akas":                   "description.Container.ARN",
	"arn":                    "description.Container.ARN",
	"creation_time":          "description.Container.CreationTime",
	"endpoint":               "description.Container.Endpoint",
	"kaytu_account_id":       "metadata.SourceID",
	"name":                   "description.Container.Name",
	"policy":                 "description.Policy",
	"policy_std":             "description.Policy",
	"status":                 "description.Container.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Container.Name",
}

func ListMediaStoreContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMediaStoreContainer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMediaStoreContainerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMediaStoreContainerFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMediaStoreContainerFilters = map[string]string{
	"access_logging_enabled": "description.Container.AccessLoggingEnabled",
	"akas":                   "description.Container.ARN",
	"arn":                    "description.Container.ARN",
	"creation_time":          "description.Container.CreationTime",
	"endpoint":               "description.Container.Endpoint",
	"kaytu_account_id":       "metadata.SourceID",
	"name":                   "description.Container.Name",
	"policy":                 "description.Policy",
	"policy_std":             "description.Policy",
	"status":                 "description.Container.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Container.Name",
}

func GetMediaStoreContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMediaStoreContainer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMediaStoreContainerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMediaStoreContainerFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MediaStoreContainer =============================

// ==========================  START: MgnApplication =============================

type MgnApplication struct {
	Description   aws.MgnApplicationDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type MgnApplicationHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  MgnApplication `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type MgnApplicationHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []MgnApplicationHit `json:"hits"`
}

type MgnApplicationSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  MgnApplicationHits `json:"hits"`
}

type MgnApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMgnApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (MgnApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mgn_application", filters, limit)
	if err != nil {
		return MgnApplicationPaginator{}, err
	}

	p := MgnApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MgnApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MgnApplicationPaginator) NextPage(ctx context.Context) ([]MgnApplication, error) {
	var response MgnApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MgnApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMgnApplicationFilters = map[string]string{
	"akas":                          "description.Application.Arn",
	"application_aggregated_status": "description.Application.ApplicationAggregatedStatus",
	"application_id":                "description.Application.ApplicationID",
	"arn":                           "description.Application.Arn",
	"creation_date_time":            "description.Application.CreationDateTime",
	"description":                   "description.Application.Description",
	"is_archived":                   "description.Application.IsArchived",
	"kaytu_account_id":              "metadata.SourceID",
	"last_modified_date_time":       "description.Application.LastModifiedDateTime",
	"name":                          "description.Application.Name",
	"tags":                          "description.Application.Tags",
	"title":                         "description.Application.Name",
	"wave_id":                       "description.Application.WaveID",
}

func ListMgnApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMgnApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMgnApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMgnApplicationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMgnApplicationFilters = map[string]string{
	"akas":                          "description.Application.Arn",
	"application_aggregated_status": "description.Application.ApplicationAggregatedStatus",
	"application_id":                "description.Application.ApplicationID",
	"arn":                           "description.Application.Arn",
	"creation_date_time":            "description.Application.CreationDateTime",
	"description":                   "description.Application.Description",
	"is_archived":                   "description.Application.IsArchived",
	"kaytu_account_id":              "metadata.SourceID",
	"last_modified_date_time":       "description.Application.LastModifiedDateTime",
	"name":                          "description.Application.Name",
	"tags":                          "description.Application.Tags",
	"title":                         "description.Application.Name",
	"wave_id":                       "description.Application.WaveID",
}

func GetMgnApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMgnApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMgnApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMgnApplicationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MgnApplication =============================

// ==========================  START: SecurityLakeDataLake =============================

type SecurityLakeDataLake struct {
	Description   aws.SecurityLakeDataLakeDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SecurityLakeDataLakeHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SecurityLakeDataLake `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SecurityLakeDataLakeHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SecurityLakeDataLakeHit `json:"hits"`
}

type SecurityLakeDataLakeSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SecurityLakeDataLakeHits `json:"hits"`
}

type SecurityLakeDataLakePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityLakeDataLakePaginator(filters []essdk.BoolFilter, limit *int64) (SecurityLakeDataLakePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securitylake_datalake", filters, limit)
	if err != nil {
		return SecurityLakeDataLakePaginator{}, err
	}

	p := SecurityLakeDataLakePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityLakeDataLakePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityLakeDataLakePaginator) NextPage(ctx context.Context) ([]SecurityLakeDataLake, error) {
	var response SecurityLakeDataLakeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityLakeDataLake
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityLakeDataLakeFilters = map[string]string{
	"encryption_key":                  "description.DataLake.EncryptionKey",
	"kaytu_account_id":                "metadata.SourceID",
	"replication_destination_regions": "description.DataLake.ReplicationDestinationRegions",
	"replication_role_arn":            "description.DataLake.ReplicationRoleArn",
	"retention_settings":              "description.DataLake.RetentionSettings",
	"s3_bucket_arn":                   "description.DataLake.S3BucketArn",
	"status":                          "description.DataLake.Status",
	"tags":                            "description.DataLake.TagsMap",
}

func ListSecurityLakeDataLake(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityLakeDataLake")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityLakeDataLakePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityLakeDataLakeFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityLakeDataLakeFilters = map[string]string{
	"encryption_key":                  "description.DataLake.EncryptionKey",
	"kaytu_account_id":                "metadata.SourceID",
	"replication_destination_regions": "description.DataLake.ReplicationDestinationRegions",
	"replication_role_arn":            "description.DataLake.ReplicationRoleArn",
	"retention_settings":              "description.DataLake.RetentionSettings",
	"s3_bucket_arn":                   "description.DataLake.S3BucketArn",
	"status":                          "description.DataLake.Status",
	"tags":                            "description.DataLake.TagsMap",
}

func GetSecurityLakeDataLake(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityLakeDataLake")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityLakeDataLakePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityLakeDataLakeFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityLakeDataLake =============================

// ==========================  START: SecurityLakeSubscriber =============================

type SecurityLakeSubscriber struct {
	Description   aws.SecurityLakeSubscriberDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type SecurityLakeSubscriberHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  SecurityLakeSubscriber `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type SecurityLakeSubscriberHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []SecurityLakeSubscriberHit `json:"hits"`
}

type SecurityLakeSubscriberSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  SecurityLakeSubscriberHits `json:"hits"`
}

type SecurityLakeSubscriberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityLakeSubscriberPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityLakeSubscriberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securitylake_subscriber", filters, limit)
	if err != nil {
		return SecurityLakeSubscriberPaginator{}, err
	}

	p := SecurityLakeSubscriberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityLakeSubscriberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityLakeSubscriberPaginator) NextPage(ctx context.Context) ([]SecurityLakeSubscriber, error) {
	var response SecurityLakeSubscriberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityLakeSubscriber
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityLakeSubscriberFilters = map[string]string{
	"access_types":           "description.Subscriber.AccessTypes",
	"akas":                   "description.Subscriber.ProductArn",
	"created_at":             "description.Subscriber.CreatedAt",
	"external_id":            "description.Subscriber.ExternalId",
	"kaytu_account_id":       "metadata.SourceID",
	"role_arn":               "description.Subscriber.RoleArn",
	"s3_bucket_arn":          "description.Subscriber.S3BucketArn",
	"sns_arn":                "description.Subscriber.SnsArn",
	"source_types":           "description.Subscriber.SourceTypes",
	"subscriber_description": "description.Subscriber.SubscriberDescription",
	"subscriber_name":        "description.Subscriber.SubscriberName",
	"subscription_endpoint":  "description.Subscriber.SubscriptionEndpoint",
	"subscription_id":        "description.Subscriber.SubscriptionId",
	"subscription_protocol":  "description.Subscriber.SubscriptionProtocol",
	"subscription_status":    "description.Subscriber.SubscriptionStatus",
	"title":                  "description.Subscriber.SubscriberName",
	"updated_at":             "description.Subscriber.UpdatedAt",
}

func ListSecurityLakeSubscriber(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityLakeSubscriber")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityLakeSubscriberPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityLakeSubscriberFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityLakeSubscriberFilters = map[string]string{
	"access_types":           "description.Subscriber.AccessTypes",
	"akas":                   "description.Subscriber.ProductArn",
	"created_at":             "description.Subscriber.CreatedAt",
	"external_id":            "description.Subscriber.ExternalId",
	"kaytu_account_id":       "metadata.SourceID",
	"role_arn":               "description.Subscriber.RoleArn",
	"s3_bucket_arn":          "description.Subscriber.S3BucketArn",
	"sns_arn":                "description.Subscriber.SnsArn",
	"source_types":           "description.Subscriber.SourceTypes",
	"subscriber_description": "description.Subscriber.SubscriberDescription",
	"subscriber_id":          "description.Subscriber.SubscriberId",
	"subscriber_name":        "description.Subscriber.SubscriberName",
	"subscription_endpoint":  "description.Subscriber.SubscriptionEndpoint",
	"subscription_id":        "description.Subscriber.SubscriptionId",
	"subscription_protocol":  "description.Subscriber.SubscriptionProtocol",
	"subscription_status":    "description.Subscriber.SubscriptionStatus",
	"title":                  "description.Subscriber.SubscriberName",
	"updated_at":             "description.Subscriber.UpdatedAt",
}

func GetSecurityLakeSubscriber(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityLakeSubscriber")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityLakeSubscriberPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityLakeSubscriberFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityLakeSubscriber =============================

// ==========================  START: RamPrincipalAssociation =============================

type RamPrincipalAssociation struct {
	Description   aws.RamPrincipalAssociationDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type RamPrincipalAssociationHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  RamPrincipalAssociation `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type RamPrincipalAssociationHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []RamPrincipalAssociationHit `json:"hits"`
}

type RamPrincipalAssociationSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  RamPrincipalAssociationHits `json:"hits"`
}

type RamPrincipalAssociationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRamPrincipalAssociationPaginator(filters []essdk.BoolFilter, limit *int64) (RamPrincipalAssociationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ram_principalassociation", filters, limit)
	if err != nil {
		return RamPrincipalAssociationPaginator{}, err
	}

	p := RamPrincipalAssociationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RamPrincipalAssociationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RamPrincipalAssociationPaginator) NextPage(ctx context.Context) ([]RamPrincipalAssociation, error) {
	var response RamPrincipalAssociationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RamPrincipalAssociation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRamPrincipalAssociationFilters = map[string]string{
	"akas":                      "description.PrincipalAssociation.ResourceShareArn",
	"associated_entity":         "description.PrincipalAssociation.AssociatedEntity",
	"association_type":          "description.PrincipalAssociation.AssociationType",
	"creation_time":             "description.PrincipalAssociation.CreationTime",
	"external":                  "description.PrincipalAssociation.External",
	"kaytu_account_id":          "metadata.SourceID",
	"last_updated_time":         "description.PrincipalAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.PrincipalAssociation.ResourceShareArn",
	"resource_share_name":       "description.PrincipalAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.PrincipalAssociation.Status",
	"status_message":            "description.PrincipalAssociation.StatusMessage",
	"title":                     "description.PrincipalAssociation.ResourceShareName",
}

func ListRamPrincipalAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRamPrincipalAssociation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRamPrincipalAssociationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRamPrincipalAssociationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRamPrincipalAssociationFilters = map[string]string{
	"akas":                      "description.PrincipalAssociation.ResourceShareArn",
	"associated_entity":         "description.PrincipalAssociation.AssociatedEntity",
	"association_type":          "description.PrincipalAssociation.AssociationType",
	"creation_time":             "description.PrincipalAssociation.CreationTime",
	"external":                  "description.PrincipalAssociation.External",
	"kaytu_account_id":          "metadata.SourceID",
	"last_updated_time":         "description.PrincipalAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.PrincipalAssociation.ResourceShareArn",
	"resource_share_name":       "description.PrincipalAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.PrincipalAssociation.Status",
	"status_message":            "description.PrincipalAssociation.StatusMessage",
	"title":                     "description.PrincipalAssociation.ResourceShareName",
}

func GetRamPrincipalAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRamPrincipalAssociation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRamPrincipalAssociationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRamPrincipalAssociationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RamPrincipalAssociation =============================

// ==========================  START: RamResourceAssociation =============================

type RamResourceAssociation struct {
	Description   aws.RamResourceAssociationDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type RamResourceAssociationHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  RamResourceAssociation `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type RamResourceAssociationHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []RamResourceAssociationHit `json:"hits"`
}

type RamResourceAssociationSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  RamResourceAssociationHits `json:"hits"`
}

type RamResourceAssociationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRamResourceAssociationPaginator(filters []essdk.BoolFilter, limit *int64) (RamResourceAssociationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ram_resourceassociation", filters, limit)
	if err != nil {
		return RamResourceAssociationPaginator{}, err
	}

	p := RamResourceAssociationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RamResourceAssociationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RamResourceAssociationPaginator) NextPage(ctx context.Context) ([]RamResourceAssociation, error) {
	var response RamResourceAssociationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RamResourceAssociation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRamResourceAssociationFilters = map[string]string{
	"akas":                      "description.ResourceAssociation.ResourceShareArn",
	"associated_entity":         "description.ResourceAssociation.AssociatedEntity",
	"association_type":          "description.ResourceAssociation.AssociationType",
	"creation_time":             "description.ResourceAssociation.CreationTime",
	"external":                  "description.ResourceAssociation.External",
	"kaytu_account_id":          "metadata.SourceID",
	"last_updated_time":         "description.ResourceAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.ResourceAssociation.ResourceShareArn",
	"resource_share_name":       "description.ResourceAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.ResourceAssociation.Status",
	"status_message":            "description.ResourceAssociation.StatusMessage",
	"title":                     "description.ResourceAssociation.ResourceShareName",
}

func ListRamResourceAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRamResourceAssociation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRamResourceAssociationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRamResourceAssociationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRamResourceAssociationFilters = map[string]string{
	"akas":                      "description.ResourceAssociation.ResourceShareArn",
	"associated_entity":         "description.ResourceAssociation.AssociatedEntity",
	"association_type":          "description.ResourceAssociation.AssociationType",
	"creation_time":             "description.ResourceAssociation.CreationTime",
	"external":                  "description.ResourceAssociation.External",
	"kaytu_account_id":          "metadata.SourceID",
	"last_updated_time":         "description.ResourceAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.ResourceAssociation.ResourceShareArn",
	"resource_share_name":       "description.ResourceAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.ResourceAssociation.Status",
	"status_message":            "description.ResourceAssociation.StatusMessage",
	"title":                     "description.ResourceAssociation.ResourceShareName",
}

func GetRamResourceAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRamResourceAssociation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRamResourceAssociationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRamResourceAssociationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RamResourceAssociation =============================

// ==========================  START: ServerlessApplicationRepositoryApplication =============================

type ServerlessApplicationRepositoryApplication struct {
	Description   aws.ServerlessApplicationRepositoryApplicationDescription `json:"description"`
	Metadata      aws.Metadata                                              `json:"metadata"`
	ResourceJobID int                                                       `json:"resource_job_id"`
	SourceJobID   int                                                       `json:"source_job_id"`
	ResourceType  string                                                    `json:"resource_type"`
	SourceType    string                                                    `json:"source_type"`
	ID            string                                                    `json:"id"`
	ARN           string                                                    `json:"arn"`
	SourceID      string                                                    `json:"source_id"`
}

type ServerlessApplicationRepositoryApplicationHit struct {
	ID      string                                     `json:"_id"`
	Score   float64                                    `json:"_score"`
	Index   string                                     `json:"_index"`
	Type    string                                     `json:"_type"`
	Version int64                                      `json:"_version,omitempty"`
	Source  ServerlessApplicationRepositoryApplication `json:"_source"`
	Sort    []interface{}                              `json:"sort"`
}

type ServerlessApplicationRepositoryApplicationHits struct {
	Total essdk.SearchTotal                               `json:"total"`
	Hits  []ServerlessApplicationRepositoryApplicationHit `json:"hits"`
}

type ServerlessApplicationRepositoryApplicationSearchResponse struct {
	PitID string                                         `json:"pit_id"`
	Hits  ServerlessApplicationRepositoryApplicationHits `json:"hits"`
}

type ServerlessApplicationRepositoryApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServerlessApplicationRepositoryApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (ServerlessApplicationRepositoryApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_severlessapplicationrepository_application", filters, limit)
	if err != nil {
		return ServerlessApplicationRepositoryApplicationPaginator{}, err
	}

	p := ServerlessApplicationRepositoryApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServerlessApplicationRepositoryApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServerlessApplicationRepositoryApplicationPaginator) NextPage(ctx context.Context) ([]ServerlessApplicationRepositoryApplication, error) {
	var response ServerlessApplicationRepositoryApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServerlessApplicationRepositoryApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServerlessApplicationRepositoryApplicationFilters = map[string]string{
	"akas":                "description.Application.ApplicationId",
	"arn":                 "description.Application.ApplicationId",
	"author":              "description.Application.Author",
	"creation_time":       "description.Application.CreationTime",
	"description":         "description.Application.Description",
	"home_page_url":       "description.Application.HomePageUrl",
	"is_verified_author":  "description.Application.IsVerifiedAuthor",
	"kaytu_account_id":    "metadata.SourceID",
	"labels":              "description.Application.Labels",
	"license_url":         "description.Application.LicenseUrl",
	"name":                "description.Application.Name",
	"readme_url":          "description.Application.ReadmeUrl",
	"spdx_license_id":     "description.Application.SpdxLicenseId",
	"statements":          "description.Statements",
	"title":               "description.Application.Name",
	"verified_author_url": "description.Application.VerifiedAuthorUrl",
	"version":             "description.Application.Version",
}

func ListServerlessApplicationRepositoryApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServerlessApplicationRepositoryApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewServerlessApplicationRepositoryApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listServerlessApplicationRepositoryApplicationFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getServerlessApplicationRepositoryApplicationFilters = map[string]string{
	"akas":                "description.Application.ApplicationId",
	"arn":                 "description.Application.ApplicationId",
	"author":              "description.Application.Author",
	"creation_time":       "description.Application.CreationTime",
	"description":         "description.Application.Description",
	"home_page_url":       "description.Application.HomePageUrl",
	"is_verified_author":  "description.Application.IsVerifiedAuthor",
	"kaytu_account_id":    "metadata.SourceID",
	"labels":              "description.Application.Labels",
	"license_url":         "description.Application.LicenseUrl",
	"name":                "description.Application.Name",
	"readme_url":          "description.Application.ReadmeUrl",
	"spdx_license_id":     "description.Application.SpdxLicenseId",
	"statements":          "description.Statements",
	"title":               "description.Application.Name",
	"verified_author_url": "description.Application.VerifiedAuthorUrl",
	"version":             "description.Application.Version",
}

func GetServerlessApplicationRepositoryApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServerlessApplicationRepositoryApplication")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewServerlessApplicationRepositoryApplicationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getServerlessApplicationRepositoryApplicationFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ServerlessApplicationRepositoryApplication =============================

// ==========================  START: ServiceQuotasServiceQuotaChangeRequest =============================

type ServiceQuotasServiceQuotaChangeRequest struct {
	Description   aws.ServiceQuotasServiceQuotaChangeRequestDescription `json:"description"`
	Metadata      aws.Metadata                                          `json:"metadata"`
	ResourceJobID int                                                   `json:"resource_job_id"`
	SourceJobID   int                                                   `json:"source_job_id"`
	ResourceType  string                                                `json:"resource_type"`
	SourceType    string                                                `json:"source_type"`
	ID            string                                                `json:"id"`
	ARN           string                                                `json:"arn"`
	SourceID      string                                                `json:"source_id"`
}

type ServiceQuotasServiceQuotaChangeRequestHit struct {
	ID      string                                 `json:"_id"`
	Score   float64                                `json:"_score"`
	Index   string                                 `json:"_index"`
	Type    string                                 `json:"_type"`
	Version int64                                  `json:"_version,omitempty"`
	Source  ServiceQuotasServiceQuotaChangeRequest `json:"_source"`
	Sort    []interface{}                          `json:"sort"`
}

type ServiceQuotasServiceQuotaChangeRequestHits struct {
	Total essdk.SearchTotal                           `json:"total"`
	Hits  []ServiceQuotasServiceQuotaChangeRequestHit `json:"hits"`
}

type ServiceQuotasServiceQuotaChangeRequestSearchResponse struct {
	PitID string                                     `json:"pit_id"`
	Hits  ServiceQuotasServiceQuotaChangeRequestHits `json:"hits"`
}

type ServiceQuotasServiceQuotaChangeRequestPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceQuotasServiceQuotaChangeRequestPaginator(filters []essdk.BoolFilter, limit *int64) (ServiceQuotasServiceQuotaChangeRequestPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicequotas_servicequotachangerequest", filters, limit)
	if err != nil {
		return ServiceQuotasServiceQuotaChangeRequestPaginator{}, err
	}

	p := ServiceQuotasServiceQuotaChangeRequestPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceQuotasServiceQuotaChangeRequestPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceQuotasServiceQuotaChangeRequestPaginator) NextPage(ctx context.Context) ([]ServiceQuotasServiceQuotaChangeRequest, error) {
	var response ServiceQuotasServiceQuotaChangeRequestSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceQuotasServiceQuotaChangeRequest
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceQuotasServiceQuotaChangeRequestFilters = map[string]string{
	"akas":             "aRN",
	"case_id":          "description.ServiceQuotaChangeRequest.CaseId",
	"created":          "description.ServiceQuotaChangeRequest.Created",
	"desired_value":    "description.ServiceQuotaChangeRequest.DesiredValue",
	"global_quota":     "description.ServiceQuotaChangeRequest.GlobalQuota",
	"id":               "description.ServiceQuotaChangeRequest.Id",
	"kaytu_account_id": "metadata.SourceID",
	"last_updated":     "description.ServiceQuotaChangeRequest.LastUpdated",
	"quota_arn":        "description.ServiceQuotaChangeRequest.QuotaArn",
	"quota_code":       "description.ServiceQuotaChangeRequest.QuotaCode",
	"quota_name":       "description.ServiceQuotaChangeRequest.QuotaName",
	"requester":        "description.ServiceQuotaChangeRequest.Requester",
	"service_code":     "description.ServiceQuotaChangeRequest.ServiceCode",
	"service_name":     "description.ServiceQuotaChangeRequest.ServiceName",
	"status":           "description.ServiceQuotaChangeRequest.Status",
	"tags_src":         "description.Tags",
	"title":            "description.ServiceQuotaChangeRequest.QuotaName",
	"unit":             "description.ServiceQuotaChangeRequest.Unit",
}

func ListServiceQuotasServiceQuotaChangeRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceQuotasServiceQuotaChangeRequest")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewServiceQuotasServiceQuotaChangeRequestPaginator(essdk.BuildFilter(d.KeyColumnQuals, listServiceQuotasServiceQuotaChangeRequestFilters, "aws", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getServiceQuotasServiceQuotaChangeRequestFilters = map[string]string{
	"akas":             "aRN",
	"case_id":          "description.ServiceQuotaChangeRequest.CaseId",
	"created":          "description.ServiceQuotaChangeRequest.Created",
	"desired_value":    "description.ServiceQuotaChangeRequest.DesiredValue",
	"global_quota":     "description.ServiceQuotaChangeRequest.GlobalQuota",
	"id":               "description.ServiceQuotaChangeRequest.Id",
	"kaytu_account_id": "metadata.SourceID",
	"last_updated":     "description.ServiceQuotaChangeRequest.LastUpdated",
	"quota_arn":        "description.ServiceQuotaChangeRequest.QuotaArn",
	"quota_code":       "description.ServiceQuotaChangeRequest.QuotaCode",
	"quota_name":       "description.ServiceQuotaChangeRequest.QuotaName",
	"requester":        "description.ServiceQuotaChangeRequest.Requester",
	"service_code":     "description.ServiceQuotaChangeRequest.ServiceCode",
	"service_name":     "description.ServiceQuotaChangeRequest.ServiceName",
	"status":           "description.ServiceQuotaChangeRequest.Status",
	"tags_src":         "description.Tags",
	"title":            "description.ServiceQuotaChangeRequest.QuotaName",
	"unit":             "description.ServiceQuotaChangeRequest.Unit",
}

func GetServiceQuotasServiceQuotaChangeRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceQuotasServiceQuotaChangeRequest")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewServiceQuotasServiceQuotaChangeRequestPaginator(essdk.BuildFilter(d.KeyColumnQuals, getServiceQuotasServiceQuotaChangeRequestFilters, "aws", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ServiceQuotasServiceQuotaChangeRequest =============================
